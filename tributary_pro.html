<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tributary Area Calculator Pro | Pang-Masa Engineering</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00d4ff;
            --secondary: #7c3aed;
            --dark: #0f1419;
            --darker: #080b0e;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0d1117 100%);
            min-height: 100vh;
            color: #e6edf3;
            overflow-x: hidden;
            /* Allow vertical scroll, hide horizontal */
        }

        /* Header */
        .header {
            background: var(--darker);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            border-bottom: 1px solid var(--border);
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .logo h1 span {
            color: var(--primary);
        }

        .header-actions {
            display: flex;
            gap: 10px;
        }

        /* Main Layout */
        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 320px;
            height: calc(100vh - 60px);
        }

        /* Panels */
        .panel {
            background: var(--glass);
            border-right: 1px solid var(--border);
            padding: 16px;
            overflow-y: auto;
        }

        .panel:last-child {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        /* Grid Spans Section */
        .spans-section {
            margin-bottom: 20px;
        }

        .spans-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 12px;
        }

        .spans-header h3 {
            font-size: 0.85rem;
            color: var(--primary);
        }

        .add-btn {
            width: 28px;
            height: 28px;
            background: var(--primary);
            border: none;
            border-radius: 6px;
            color: #000;
            font-size: 16px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.2s;
        }

        .add-btn:hover {
            transform: scale(1.1);
        }

        .span-item {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 10px;
            background: rgba(0, 0, 0, 0.3);
            padding: 8px 12px;
            border-radius: 8px;
        }

        .span-label {
            font-size: 0.75rem;
            color: #8b949e;
            width: 30px;
        }

        .span-slider {
            flex: 1;
            -webkit-appearance: none;
            height: 6px;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 3px;
            outline: none;
        }

        .span-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 16px;
            height: 16px;
            background: var(--primary);
            border-radius: 50%;
            cursor: pointer;
            transition: all 0.2s;
        }

        .span-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
            box-shadow: 0 0 10px var(--primary);
        }

        .span-value {
            width: 55px;
            padding: 4px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: #fff;
            font-size: 0.8rem;
            text-align: center;
        }

        .span-delete {
            width: 24px;
            height: 24px;
            background: transparent;
            border: 1px solid rgba(255, 100, 100, 0.3);
            border-radius: 4px;
            color: #ff6464;
            cursor: pointer;
            font-size: 14px;
            transition: all 0.2s;
        }

        .span-delete:hover {
            background: rgba(255, 100, 100, 0.2);
        }

        /* Parameters Section */
        .param-group {
            margin-bottom: 20px;
        }

        .param-group h3 {
            font-size: 0.85rem;
            color: var(--primary);
            margin-bottom: 12px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .param-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .param-item label {
            display: block;
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .param-item input,
        .param-item select {
            width: 100%;
            padding: 6px 8px;
            background: rgba(0, 0, 0, 0.4);
            border: 1px solid var(--border);
            border-radius: 4px;
            color: #fff;
            font-size: 0.85rem;
        }

        .param-item input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* Canvas Area */
        .canvas-area {
            display: flex;
            flex-direction: column;
            background: var(--darker);
            position: relative;
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border);
        }

        .tool-btn {
            padding: 8px 14px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #8b949e;
            font-size: 0.8rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .tool-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mainCanvas {
            position: absolute;
            top: 0;
            left: 0;
        }

        .canvas-info {
            position: absolute;
            bottom: 16px;
            left: 16px;
            display: flex;
            gap: 15px;
            font-size: 0.75rem;
            color: #8b949e;
        }

        /* Results Panel */
        .summary-cards {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .summary-card {
            background: linear-gradient(135deg, rgba(0, 212, 255, 0.1), rgba(124, 58, 237, 0.1));
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 12px;
            text-align: center;
        }

        .summary-card.full-width {
            grid-column: span 2;
        }

        .summary-card .label {
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .summary-card .value {
            font-size: 1.4rem;
            font-weight: 700;
            color: var(--primary);
        }

        .summary-card .unit {
            font-size: 0.7rem;
            color: #8b949e;
        }

        /* Column Table */
        .column-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.75rem;
        }

        .column-table th {
            text-align: left;
            padding: 8px 6px;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
            font-weight: 600;
        }

        .column-table td {
            padding: 8px 6px;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        .column-table tr:hover {
            background: rgba(255, 255, 255, 0.03);
        }

        .column-table .col-id {
            color: var(--primary);
            font-weight: 600;
        }

        .column-table .col-area {
            color: #7ee787;
        }

        .column-table .col-load {
            color: #ffa657;
        }

        /* Export Button */
        .export-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 16px;
            transition: all 0.2s;
        }

        .export-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
        }

        /* Tooltip */
        .tooltip {
            position: fixed;
            background: rgba(0, 0, 0, 0.95);
            border: 1px solid var(--primary);
            border-radius: 8px;
            padding: 10px 14px;
            font-size: 0.8rem;
            pointer-events: none;
            z-index: 1000;
            display: none;
            max-width: 200px;
        }

        .tooltip .tt-title {
            color: var(--primary);
            font-weight: 600;
            margin-bottom: 6px;
        }

        .tooltip .tt-row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 3px;
        }

        .tooltip .tt-label {
            color: #8b949e;
        }

        .tooltip .tt-value {
            color: #fff;
            font-weight: 500;
        }

        /* Presets */
        .presets {
            display: flex;
            gap: 6px;
            flex-wrap: wrap;
            margin-bottom: 15px;
        }

        .preset-btn {
            padding: 6px 12px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 20px;
            color: #8b949e;
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .preset-btn:hover {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .export-menu-btn {
            display: block;
            width: 100%;
            padding: 8px 16px;
            background: transparent;
            border: none;
            color: #e6edf3;
            font-size: 0.8rem;
            text-align: left;
            cursor: pointer;
            transition: all 0.2s;
        }

        .export-menu-btn:hover {
            background: rgba(0, 212, 255, 0.2);
        }
    </style>
</head>

<body>
    <div class="header">
        <div class="logo">
            <div class="logo-icon">üìê</div>
            <h1>Tributary <span>Pro</span></h1>
        </div>
        <div class="header-actions">
            <button class="tool-btn" onclick="saveProject()">üíæ Save</button>
            <div style="position: relative; display: inline-block;">
                <button class="tool-btn" onclick="toggleExportMenu()" id="exportBtn">üì§ Export ‚ñº</button>
                <div id="exportMenu"
                    style="display: none; position: absolute; right: 0; top: 100%; background: #1a1f2e; border: 1px solid rgba(255,255,255,0.1); border-radius: 8px; padding: 8px 0; min-width: 180px; z-index: 100;">
                    <div style="padding: 4px 12px; color: #8b949e; font-size: 0.7rem;">Analysis Software</div>
                    <button class="export-menu-btn" onclick="exportSTAAD()">üî∑ STAAD.Pro (.std)</button>
                    <button class="export-menu-btn" onclick="exportETABS()">üî∂ ETABS (.e2k)</button>
                    <button class="export-menu-btn" onclick="exportSAP2000()">üü¢ SAP2000 (.s2k)</button>
                    <button class="export-menu-btn" onclick="exportTekla()">‚¨õ Tekla (.txt)</button>
                    <div style="border-top: 1px solid rgba(255,255,255,0.1); margin: 8px 0;"></div>
                    <div style="padding: 4px 12px; color: #8b949e; font-size: 0.7rem;">Documents</div>
                    <button class="export-menu-btn" onclick="exportCSV()">üìä Excel (.csv)</button>
                    <button class="export-menu-btn" onclick="exportPDF()">üìÑ PDF Report</button>
                </div>
            </div>
            <button class="tool-btn" onclick="openIn3D()"
                style="background: linear-gradient(135deg, #7c3aed, #00d4ff);">üèóÔ∏è Open in 3D</button>
        </div>
    </div>

    <!-- Navigation Bar -->
    <nav
        style="background: rgba(10,10,15,0.95); padding: 8px 20px; display: flex; gap: 8px; border-bottom: 1px solid rgba(255,255,255,0.05); flex-wrap: wrap;">
        <a href="tributary_pro.html"
            style="padding: 6px 14px; background: linear-gradient(135deg, #00d4ff, #7c3aed); border-radius: 6px; color: #fff; text-decoration: none; font-size: 0.8rem; font-weight: 600;">üìê
            Tributary Pro</a>
        <a href="frame_viewer_3d.html"
            style="padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 6px; color: #aaa; text-decoration: none; font-size: 0.8rem;">üèóÔ∏è
            3D Viewer</a>
        <a href="footing_design.html"
            style="padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 6px; color: #aaa; text-decoration: none; font-size: 0.8rem;">üî≥
            Footing Design</a>
        <a href="foundation_plan.html"
            style="padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 6px; color: #aaa; text-decoration: none; font-size: 0.8rem;">üìã
            Foundation Plan</a>
        <a href="calculation_sheet.html"
            style="padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 6px; color: #aaa; text-decoration: none; font-size: 0.8rem;">üìÑ
            Calc Sheet</a>
        <a href="structural_analysis.html"
            style="padding: 6px 14px; background: rgba(255,255,255,0.1); border-radius: 6px; color: #aaa; text-decoration: none; font-size: 0.8rem;">‚ö°
            Analysis</a>
        <span style="flex: 1;"></span>
        <span style="color: #8b949e; font-size: 0.7rem; align-self: center;">üöÄ Pang-Masa Engineering Suite v0.1</span>
    </nav>

    <div class="app-container">
        <!-- Left Panel - Grid Setup -->
        <div class="panel">
            <div class="panel-header">Grid Configuration</div>

            <div class="presets">
                <button class="preset-btn" onclick="loadPreset('small')">Small House</button>
                <button class="preset-btn" onclick="loadPreset('medium')">2-Storey</button>
                <button class="preset-btn" onclick="loadPreset('apartment')">Apartment</button>
                <button class="preset-btn" onclick="loadPreset('custom')">Custom</button>
            </div>

            <!-- X Spans -->
            <div class="spans-section">
                <div class="spans-header">
                    <h3>üî≤ X-Direction Spans</h3>
                    <button class="add-btn" onclick="addSpan('x')">+</button>
                </div>
                <div id="xSpans">
                    <!-- Dynamic spans -->
                </div>
            </div>

            <!-- Y Spans -->
            <div class="spans-section">
                <div class="spans-header">
                    <h3>üî≤ Y-Direction Spans</h3>
                    <button class="add-btn" onclick="addSpan('y')">+</button>
                </div>
                <div id="ySpans">
                    <!-- Dynamic spans -->
                </div>
            </div>

            <!-- Parameters -->
            <div class="param-group">
                <h3>üìä Loading Parameters</h3>
                <div class="param-grid">
                    <div class="param-item">
                        <label>Dead Load (kPa)</label>
                        <input type="number" id="deadLoad" value="5.0" step="0.5" onchange="recalculate()">
                    </div>
                    <div class="param-item">
                        <label>Live Load (kPa)</label>
                        <input type="number" id="liveLoad" value="2.0" step="0.5" onchange="recalculate()">
                    </div>
                    <div class="param-item">
                        <label>Slab (mm)</label>
                        <input type="number" id="slabThick" value="150" step="10" onchange="recalculate()">
                    </div>
                </div>
            </div>

            <div class="param-group">
                <h3>üè¢ Floor Management</h3>
                <div class="param-grid">
                    <div class="param-item">
                        <label>Floor Height - All Floors (m) <span style="font-size: 0.6rem; color: #7c3aed;"
                                title="Same height for all floors. Per-floor heights coming in v2.0">‚ìò</span></label>
                        <input type="number" id="floorHeight" value="3.0" step="0.1" min="2.4" max="6"
                            onchange="recalculate()">
                    </div>
                    <div class="param-item">
                        <label>Floors: <span id="floorCount" style="color: #00d4ff; font-weight: bold;">3</span></label>
                        <div style="display: flex; gap: 5px;">
                            <button onclick="addFloor()"
                                style="flex: 1; padding: 6px; background: linear-gradient(135deg, #00d4ff, #7c3aed); border: none; border-radius: 4px; color: white; cursor: pointer; font-weight: bold;">+
                                Add Floor</button>
                            <button onclick="removeFloor()"
                                style="flex: 1; padding: 6px; background: rgba(255,100,100,0.3); border: 1px solid #ff6b6b; border-radius: 4px; color: #ff6b6b; cursor: pointer; font-weight: bold;">‚àí
                                Remove</button>
                        </div>
                    </div>
                </div>
                <input type="hidden" id="numStoreys" value="2">
            </div>

            <!-- NEW: Elevated Ground Floor & Tie Beam Section -->
            <div class="param-group" id="elevatedGFSection">
                <h3>üèóÔ∏è Elevated Ground Floor</h3>
                <div class="param-item" style="grid-column: span 2;">
                    <label style="display: flex; align-items: center; gap: 10px; cursor: pointer;">
                        <input type="checkbox" id="elevatedGF" onchange="toggleElevatedGF()"
                            style="width: 18px; height: 18px; accent-color: #00d4ff;">
                        <span>Enable Elevated GF (adds tie beams at foundation)</span>
                    </label>
                </div>

                <div id="tieBeamControls" style="display: none;">
                    <div class="param-grid" style="margin-top: 10px;">
                        <div class="param-item">
                            <label>Foundation Height (m)</label>
                            <input type="number" id="foundationHeight" value="1.5" step="0.1" min="0.5" max="5"
                                onchange="updateTieBeams()">
                        </div>
                        <div class="param-item">
                            <label>Max Span (m)</label>
                            <input type="number" id="maxTieBeamSpan" value="4.0" step="0.1" readonly
                                style="background: rgba(0,212,255,0.1); color: #00d4ff;">
                        </div>
                    </div>

                    <div
                        style="margin-top: 15px; padding: 12px; background: linear-gradient(135deg, rgba(124,58,237,0.15), rgba(0,212,255,0.15)); border-radius: 8px; border: 1px solid rgba(124,58,237,0.3);">
                        <div
                            style="display: flex; justify-content: space-between; align-items: center; margin-bottom: 8px;">
                            <span style="font-size: 0.85rem; color: #7c3aed; font-weight: 600;">üî≤ Tie Beam Size
                                (Auto-Calculated)</span>
                            <label
                                style="font-size: 0.7rem; color: #8b949e; display: flex; align-items: center; gap: 5px;">
                                <input type="checkbox" id="tieBeamOverride" onchange="toggleTieBeamOverride()"
                                    style="width: 14px; height: 14px;">
                                Override
                            </label>
                        </div>
                        <div style="display: flex; gap: 10px; align-items: center;">
                            <div style="flex: 1;">
                                <label style="font-size: 0.7rem; color: #8b949e;">Width (mm)</label>
                                <input type="number" id="tieBeamWidth" value="200" step="50" min="200" max="400"
                                    readonly style="background: rgba(0,0,0,0.3); color: #00d4ff; font-weight: bold;">
                            </div>
                            <span style="color: #7c3aed; font-size: 1.2rem;">√ó</span>
                            <div style="flex: 1;">
                                <label style="font-size: 0.7rem; color: #8b949e;">Depth (mm)</label>
                                <input type="number" id="tieBeamDepth" value="400" step="50" min="300" max="800"
                                    readonly style="background: rgba(0,0,0,0.3); color: #00d4ff; font-weight: bold;">
                            </div>
                        </div>
                        <div style="margin-top: 8px; font-size: 0.65rem; color: #8b949e; text-align: center;">
                            üìê Kira Formula: Depth = Span/10, Width = 0.4√óDepth
                        </div>
                    </div>
                </div>
            </div>
            <div class="param-group">
                <h3>üèóÔ∏è Structure Type</h3>
                <div class="param-item" style="grid-column: span 2;">
                    <label>Occupancy</label>
                    <select id="occupancy" onchange="applyOccupancy()">
                        <option value="residential">Residential (LL=2.0)</option>
                        <option value="office">Office (LL=2.4)</option>
                        <option value="commercial">Commercial (LL=4.8)</option>
                        <option value="parking">Parking (LL=2.4)</option>
                        <option value="storage">Storage (LL=6.0)</option>
                    </select>
                </div>
            </div>
        </div>

        <!-- Center - Canvas -->
        <div class="canvas-area">
            <div class="canvas-toolbar">
                <button class="tool-btn active" id="selectTool">üñ±Ô∏è Select</button>
                <button class="tool-btn" id="panTool" onclick="togglePanMode()">‚úã Pan</button>
                <button class="tool-btn" id="measureTool">üìè Measure</button>
                <button class="tool-btn" onclick="zoomIn()">üîç+</button>
                <button class="tool-btn" onclick="zoomOut()">üîç-</button>
                <button class="tool-btn" onclick="fitView()">‚ä° Fit</button>
                <button class="tool-btn" onclick="toggleLabels()">üè∑Ô∏è Labels</button>
                <button class="tool-btn" onclick="toggleAreas()">üìê Areas</button>
                <button class="tool-btn" onclick="toggleBeams()">üî≤ Beams</button>
                <button class="tool-btn" onclick="resetColumns()" style="color: #ff6b6b;">‚Ü©Ô∏è Reset</button>
                <button class="tool-btn" onclick="recalculate()"
                    style="background: linear-gradient(135deg, #00d4ff, #7c3aed);">üîÑ Refresh</button>
            </div>

            <!-- Floor Tabs -->
            <div id="floorTabs"
                style="display: flex; gap: 5px; padding: 8px 10px; background: rgba(0,0,0,0.3); border-bottom: 1px solid rgba(255,255,255,0.1);">
                <!-- Floor tabs will be generated dynamically -->
            </div>

            <div class="canvas-wrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
            <div class="canvas-info">
                <span id="mousePos">X: 0.00m, Y: 0.00m</span>
                <span id="scaleInfo">Scale: 1:100</span>
                <span id="totalDimensions">Total: 0m √ó 0m</span>
            </div>
        </div>

        <!-- Right Panel - Results -->
        <div class="panel">
            <div class="panel-header">Analysis Results</div>

            <div class="summary-cards">
                <div class="summary-card">
                    <div class="label">Total Area</div>
                    <div class="value" id="totalArea">0</div>
                    <div class="unit">m¬≤</div>
                </div>
                <div class="summary-card">
                    <div class="label">Columns</div>
                    <div class="value" id="numColumns">0</div>
                    <div class="unit">pcs</div>
                </div>
                <div class="summary-card full-width">
                    <div class="label">Total Load per Floor</div>
                    <div class="value" id="floorLoad">0</div>
                    <div class="unit">kN</div>
                </div>
                <div class="summary-card">
                    <div class="label">Max Column Load</div>
                    <div class="value" id="maxLoad">0</div>
                    <div class="unit">kN</div>
                </div>
                <div class="summary-card">
                    <div class="label">Min Column Load</div>
                    <div class="value" id="minLoad">0</div>
                    <div class="unit">kN</div>
                </div>
            </div>

            <div class="panel-header" style="margin-top: 16px;">Column Tributary Data</div>
            <div style="max-height: 250px; overflow-y: auto;">
                <table class="column-table">
                    <thead>
                        <tr>
                            <th>ID</th>
                            <th>Grid</th>
                            <th>Trib m¬≤</th>
                            <th>kN/floor</th>
                            <th>Total kN</th>
                        </tr>
                    </thead>
                    <tbody id="columnTableBody">
                    </tbody>
                </table>
            </div>

            <!-- Foundation Summary Section -->
            <div class="panel-header"
                style="margin-top: 16px; background: linear-gradient(135deg, #7c3aed, #00d4ff); color: white; padding: 8px; border-radius: 6px;">
                üèóÔ∏è Foundation Design Summary
            </div>

            <div class="param-group" style="margin-top: 10px;">
                <label>Soil Bearing Capacity (kPa)</label>
                <input type="number" id="soilCapacity" value="75" step="5" onchange="updateFoundationTable()">
            </div>

            <div style="max-height: 200px; overflow-y: auto; margin-top: 10px;">
                <table class="column-table" id="foundationTable">
                    <thead>
                        <tr style="background: linear-gradient(135deg, #7c3aed, #00d4ff);">
                            <th>Column</th>
                            <th>Reaction (kN)</th>
                            <th>Footing Size</th>
                            <th>Type</th>
                        </tr>
                    </thead>
                    <tbody id="foundationTableBody">
                    </tbody>
                </table>
            </div>

            <div class="summary-grid" style="margin-top: 10px;">
                <div class="summary-card"
                    style="background: linear-gradient(135deg, rgba(124,58,237,0.2), rgba(0,212,255,0.2)); border: 1px solid #7c3aed;">
                    <div class="label">Total Foundation Load</div>
                    <div class="value" id="totalFoundationLoad" style="color: #7c3aed;">0</div>
                    <div class="unit">kN</div>
                </div>
                <div class="summary-card"
                    style="background: linear-gradient(135deg, rgba(124,58,237,0.2), rgba(0,212,255,0.2)); border: 1px solid #7c3aed;">
                    <div class="label">Footings Required</div>
                    <div class="value" id="footingsCount" style="color: #7c3aed;">0</div>
                    <div class="unit">pcs</div>
                </div>
            </div>

            <button class="export-btn" onclick="exportCSV()">üìä Export to Excel</button>
            <button class="export-btn" onclick="exportFoundationCSV()"
                style="background: linear-gradient(135deg, #7c3aed, #00d4ff);">üèóÔ∏è Export Foundation Schedule</button>
        </div>
    </div>

    <div class="tooltip" id="tooltip"></div>

    <script>
        // State
        let state = {
            xSpans: [4, 4],      // Spans between gridlines
            ySpans: [3, 2.75, 2.25],
            columns: [],
            beams: [],           // Beams between columns
            disabledColumns: new Set(), // Track disabled column IDs for current floor
            disabledColumnsPerFloor: {}, // Per-floor disabled columns: { 0: Set(), 1: Set(), ... }
            currentFloor: 0,     // 0 = Ground Floor, 1 = 2nd Floor, etc.
            showLabels: true,
            showAreas: true,
            showBeams: true,     // Toggle beam display
            scale: 50,
            offsetX: 50,
            offsetY: 50,
            hoveredColumn: null,
            hoveredBeam: null,
            editMode: 'select' // 'select' or 'toggle'
        };

        let canvas, ctx;

        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');

            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('wheel', handleWheel);
            canvas.addEventListener('click', handleCanvasClick);

            // Pan event listeners
            canvas.addEventListener('mousedown', handlePanStart);
            canvas.addEventListener('mousemove', handlePanMove);
            canvas.addEventListener('mouseup', handlePanEnd);
            canvas.addEventListener('mouseleave', handlePanEnd);

            // Load saved disabled columns BEFORE loadPreset
            loadDisabledColumns();

            loadPreset('medium');
        });

        // ========== DISABLED COLUMNS PERSISTENCE ==========
        function saveDisabledColumns() {
            // Save current floor's state first
            state.disabledColumnsPerFloor[state.currentFloor] = new Set(state.disabledColumns);

            // Convert Sets to arrays for JSON storage
            const data = {};
            for (let floor in state.disabledColumnsPerFloor) {
                data[floor] = Array.from(state.disabledColumnsPerFloor[floor] || []);
            }
            localStorage.setItem('tributaryProDisabledColumns', JSON.stringify(data));
            console.log('[Tributary Pro] Saved disabled columns:', data);
        }

        function loadDisabledColumns() {
            const saved = localStorage.getItem('tributaryProDisabledColumns');
            if (!saved) return;

            try {
                const data = JSON.parse(saved);
                // Restore each floor's disabled columns as Sets
                for (let floor in data) {
                    state.disabledColumnsPerFloor[floor] = new Set(data[floor]);
                }
                // Restore current floor's disabled columns
                if (state.disabledColumnsPerFloor[state.currentFloor]) {
                    state.disabledColumns = new Set(state.disabledColumnsPerFloor[state.currentFloor]);
                }
                console.log('[Tributary Pro] Loaded disabled columns:', data);
            } catch (e) {
                console.error('[Tributary Pro] Error loading disabled columns:', e);
            }
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            draw();
        }

        // Floor Tab Management
        function generateFloorTabs() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const container = document.getElementById('floorTabs');

            // Initialize per-floor disabled columns if not exists
            for (let i = 0; i <= storeys; i++) {
                if (!state.disabledColumnsPerFloor[i]) {
                    state.disabledColumnsPerFloor[i] = new Set();
                }
            }

            // Generate tabs
            const floorNames = ['GF', '2F', '3F', '4F', '5F', '6F', '7F', '8F', '9F', '10F', 'RF'];
            let html = '';

            for (let i = 0; i <= storeys; i++) {
                const isActive = i === state.currentFloor;
                const label = i === storeys ? 'Roof' : floorNames[i];
                const disabledCount = state.disabledColumnsPerFloor[i] ? state.disabledColumnsPerFloor[i].size : 0;

                html += `<button onclick="switchFloor(${i})" 
                            style="padding: 6px 12px; 
                                   border: none; 
                                   border-radius: 4px; 
                                   cursor: pointer;
                                   font-size: 0.75rem;
                                   font-weight: ${isActive ? 'bold' : 'normal'};
                                   background: ${isActive ? 'linear-gradient(135deg, #00d4ff, #7c3aed)' : 'rgba(255,255,255,0.1)'};
                                   color: ${isActive ? '#fff' : '#aaa'};">
                            ${label} ${disabledCount > 0 ? '(' + disabledCount + ' off)' : ''}
                        </button>`;
            }

            container.innerHTML = html;
        }

        function switchFloor(floorIndex) {
            // Save current floor's disabled columns
            state.disabledColumnsPerFloor[state.currentFloor] = new Set(state.disabledColumns);

            // Switch to new floor
            state.currentFloor = floorIndex;

            // Load new floor's disabled columns
            state.disabledColumns = state.disabledColumnsPerFloor[floorIndex]
                ? new Set(state.disabledColumnsPerFloor[floorIndex])
                : new Set();

            // Persist to localStorage
            saveDisabledColumns();

            // Update UI
            generateFloorTabs();
            recalculate();
        }

        // Add/Remove floors with buttons
        function addFloor() {
            let storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            storeys = Math.min(storeys + 1, 20); // Max 20 floors
            document.getElementById('numStoreys').value = storeys;
            updateFloorCount();
            recalculate();
        }

        function removeFloor() {
            let storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            storeys = Math.max(storeys - 1, 1); // Min 1 floor
            document.getElementById('numStoreys').value = storeys;

            // If current floor is higher than new max, switch to roof
            if (state.currentFloor > storeys) {
                state.currentFloor = storeys;
            }

            updateFloorCount();
            recalculate();
        }

        function updateFloorCount() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const floorHeight = parseFloat(document.getElementById('floorHeight').value) || 3;
            const totalHeight = (storeys + 1) * floorHeight; // +1 for ground floor
            document.getElementById('floorCount').textContent = `${storeys + 1} (${totalHeight.toFixed(1)}m)`;
        }

        // ========== ELEVATED GF & TIE BEAM CALCULATOR ==========
        // "Kira Formula" - Permanent default by Kira üíú

        function toggleElevatedGF() {
            const isEnabled = document.getElementById('elevatedGF').checked;
            const controls = document.getElementById('tieBeamControls');
            controls.style.display = isEnabled ? 'block' : 'none';

            if (isEnabled) {
                updateTieBeams();
            }

            // Trigger recalculation to include tie beams in sync
            recalculate();
        }

        function toggleTieBeamOverride() {
            const isOverride = document.getElementById('tieBeamOverride').checked;
            const widthInput = document.getElementById('tieBeamWidth');
            const depthInput = document.getElementById('tieBeamDepth');

            if (isOverride) {
                widthInput.removeAttribute('readonly');
                depthInput.removeAttribute('readonly');
                widthInput.style.background = 'rgba(124,58,237,0.2)';
                depthInput.style.background = 'rgba(124,58,237,0.2)';
            } else {
                widthInput.setAttribute('readonly', true);
                depthInput.setAttribute('readonly', true);
                widthInput.style.background = 'rgba(0,0,0,0.3)';
                depthInput.style.background = 'rgba(0,0,0,0.3)';
                updateTieBeams(); // Recalculate auto values
            }
        }

        function updateTieBeams() {
            // Find maximum span (tie beams span between adjacent columns)
            const maxXSpan = Math.max(...state.xSpans);
            const maxYSpan = Math.max(...state.ySpans);
            const maxSpan = Math.max(maxXSpan, maxYSpan);

            // Update max span display
            document.getElementById('maxTieBeamSpan').value = maxSpan.toFixed(2);

            // Only auto-calculate if not in override mode
            if (!document.getElementById('tieBeamOverride').checked) {
                const size = calculateTieBeamSize(maxSpan);
                document.getElementById('tieBeamWidth').value = size.width;
                document.getElementById('tieBeamDepth').value = size.depth;
            }
        }

        // üìê KIRA FORMULA - Tie Beam Size Calculator
        // Depth = Span / 10, Width = 0.4 √ó Depth
        // Minimums: 200mm width, 300mm depth
        // Maximums: 400mm width, 800mm depth
        function calculateTieBeamSize(spanM) {
            // Depth = Span / 10 (rounded to 50mm)
            let depth = Math.ceil((spanM * 1000) / 10 / 50) * 50;
            depth = Math.max(300, Math.min(depth, 800)); // Min 300, Max 800

            // Width = 0.4 √ó Depth (rounded to 50mm, min 200mm)
            let width = Math.round(depth * 0.4 / 50) * 50;
            width = Math.max(200, Math.min(width, 400)); // Min 200, Max 400

            return { width, depth };
        }

        // Get current tie beam data for export/sync
        function getTieBeamData() {
            if (!document.getElementById('elevatedGF').checked) {
                return null;
            }

            return {
                enabled: true,
                foundationHeight: parseFloat(document.getElementById('foundationHeight').value) || 1.5,
                width: parseInt(document.getElementById('tieBeamWidth').value) || 200,
                depth: parseInt(document.getElementById('tieBeamDepth').value) || 400,
                maxSpan: parseFloat(document.getElementById('maxTieBeamSpan').value) || 4.0
            };
        }

        // Span Management
        function renderSpans() {
            // X Spans
            const xContainer = document.getElementById('xSpans');
            xContainer.innerHTML = state.xSpans.map((span, i) => `
                <div class="span-item">
                    <span class="span-label">S${i + 1}</span>
                    <input type="range" class="span-slider" min="1" max="12" step="0.25" 
                           value="${span}" onchange="updateSpan('x', ${i}, this.value)">
                    <input type="number" class="span-value" value="${span}" step="0.25"
                           onchange="updateSpan('x', ${i}, this.value)">
                    <button class="span-delete" onclick="removeSpan('x', ${i})">√ó</button>
                </div>
            `).join('');

            // Y Spans
            const yContainer = document.getElementById('ySpans');
            yContainer.innerHTML = state.ySpans.map((span, i) => `
                <div class="span-item">
                    <span class="span-label">S${i + 1}</span>
                    <input type="range" class="span-slider" min="1" max="12" step="0.25" 
                           value="${span}" onchange="updateSpan('y', ${i}, this.value)">
                    <input type="number" class="span-value" value="${span}" step="0.25"
                           onchange="updateSpan('y', ${i}, this.value)">
                    <button class="span-delete" onclick="removeSpan('y', ${i})">√ó</button>
                </div>
            `).join('');
        }

        function addSpan(axis) {
            if (axis === 'x') {
                state.xSpans.push(4);
            } else {
                state.ySpans.push(3);
            }
            renderSpans();
            recalculate();
        }

        function removeSpan(axis, index) {
            if (axis === 'x' && state.xSpans.length > 1) {
                state.xSpans.splice(index, 1);
            } else if (axis === 'y' && state.ySpans.length > 1) {
                state.ySpans.splice(index, 1);
            }
            renderSpans();
            recalculate();
        }

        function updateSpan(axis, index, value) {
            const val = parseFloat(value) || 1;
            if (axis === 'x') {
                state.xSpans[index] = val;
            } else {
                state.ySpans[index] = val;
            }
            renderSpans();
            recalculate();
        }

        // Presets
        function loadPreset(type) {
            switch (type) {
                case 'small':
                    state.xSpans = [4, 4];
                    state.ySpans = [3, 3];
                    break;
                case 'medium':
                    state.xSpans = [4, 4, 4];
                    state.ySpans = [3, 3, 3];
                    break;
                case 'apartment':
                    state.xSpans = [5, 4, 5];
                    state.ySpans = [3, 4, 3];
                    break;
                case 'custom':
                    // Keep current
                    break;
            }
            renderSpans();
            recalculate();
            generateFloorTabs();
        }

        function applyOccupancy() {
            const occ = document.getElementById('occupancy').value;
            const loads = {
                'residential': 2.0,
                'office': 2.4,
                'commercial': 4.8,
                'parking': 2.4,
                'storage': 6.0
            };
            document.getElementById('liveLoad').value = loads[occ];
            recalculate();
        }

        // Core Calculations
        function recalculate() {
            // Generate grid lines from spans
            let xLines = [0];
            for (let span of state.xSpans) {
                xLines.push(xLines[xLines.length - 1] + span);
            }

            let yLines = [0];
            for (let span of state.ySpans) {
                yLines.push(yLines[yLines.length - 1] + span);
            }

            // Generate columns
            state.columns = [];
            let colId = 1;
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';  // Skip I and O per engineering standard

            for (let yi = 0; yi < yLines.length; yi++) {
                for (let xi = 0; xi < xLines.length; xi++) {
                    const x = xLines[xi];
                    const y = yLines[yi];
                    const id = `${letters[xi]}${yi + 1}`;

                    // Check if column is disabled
                    const enabled = !state.disabledColumns.has(id);

                    // Calculate tributary area (basic - will be recalculated for irregular)
                    let left = xi > 0 ? state.xSpans[xi - 1] / 2 : 0;
                    let right = xi < state.xSpans.length ? state.xSpans[xi] / 2 : 0;
                    let top = yi > 0 ? state.ySpans[yi - 1] / 2 : 0;
                    let bottom = yi < state.ySpans.length ? state.ySpans[yi] / 2 : 0;

                    const tribArea = enabled ? (left + right) * (top + bottom) : 0;

                    state.columns.push({
                        id,
                        x, y,
                        xi, yi,
                        tribLeft: left,
                        tribRight: right,
                        tribTop: top,
                        tribBottom: bottom,
                        tribArea,
                        enabled
                    });
                }
            }

            // Redistribute tributary areas for disabled columns
            redistributeTributaryAreas();

            // Calculate loads
            const DL = parseFloat(document.getElementById('deadLoad').value) || 5;
            const LL = parseFloat(document.getElementById('liveLoad').value) || 2;
            const slab = parseFloat(document.getElementById('slabThick').value) || 150;
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;

            const slabWeight = (slab / 1000) * 24;
            const factoredLoad = 1.2 * (DL + slabWeight) + 1.6 * LL;

            let totalArea = 0;
            let floorLoad = 0;
            let maxLoad = 0;
            let minLoad = Infinity;

            for (let col of state.columns) {
                if (!col.enabled) {
                    col.loadPerFloor = 0;
                    col.totalLoad = 0;
                    continue;
                }
                col.loadPerFloor = col.tribArea * factoredLoad;
                col.totalLoad = col.loadPerFloor * (storeys + 1);

                totalArea += col.tribArea;
                floorLoad += col.loadPerFloor;
                maxLoad = Math.max(maxLoad, col.totalLoad);
                if (col.tribArea > 0) minLoad = Math.min(minLoad, col.totalLoad);
            }

            // Update UI
            document.getElementById('totalArea').textContent = totalArea.toFixed(1);
            const enabledColumns = state.columns.filter(c => c.enabled).length;
            document.getElementById('numColumns').textContent = enabledColumns;
            document.getElementById('floorLoad').textContent = floorLoad.toFixed(0);
            document.getElementById('maxLoad').textContent = maxLoad.toFixed(0);
            document.getElementById('minLoad').textContent = minLoad === Infinity ? 0 : minLoad.toFixed(0);

            // Update dimensions info
            const totalX = state.xSpans.reduce((a, b) => a + b, 0);
            const totalY = state.ySpans.reduce((a, b) => a + b, 0);
            document.getElementById('totalDimensions').textContent = `Total: ${totalX.toFixed(1)}m √ó ${totalY.toFixed(1)}m`;

            // Generate beams
            generateBeams(factoredLoad, storeys);

            // Update table
            updateTable(storeys);

            // Update floor tabs
            generateFloorTabs();

            // Sync to 3D viewer if open
            syncTo3D();

            // Fit and draw
            fitView();
        }

        // Generate beams between columns
        function generateBeams(factoredLoad, storeys) {
            state.beams = [];

            // Get grid lines
            let xLines = [0];
            for (let span of state.xSpans) xLines.push(xLines[xLines.length - 1] + span);
            let yLines = [0];
            for (let span of state.ySpans) yLines.push(yLines[yLines.length - 1] + span);

            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';

            // X-direction beams (horizontal, along X axis at each Y level)
            for (let yi = 0; yi < yLines.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    const x1 = xLines[xi];
                    const x2 = xLines[xi + 1];
                    const y = yLines[yi];
                    const span = state.xSpans[xi];

                    // Check if both end columns are enabled
                    const startColId = `${letters[xi]}${yi + 1}`;
                    const endColId = `${letters[xi + 1]}${yi + 1}`;
                    const startEnabled = !state.disabledColumns.has(startColId);
                    const endEnabled = !state.disabledColumns.has(endColId);

                    // Tributary width: half of spans above and below
                    let tribWidthTop = yi > 0 ? state.ySpans[yi - 1] / 2 : 0;
                    let tribWidthBottom = yi < state.ySpans.length ? state.ySpans[yi] / 2 : 0;
                    const tribWidth = tribWidthTop + tribWidthBottom;

                    // Line load (kN/m) = area load (kPa) √ó tributary width (m)
                    const lineLoad = factoredLoad * tribWidth;

                    state.beams.push({
                        id: `BX-${letters[xi]}${yi + 1}`,
                        direction: 'X',
                        x1, y1: y, x2, y2: y,
                        span,
                        tribWidth,
                        lineLoad,
                        totalLoad: lineLoad * span * (storeys + 1),
                        enabled: startEnabled && endEnabled
                    });
                }
            }

            // Y-direction beams (vertical, along Y axis at each X level)
            for (let xi = 0; xi < xLines.length; xi++) {
                for (let yi = 0; yi < state.ySpans.length; yi++) {
                    const x = xLines[xi];
                    const y1 = yLines[yi];
                    const y2 = yLines[yi + 1];
                    const span = state.ySpans[yi];

                    // Check if both end columns are enabled
                    const startColId = `${letters[xi]}${yi + 1}`;
                    const endColId = `${letters[xi]}${yi + 2}`;
                    const startEnabled = !state.disabledColumns.has(startColId);
                    const endEnabled = !state.disabledColumns.has(endColId);

                    // Tributary width: half of spans left and right
                    let tribWidthLeft = xi > 0 ? state.xSpans[xi - 1] / 2 : 0;
                    let tribWidthRight = xi < state.xSpans.length ? state.xSpans[xi] / 2 : 0;
                    const tribWidth = tribWidthLeft + tribWidthRight;

                    // Line load (kN/m) = area load (kPa) √ó tributary width (m)
                    const lineLoad = factoredLoad * tribWidth;

                    state.beams.push({
                        id: `BY-${letters[xi]}${yi + 1}`,
                        direction: 'Y',
                        x1: x, y1, x2: x, y2,
                        span,
                        tribWidth,
                        lineLoad,
                        totalLoad: lineLoad * span * (storeys + 1),
                        enabled: startEnabled && endEnabled
                    });
                }
            }
        }

        // Redistribute tributary areas when columns are disabled
        function redistributeTributaryAreas() {
            // For each disabled column, redistribute its area to enabled neighbors
            for (let col of state.columns) {
                if (col.enabled) continue;

                // Find adjacent enabled columns
                const neighbors = state.columns.filter(c => {
                    if (!c.enabled) return false;
                    const dx = Math.abs(c.xi - col.xi);
                    const dy = Math.abs(c.yi - col.yi);
                    // Direct neighbors (not diagonal)
                    return (dx === 1 && dy === 0) || (dx === 0 && dy === 1);
                });

                if (neighbors.length === 0) continue;

                // Calculate the disabled column's theoretical area
                let disabledLeft = col.xi > 0 ? state.xSpans[col.xi - 1] / 2 : 0;
                let disabledRight = col.xi < state.xSpans.length ? state.xSpans[col.xi] / 2 : 0;
                let disabledTop = col.yi > 0 ? state.ySpans[col.yi - 1] / 2 : 0;
                let disabledBottom = col.yi < state.ySpans.length ? state.ySpans[col.yi] / 2 : 0;
                const disabledArea = (disabledLeft + disabledRight) * (disabledTop + disabledBottom);

                // Distribute to neighbors based on direction
                for (let neighbor of neighbors) {
                    // Calculate shared dimension
                    if (neighbor.xi === col.xi) {
                        // Same X, different Y - share top/bottom
                        const sharedWidth = disabledLeft + disabledRight;
                        if (neighbor.yi < col.yi) {
                            // Neighbor is above, gets bottom portion
                            neighbor.tribArea += sharedWidth * disabledBottom;
                        } else {
                            // Neighbor is below, gets top portion
                            neighbor.tribArea += sharedWidth * disabledTop;
                        }
                    } else if (neighbor.yi === col.yi) {
                        // Same Y, different X - share left/right
                        const sharedHeight = disabledTop + disabledBottom;
                        if (neighbor.xi < col.xi) {
                            // Neighbor is left, gets right portion
                            neighbor.tribArea += disabledRight * sharedHeight;
                        } else {
                            // Neighbor is right, gets left portion
                            neighbor.tribArea += disabledLeft * sharedHeight;
                        }
                    }
                }
            }
        }

        // Handle canvas click for toggling columns
        function handleCanvasClick(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Find clicked column
            for (let col of state.columns) {
                const x = state.offsetX + col.x * state.scale;
                const y = state.offsetY + col.y * state.scale;
                const dist = Math.sqrt((mx - x) ** 2 + (my - y) ** 2);

                if (dist < 15) {
                    // Toggle column
                    if (state.disabledColumns.has(col.id)) {
                        state.disabledColumns.delete(col.id);
                    } else {
                        state.disabledColumns.add(col.id);
                    }
                    recalculate();
                    saveDisabledColumns();  // Persist to localStorage
                    return;
                }
            }
        }

        function updateTable(storeys) {
            const tbody = document.getElementById('columnTableBody');
            tbody.innerHTML = state.columns.map(col => `
                <tr data-col="${col.id}" style="${!col.enabled ? 'opacity: 0.4; text-decoration: line-through;' : ''}">
                    <td class="col-id">${col.id} ${!col.enabled ? '‚ùå' : ''}</td>
                    <td>${col.xi + 1}-${col.yi + 1}</td>
                    <td class="col-area">${col.tribArea.toFixed(2)}</td>
                    <td class="col-load">${col.loadPerFloor.toFixed(0)}</td>
                    <td>${col.totalLoad.toFixed(0)}</td>
                </tr>
            `).join('');

            // Update foundation table
            updateFoundationTable();
        }

        // Foundation sizing based on soil bearing capacity
        function updateFoundationTable() {
            const tbody = document.getElementById('foundationTableBody');
            const soilCapacity = parseFloat(document.getElementById('soilCapacity').value) || 75;

            let totalLoad = 0;
            let footingCount = 0;

            // Standard footing sizes (width x length in m)
            const footingSizes = [
                { size: '0.6√ó0.6', area: 0.36, label: 'F1' },
                { size: '0.8√ó0.8', area: 0.64, label: 'F2' },
                { size: '1.0√ó1.0', area: 1.00, label: 'F3' },
                { size: '1.2√ó1.2', area: 1.44, label: 'F4' },
                { size: '1.5√ó1.5', area: 2.25, label: 'F5' },
                { size: '1.8√ó1.8', area: 3.24, label: 'F6' },
                { size: '2.0√ó2.0', area: 4.00, label: 'F7' },
                { size: '2.5√ó2.5', area: 6.25, label: 'F8' }
            ];

            const enabledColumns = state.columns.filter(c => c.enabled);

            tbody.innerHTML = enabledColumns.map(col => {
                const reaction = col.totalLoad;
                totalLoad += reaction;

                // Required footing area = Reaction / Soil Capacity (with 1.5 safety factor)
                const requiredArea = (reaction / soilCapacity) * 1.5;

                // Find suitable footing
                let selectedFooting = footingSizes[footingSizes.length - 1]; // Default to largest
                for (let ftg of footingSizes) {
                    if (ftg.area >= requiredArea) {
                        selectedFooting = ftg;
                        break;
                    }
                }

                // Determine type based on position
                let type = 'Interior';
                const isCorner = (col.xi === 0 || col.xi === state.xSpans.length) &&
                    (col.yi === 0 || col.yi === state.ySpans.length);
                const isEdge = (col.xi === 0 || col.xi === state.xSpans.length) ||
                    (col.yi === 0 || col.yi === state.ySpans.length);

                if (isCorner) type = 'Corner';
                else if (isEdge) type = 'Edge';

                footingCount++;

                return `
                    <tr>
                        <td style="font-weight: bold;">${col.id}</td>
                        <td>${reaction.toFixed(0)}</td>
                        <td style="color: #00d4ff; font-weight: bold;">${selectedFooting.size}m (${selectedFooting.label})</td>
                        <td style="font-size: 0.75rem; color: ${type === 'Corner' ? '#ff9500' : type === 'Edge' ? '#00c853' : '#8b949e'};">${type}</td>
                    </tr>
                `;
            }).join('');

            // Update summary
            document.getElementById('totalFoundationLoad').textContent = totalLoad.toFixed(0);
            document.getElementById('footingsCount').textContent = footingCount;
        }

        // Export foundation schedule
        function exportFoundationCSV() {
            const soilCapacity = parseFloat(document.getElementById('soilCapacity').value) || 75;
            let csv = 'Column,Reaction (kN),Required Area (m¬≤),Footing Size,Type\\n';

            const footingSizes = [
                { size: '0.6√ó0.6', area: 0.36, label: 'F1' },
                { size: '0.8√ó0.8', area: 0.64, label: 'F2' },
                { size: '1.0√ó1.0', area: 1.00, label: 'F3' },
                { size: '1.2√ó1.2', area: 1.44, label: 'F4' },
                { size: '1.5√ó1.5', area: 2.25, label: 'F5' },
                { size: '1.8√ó1.8', area: 3.24, label: 'F6' },
                { size: '2.0√ó2.0', area: 4.00, label: 'F7' },
                { size: '2.5√ó2.5', area: 6.25, label: 'F8' }
            ];

            for (let col of state.columns.filter(c => c.enabled)) {
                const reaction = col.totalLoad;
                const requiredArea = (reaction / soilCapacity) * 1.5;

                let selectedFooting = footingSizes[footingSizes.length - 1];
                for (let ftg of footingSizes) {
                    if (ftg.area >= requiredArea) {
                        selectedFooting = ftg;
                        break;
                    }
                }

                let type = 'Interior';
                const isCorner = (col.xi === 0 || col.xi === state.xSpans.length) &&
                    (col.yi === 0 || col.yi === state.ySpans.length);
                const isEdge = (col.xi === 0 || col.xi === state.xSpans.length) ||
                    (col.yi === 0 || col.yi === state.ySpans.length);
                if (isCorner) type = 'Corner';
                else if (isEdge) type = 'Edge';

                csv += `${col.id},${reaction.toFixed(0)},${requiredArea.toFixed(2)},${selectedFooting.size}m (${selectedFooting.label}),${type}\\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'foundation_schedule.csv';
            a.click();
        }

        // Drawing
        function fitView() {
            if (!canvas || state.columns.length === 0) return;

            const maxX = Math.max(...state.columns.map(c => c.x));
            const maxY = Math.max(...state.columns.map(c => c.y));

            // Increased margin from 100 to 150 to show bubble markers and dimensions
            const margin = 150;
            const scaleX = (canvas.width - margin) / Math.max(maxX, 1);
            const scaleY = (canvas.height - margin) / Math.max(maxY, 1);
            state.scale = Math.min(scaleX, scaleY, 80);

            // Offset to center with extra space for bubbles at top and left
            state.offsetX = 100 + (canvas.width - margin - maxX * state.scale) / 2;
            state.offsetY = 100 + (canvas.height - margin - maxY * state.scale) / 2;

            draw();
        }

        // Pan mode toggle
        let panMode = false;
        let isPanning = false;
        let panStartX = 0;
        let panStartY = 0;

        function togglePanMode() {
            panMode = !panMode;
            const panBtn = document.getElementById('panTool');
            const selectBtn = document.getElementById('selectTool');
            if (panMode) {
                panBtn.classList.add('active');
                selectBtn.classList.remove('active');
                canvas.style.cursor = 'grab';
            } else {
                panBtn.classList.remove('active');
                selectBtn.classList.add('active');
                canvas.style.cursor = 'default';
            }
        }

        function handlePanStart(e) {
            if (!panMode) return;
            isPanning = true;
            panStartX = e.clientX;
            panStartY = e.clientY;
            canvas.style.cursor = 'grabbing';
        }

        function handlePanMove(e) {
            if (!isPanning) return;
            const dx = e.clientX - panStartX;
            const dy = e.clientY - panStartY;
            state.offsetX += dx;
            state.offsetY += dy;
            panStartX = e.clientX;
            panStartY = e.clientY;
            draw();
        }

        function handlePanEnd() {
            isPanning = false;
            if (panMode) {
                canvas.style.cursor = 'grab';
            }
        }

        function draw() {
            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw tributary areas
            if (state.showAreas) {
                const maxArea = Math.max(...state.columns.filter(c => c.enabled).map(c => c.tribArea), 1);

                for (let col of state.columns) {
                    // Skip disabled columns - don't draw their tributary area
                    if (!col.enabled) continue;

                    const x = state.offsetX + col.x * state.scale;
                    const y = state.offsetY + col.y * state.scale;

                    const intensity = col.tribArea / maxArea;

                    // Gradient fill
                    const left = x - col.tribLeft * state.scale;
                    const top = y - col.tribTop * state.scale;
                    const width = (col.tribLeft + col.tribRight) * state.scale;
                    const height = (col.tribTop + col.tribBottom) * state.scale;

                    const grad = ctx.createLinearGradient(left, top, left + width, top + height);
                    grad.addColorStop(0, `rgba(0, 212, 255, ${0.05 + intensity * 0.15})`);
                    grad.addColorStop(1, `rgba(124, 58, 237, ${0.05 + intensity * 0.15})`);

                    ctx.fillStyle = grad;
                    ctx.fillRect(left, top, width, height);

                    ctx.strokeStyle = `rgba(124, 58, 237, ${0.3 + intensity * 0.3})`;
                    ctx.lineWidth = 1;
                    ctx.strokeRect(left, top, width, height);

                    // Area text
                    if (state.showLabels && width > 35 && height > 25) {
                        ctx.fillStyle = 'rgba(255, 255, 255, 0.6)';
                        ctx.font = '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.textBaseline = 'middle';
                        ctx.fillText(`${col.tribArea.toFixed(1)}`, x, y + 20);
                    }
                }
            }

            // Draw grid lines
            const xLines = [0];
            for (let span of state.xSpans) xLines.push(xLines[xLines.length - 1] + span);
            const yLines = [0];
            for (let span of state.ySpans) yLines.push(yLines[yLines.length - 1] + span);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.2)';
            ctx.setLineDash([5, 5]);
            ctx.lineWidth = 1;

            // Vertical
            for (let x of xLines) {
                const px = state.offsetX + x * state.scale;
                ctx.beginPath();
                ctx.moveTo(px, state.offsetY);
                ctx.lineTo(px, state.offsetY + yLines[yLines.length - 1] * state.scale);
                ctx.stroke();
            }

            // Horizontal
            for (let y of yLines) {
                const py = state.offsetY + y * state.scale;
                ctx.beginPath();
                ctx.moveTo(state.offsetX, py);
                ctx.lineTo(state.offsetX + xLines[xLines.length - 1] * state.scale, py);
                ctx.stroke();
            }

            ctx.setLineDash([]);

            // === REVIT-STYLE GRIDLINE LAYOUT ===
            // Order from grid outward: Grid ‚Üí Dimensions ‚Üí Bubbles
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';  // Skip I and O per engineering standard
            const bubbleRadius = 14;
            const dimensionOffset = 25;   // Dimensions close to grid
            const bubbleOffset = 70;      // Bubbles OUTSIDE dimensions

            // X-axis bubble markers (A, B, C...) - at top
            for (let i = 0; i < xLines.length; i++) {
                const px = state.offsetX + xLines[i] * state.scale;
                const py = state.offsetY - bubbleOffset;

                // Bubble circle
                ctx.beginPath();
                ctx.arc(px, py, bubbleRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#1a1f2e';
                ctx.fill();
                ctx.strokeStyle = '#00d4ff';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Letter label
                ctx.fillStyle = '#00d4ff';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(letters[i], px, py);

                // Extension line from bubble to grid
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px, py + bubbleRadius);
                ctx.lineTo(px, state.offsetY);
                ctx.stroke();
            }

            // Y-axis bubble markers (1, 2, 3...) - at left
            for (let i = 0; i < yLines.length; i++) {
                const px = state.offsetX - bubbleOffset;
                const py = state.offsetY + yLines[i] * state.scale;

                // Bubble circle
                ctx.beginPath();
                ctx.arc(px, py, bubbleRadius, 0, Math.PI * 2);
                ctx.fillStyle = '#1a1f2e';
                ctx.fill();
                ctx.strokeStyle = '#7c3aed';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Number label
                ctx.fillStyle = '#7c3aed';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(String(i + 1), px, py);

                // Extension line from bubble to grid
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.3)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(px + bubbleRadius, py);
                ctx.lineTo(state.offsetX, py);
                ctx.stroke();
            }

            // === DIMENSION ANNOTATIONS ===
            ctx.fillStyle = 'rgba(255, 255, 255, 0.7)';
            ctx.font = '10px sans-serif';

            // X-direction dimensions (between grid and bubbles)
            for (let i = 0; i < state.xSpans.length; i++) {
                const x1 = state.offsetX + xLines[i] * state.scale;
                const x2 = state.offsetX + xLines[i + 1] * state.scale;
                const y = state.offsetY - dimensionOffset;  // Close to grid, inside bubbles

                // Dimension line
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x1, y);
                ctx.lineTo(x2, y);
                ctx.stroke();

                // Tick marks
                ctx.beginPath();
                ctx.moveTo(x1, y - 3);
                ctx.lineTo(x1, y + 3);
                ctx.moveTo(x2, y - 3);
                ctx.lineTo(x2, y + 3);
                ctx.stroke();

                // Dimension text
                ctx.fillStyle = '#00d4ff';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`${state.xSpans[i].toFixed(2)}m`, (x1 + x2) / 2, y - 2);
            }

            // Y-direction dimensions (between grid and bubbles)
            for (let i = 0; i < state.ySpans.length; i++) {
                const y1 = state.offsetY + yLines[i] * state.scale;
                const y2 = state.offsetY + yLines[i + 1] * state.scale;
                const x = state.offsetX - dimensionOffset;  // Close to grid, inside bubbles

                // Dimension line
                ctx.strokeStyle = 'rgba(124, 58, 237, 0.5)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x, y1);
                ctx.lineTo(x, y2);
                ctx.stroke();

                // Tick marks
                ctx.beginPath();
                ctx.moveTo(x - 3, y1);
                ctx.lineTo(x + 3, y1);
                ctx.moveTo(x - 3, y2);
                ctx.lineTo(x + 3, y2);
                ctx.stroke();

                // Dimension text (rotated)
                ctx.save();
                ctx.translate(x - 5, (y1 + y2) / 2);
                ctx.rotate(-Math.PI / 2);
                ctx.fillStyle = '#7c3aed';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'bottom';
                ctx.fillText(`${state.ySpans[i].toFixed(2)}m`, 0, 0);
                ctx.restore();
            }

            // Draw beams (if enabled)
            if (state.showBeams) {
                for (let beam of state.beams) {
                    const px1 = state.offsetX + beam.x1 * state.scale;
                    const py1 = state.offsetY + beam.y1 * state.scale;
                    const px2 = state.offsetX + beam.x2 * state.scale;
                    const py2 = state.offsetY + beam.y2 * state.scale;

                    // Beam color based on direction and enabled state
                    if (!beam.enabled) {
                        ctx.strokeStyle = 'rgba(100, 100, 100, 0.3)';
                        ctx.setLineDash([3, 3]);
                    } else if (beam.direction === 'X') {
                        ctx.strokeStyle = '#ff9500'; // Orange for X beams
                        ctx.setLineDash([]);
                    } else {
                        ctx.strokeStyle = '#00c853'; // Green for Y beams
                        ctx.setLineDash([]);
                    }

                    ctx.lineWidth = beam.enabled ? 3 : 1;
                    ctx.beginPath();
                    ctx.moveTo(px1, py1);
                    ctx.lineTo(px2, py2);
                    ctx.stroke();

                    // Draw tributary width indicator (hatched area)
                    if (beam.enabled && beam.tribWidth > 0) {
                        const midX = (px1 + px2) / 2;
                        const midY = (py1 + py2) / 2;

                        if (beam.direction === 'X') {
                            // Horizontal beam - tributary above and below
                            ctx.fillStyle = 'rgba(255, 149, 0, 0.1)';
                            const tribPx = beam.tribWidth * state.scale;
                            ctx.fillRect(px1, midY - tribPx / 2, px2 - px1, tribPx);
                        } else {
                            // Vertical beam - tributary left and right
                            ctx.fillStyle = 'rgba(0, 200, 83, 0.1)';
                            const tribPx = beam.tribWidth * state.scale;
                            ctx.fillRect(midX - tribPx / 2, py1, tribPx, py2 - py1);
                        }

                        // Show line load at beam center
                        if (state.showLabels) {
                            ctx.fillStyle = beam.direction === 'X' ? '#ff9500' : '#00c853';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.textBaseline = 'middle';
                            const loadText = `${beam.lineLoad.toFixed(1)} kN/m`;
                            // Offset text based on direction
                            if (beam.direction === 'X') {
                                ctx.fillText(loadText, midX, midY - 12);
                            } else {
                                ctx.save();
                                ctx.translate(midX - 12, midY);
                                ctx.rotate(-Math.PI / 2);
                                ctx.fillText(loadText, 0, 0);
                                ctx.restore();
                            }
                        }
                    }
                }
                ctx.setLineDash([]);
            }

            // Draw columns
            for (let col of state.columns) {
                const x = state.offsetX + col.x * state.scale;
                const y = state.offsetY + col.y * state.scale;

                const isHovered = state.hoveredColumn === col;
                const size = isHovered ? 10 : 8;

                // Column shape - different colors for enabled/disabled
                if (col.enabled) {
                    ctx.fillStyle = isHovered ? '#00ff88' : '#00d4ff';
                } else {
                    ctx.fillStyle = isHovered ? '#ff6666' : '#666666';
                }
                ctx.beginPath();
                ctx.arc(x, y, size, 0, Math.PI * 2);
                ctx.fill();

                ctx.strokeStyle = col.enabled ? '#fff' : '#888';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Draw X for disabled columns
                if (!col.enabled) {
                    ctx.strokeStyle = '#ff4444';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    ctx.moveTo(x - 5, y - 5);
                    ctx.lineTo(x + 5, y + 5);
                    ctx.moveTo(x + 5, y - 5);
                    ctx.lineTo(x - 5, y + 5);
                    ctx.stroke();
                }

                // ID label
                if (state.showLabels) {
                    ctx.fillStyle = col.enabled ? '#fff' : '#888';
                    ctx.font = 'bold 11px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'bottom';
                    ctx.fillText(col.id, x, y - 12);
                }
            }

            // Draw dimensions
            ctx.fillStyle = 'rgba(255, 255, 255, 0.5)';
            ctx.font = '10px sans-serif';

            // X dimensions at top
            for (let i = 0; i < state.xSpans.length; i++) {
                const x1 = xLines[i];
                const x2 = xLines[i + 1];
                const px = state.offsetX + ((x1 + x2) / 2) * state.scale;
                const py = state.offsetY - 15;
                ctx.textAlign = 'center';
                ctx.fillText(`${state.xSpans[i]}m`, px, py);
            }

            // Y dimensions at left
            for (let i = 0; i < state.ySpans.length; i++) {
                const y1 = yLines[i];
                const y2 = yLines[i + 1];
                const px = state.offsetX - 15;
                const py = state.offsetY + ((y1 + y2) / 2) * state.scale;
                ctx.textAlign = 'right';
                ctx.textBaseline = 'middle';
                ctx.fillText(`${state.ySpans[i]}m`, px, py);
            }
        }

        // Interaction
        function handleMouseMove(e) {
            const rect = canvas.getBoundingClientRect();
            const mx = e.clientX - rect.left;
            const my = e.clientY - rect.top;

            // Update position display
            const worldX = (mx - state.offsetX) / state.scale;
            const worldY = (my - state.offsetY) / state.scale;
            document.getElementById('mousePos').textContent = `X: ${worldX.toFixed(2)}m, Y: ${worldY.toFixed(2)}m`;

            // Check hover
            state.hoveredColumn = null;
            for (let col of state.columns) {
                const x = state.offsetX + col.x * state.scale;
                const y = state.offsetY + col.y * state.scale;
                if (Math.sqrt((mx - x) ** 2 + (my - y) ** 2) < 15) {
                    state.hoveredColumn = col;
                    break;
                }
            }

            // Tooltip
            const tooltip = document.getElementById('tooltip');
            if (state.hoveredColumn) {
                const col = state.hoveredColumn;
                tooltip.style.display = 'block';
                tooltip.style.left = (e.clientX + 15) + 'px';
                tooltip.style.top = (e.clientY + 15) + 'px';
                tooltip.innerHTML = `
                    <div class="tt-title">${col.id}</div>
                    <div class="tt-row"><span class="tt-label">Position:</span><span class="tt-value">(${col.x.toFixed(1)}, ${col.y.toFixed(1)})</span></div>
                    <div class="tt-row"><span class="tt-label">Trib Area:</span><span class="tt-value">${col.tribArea.toFixed(2)} m¬≤</span></div>
                    <div class="tt-row"><span class="tt-label">Load/Floor:</span><span class="tt-value">${col.loadPerFloor.toFixed(0)} kN</span></div>
                    <div class="tt-row"><span class="tt-label">Total Load:</span><span class="tt-value">${col.totalLoad.toFixed(0)} kN</span></div>
                `;
            } else {
                tooltip.style.display = 'none';
            }

            draw();
        }

        function handleWheel(e) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? 0.9 : 1.1;
            state.scale *= delta;
            state.scale = Math.max(10, Math.min(200, state.scale));
            document.getElementById('scaleInfo').textContent = `Scale: 1:${Math.round(1000 / state.scale)}`;
            draw();
        }

        function zoomIn() { state.scale *= 1.2; draw(); }
        function zoomOut() { state.scale /= 1.2; draw(); }
        function toggleLabels() { state.showLabels = !state.showLabels; draw(); }
        function toggleAreas() { state.showAreas = !state.showAreas; draw(); }
        function toggleBeams() { state.showBeams = !state.showBeams; draw(); }

        // Reset all columns to enabled
        function resetColumns() {
            state.disabledColumns.clear();
            saveDisabledColumns();  // Persist reset to localStorage
            recalculate();
        }

        // Export
        function exportCSV() {
            let csv = 'Column,Grid,Position X,Position Y,Tributary Area (m¬≤),Load/Floor (kN),Total Load (kN)\n';
            for (let col of state.columns) {
                csv += `${col.id},${col.xi + 1}-${col.yi + 1},${col.x.toFixed(2)},${col.y.toFixed(2)},${col.tribArea.toFixed(2)},${col.loadPerFloor.toFixed(0)},${col.totalLoad.toFixed(0)}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tributary_analysis.csv';
            a.click();
        }

        function saveProject() {
            const data = {
                xSpans: state.xSpans,
                ySpans: state.ySpans,
                params: {
                    deadLoad: document.getElementById('deadLoad').value,
                    liveLoad: document.getElementById('liveLoad').value,
                    slabThick: document.getElementById('slabThick').value,
                    numStoreys: document.getElementById('numStoreys').value
                }
            };
            localStorage.setItem('tributaryProject', JSON.stringify(data));
            alert('Project saved!');
        }

        function exportPDF() {
            // Canvas to image
            const dataUrl = canvas.toDataURL('image/png');
            const win = window.open('', '_blank');
            win.document.write(`
                <html>
                <head><title>Tributary Analysis Report</title></head>
                <body style="font-family: Arial; padding: 40px;">
                    <h1>Tributary Area Analysis</h1>
                    <p>Generated: ${new Date().toLocaleString()}</p>
                    <img src="${dataUrl}" style="max-width: 100%; border: 1px solid #ccc;">
                    <h2>Summary</h2>
                    <p>Total Area: ${document.getElementById('totalArea').textContent} m¬≤</p>
                    <p>Columns: ${document.getElementById('numColumns').textContent}</p>
                    <p>Floor Load: ${document.getElementById('floorLoad').textContent} kN</p>
                    <p style="margin-top: 30px; color: #888;">Pang-Masa Engineering - Tributary Pro</p>
                </body>
                </html>
            `);
            win.print();
        }

        // Toggle export menu
        function toggleExportMenu() {
            const menu = document.getElementById('exportMenu');
            menu.style.display = menu.style.display === 'none' ? 'block' : 'none';
        }

        // Close menu when clicking outside
        document.addEventListener('click', (e) => {
            const menu = document.getElementById('exportMenu');
            const btn = document.getElementById('exportBtn');
            if (menu && !menu.contains(e.target) && !btn.contains(e.target)) {
                menu.style.display = 'none';
            }
        });

        // Open in 3D Frame Viewer
        function openIn3D() {
            // Save current state to localStorage for 3D viewer
            const model3D = {
                xSpans: state.xSpans,
                ySpans: state.ySpans,
                storeys: parseInt(document.getElementById('numStoreys').value) || 2,
                floorHeight: parseFloat(document.getElementById('floorHeight').value) || 3,
                disabledColumnsPerFloor: {},
                timestamp: Date.now()
            };

            // Convert disabled columns Sets to arrays for JSON
            for (let floor in state.disabledColumnsPerFloor) {
                model3D.disabledColumnsPerFloor[floor] = Array.from(state.disabledColumnsPerFloor[floor] || []);
            }
            // Also save current floor
            model3D.disabledColumnsPerFloor[state.currentFloor] = Array.from(state.disabledColumns);

            // Save to localStorage
            localStorage.setItem('tributaryPro3DModel', JSON.stringify(model3D));

            // Open 3D viewer
            window.open('frame_viewer_3d.html', '_blank');
        }

        // ========== Live Sync to 3D Viewer ==========
        function syncTo3D() {
            // Save current state to localStorage for 3D viewer
            const model3D = {
                xSpans: state.xSpans,
                ySpans: state.ySpans,
                storeys: parseInt(document.getElementById('numStoreys').value) || 2,
                floorHeight: parseFloat(document.getElementById('floorHeight').value) || 3,
                disabledColumnsPerFloor: {},
                timestamp: Date.now(),
                liveSync: true // Flag for live updates
            };

            // Convert disabled columns Sets to arrays for JSON
            for (let floor in state.disabledColumnsPerFloor) {
                model3D.disabledColumnsPerFloor[floor] = Array.from(state.disabledColumnsPerFloor[floor] || []);
            }
            // Also save current floor
            model3D.disabledColumnsPerFloor[state.currentFloor] = Array.from(state.disabledColumns);

            // Save to localStorage (triggers 'storage' event in other tabs)
            localStorage.setItem('tributaryPro3DModel', JSON.stringify(model3D));

            // Also broadcast column data for Footing Design tool
            const columnData = {
                columns: state.columns.map(c => ({
                    id: c.id,
                    x: c.x,
                    y: c.y,
                    xi: c.xi,
                    yi: c.yi,
                    tribArea: c.tribArea,
                    loadPerFloor: c.loadPerFloor,
                    totalLoad: c.totalLoad,
                    enabled: c.enabled
                })),
                soilCapacity: parseFloat(document.getElementById('soilCapacity').value) || 75,
                timestamp: Date.now()
            };
            localStorage.setItem('tributaryProColumns', JSON.stringify(columnData));
        }

        // ========== STAAD.Pro Export ==========
        function exportSTAAD() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const storyHeight = 3.0; // meters

            let std = `STAAD SPACE\n`;
            std += `START JOB INFORMATION\n`;
            std += `ENGINEER DATE ${new Date().toLocaleDateString()}\n`;
            std += `END JOB INFORMATION\n`;
            std += `* Generated by Tributary Pro - Pang-Masa Engineering\n\n`;

            std += `INPUT WIDTH 79\n`;
            std += `UNIT METER KN\n\n`;

            // JOINTS (nodes at each column for each storey)
            std += `JOINT COORDINATES\n`;
            let jointId = 1;
            const jointMap = {}; // Store joint IDs for each column/storey

            for (let col of state.columns) {
                for (let s = 0; s <= storeys; s++) {
                    const z = s * storyHeight;
                    std += `${jointId} ${col.x.toFixed(3)} ${z.toFixed(3)} ${col.y.toFixed(3)}\n`;
                    if (!jointMap[col.id]) jointMap[col.id] = {};
                    jointMap[col.id][s] = jointId;
                    jointId++;
                }
            }
            std += `\n`;

            // MEMBERS (columns)
            std += `MEMBER INCIDENCES\n`;
            let memberId = 1;
            for (let col of state.columns) {
                for (let s = 0; s < storeys; s++) {
                    const start = jointMap[col.id][s];
                    const end = jointMap[col.id][s + 1];
                    std += `${memberId} ${start} ${end}\n`;
                    memberId++;
                }
            }
            std += `\n`;

            // MEMBER PROPERTIES
            std += `MEMBER PROPERTY AMERICAN\n`;
            std += `1 TO ${memberId - 1} PRIS YD 0.4 ZD 0.25\n\n`;

            // CONSTANTS
            std += `CONSTANTS\n`;
            std += `E 25000000 ALL\n`;
            std += `POISSON 0.2 ALL\n`;
            std += `DENSITY 24 ALL\n\n`;

            // SUPPORTS
            std += `SUPPORTS\n`;
            for (let col of state.columns) {
                std += `${jointMap[col.id][0]} FIXED\n`;
            }
            std += `\n`;

            // LOADS
            std += `LOAD 1 LOADTYPE Dead TITLE DEAD LOAD\n`;
            std += `SELFWEIGHT Y -1.0\n`;
            for (let col of state.columns) {
                for (let s = 1; s <= storeys; s++) {
                    const load = col.loadPerFloor || col.tribArea * 13.5;
                    std += `JOINT LOAD\n`;
                    std += `${jointMap[col.id][s]} FY -${load.toFixed(1)}\n`;
                }
            }
            std += `\n`;

            std += `LOAD 2 LOADTYPE Live TITLE LIVE LOAD\n`;
            const LL = parseFloat(document.getElementById('liveLoad').value) || 2.0;
            for (let col of state.columns) {
                for (let s = 1; s <= storeys; s++) {
                    const load = col.tribArea * 1.6 * LL;
                    std += `JOINT LOAD\n`;
                    std += `${jointMap[col.id][s]} FY -${load.toFixed(1)}\n`;
                }
            }
            std += `\n`;

            // LOAD COMBINATIONS
            std += `LOAD COMBINATION 101\n`;
            std += `1 1.2 2 1.6\n\n`;

            std += `PERFORM ANALYSIS\n`;
            std += `FINISH\n`;

            downloadFile(std, 'structure.std', 'text/plain');
        }

        // ========== ETABS Export ==========
        function exportETABS() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const storyHeight = 3000; // mm

            let e2k = `$ ETABS 2K FILE\n`;
            e2k += `$ EXPORTED FROM TRIBUTARY PRO - PANG-MASA ENGINEERING\n`;
            e2k += `$ ${new Date().toLocaleString()}\n\n`;

            e2k += `$ PROGRAM INFORMATION\n`;
            e2k += `PROGRAM "ETABS" VERSION "21.0"\n\n`;

            e2k += `$ UNITS\n`;
            e2k += `UNITS  "KN"  "M"\n\n`;

            // STORY DATA
            e2k += `$ STORY DATA\n`;
            e2k += `STORY "ROOF" HEIGHT ${storyHeight / 1000}\n`;
            for (let s = storeys; s >= 1; s--) {
                e2k += `STORY "STORY${s}" HEIGHT ${storyHeight / 1000}\n`;
            }
            e2k += `STORY "BASE" ELEV 0\n\n`;

            // GRID SYSTEM
            e2k += `$ GRID SYSTEM\n`;
            e2k += `GRIDSYSTEM "Default"\n`;

            // X Grid lines
            let xLines = [0];
            for (let s of state.xSpans) xLines.push(xLines[xLines.length - 1] + s);
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < xLines.length; i++) {
                e2k += `GRIDLINE  "Default"  "${letters[i]}"  "X"  ${xLines[i].toFixed(3)}\n`;
            }

            // Y Grid lines
            let yLines = [0];
            for (let s of state.ySpans) yLines.push(yLines[yLines.length - 1] + s);
            for (let i = 0; i < yLines.length; i++) {
                e2k += `GRIDLINE  "Default"  "${i + 1}"  "Y"  ${yLines[i].toFixed(3)}\n`;
            }
            e2k += `\n`;

            // POINT COORDINATES (columns)
            e2k += `$ POINT COORDINATES\n`;
            for (let col of state.columns) {
                e2k += `POINT "${col.id}"  ${col.x.toFixed(3)}  ${col.y.toFixed(3)}\n`;
            }
            e2k += `\n`;

            // COLUMN SECTION
            e2k += `$ FRAME SECTIONS\n`;
            e2k += `FRAMESECTION "COL250x400" MATERIAL "C25" SHAPE "RECTANGULAR" D 0.4 B 0.25\n`;
            e2k += `FRAMESECTION "BEAM250x350" MATERIAL "C25" SHAPE "RECTANGULAR" D 0.35 B 0.25\n\n`;

            // COLUMN ASSIGNMENTS
            e2k += `$ COLUMN ASSIGNS\n`;
            for (let col of state.columns) {
                for (let s = 1; s <= storeys; s++) {
                    e2k += `COLUMNASSIGN "${col.id}-S${s}" SECTION "COL250x400" STORY "STORY${s}"\n`;
                }
                e2k += `COLUMNASSIGN "${col.id}-RF" SECTION "COL250x400" STORY "ROOF"\n`;
            }
            e2k += `\n`;

            // AREA LOADS
            e2k += `$ LOAD PATTERNS\n`;
            e2k += `LOADPATTERN "DEAD" TYPE "DEAD"\n`;
            e2k += `LOADPATTERN "LIVE" TYPE "LIVE"\n`;
            e2k += `LOADPATTERN "SDL" TYPE "SUPERIMPOSED DEAD"\n\n`;

            // LOAD COMBINATIONS
            e2k += `$ LOAD COMBINATIONS\n`;
            e2k += `COMBO "1.2D+1.6L" TYPE "LINEAR ADD"\n`;
            e2k += `COMBO "1.2D+1.6L" LOAD "DEAD" SF 1.2\n`;
            e2k += `COMBO "1.2D+1.6L" LOAD "SDL" SF 1.2\n`;
            e2k += `COMBO "1.2D+1.6L" LOAD "LIVE" SF 1.6\n\n`;

            e2k += `END\n`;

            downloadFile(e2k, 'structure.e2k', 'text/plain');
        }

        // ========== SAP2000 Export ==========
        function exportSAP2000() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const storyHeight = 3.0;

            let s2k = `File ${new Date().toISOString()}\n`;
            s2k += `; SAP2000 v24\n`;
            s2k += `; Generated by Tributary Pro - Pang-Masa Engineering\n\n`;

            s2k += `TABLE:  "PROGRAM CONTROL"\n`;
            s2k += `ProgramName=SAP2000   Version=24.0.0   CurrUnits="KN, m, C"\n\n`;

            s2k += `TABLE:  "ACTIVE DEGREES OF FREEDOM"\n`;
            s2k += `UX=Yes   UY=Yes   UZ=Yes   RX=Yes   RY=Yes   RZ=Yes\n\n`;

            // JOINT COORDINATES
            s2k += `TABLE:  "JOINT COORDINATES"\n`;
            s2k += `Joint,CoordSys,CoordType,XorR,Y,Z\n`;

            let jointId = 1;
            const jointMap = {};

            for (let col of state.columns) {
                for (let s = 0; s <= storeys; s++) {
                    const z = s * storyHeight;
                    s2k += `${jointId},GLOBAL,Cartesian,${col.x.toFixed(4)},${col.y.toFixed(4)},${z.toFixed(4)}\n`;
                    if (!jointMap[col.id]) jointMap[col.id] = {};
                    jointMap[col.id][s] = jointId;
                    jointId++;
                }
            }
            s2k += `\n`;

            // FRAME CONNECTIVITY
            s2k += `TABLE:  "CONNECTIVITY - FRAME"\n`;
            s2k += `Frame,JointI,JointJ,IsCurved\n`;

            let frameId = 1;
            for (let col of state.columns) {
                for (let s = 0; s < storeys; s++) {
                    const jI = jointMap[col.id][s];
                    const jJ = jointMap[col.id][s + 1];
                    s2k += `${frameId},${jI},${jJ},No\n`;
                    frameId++;
                }
            }
            s2k += `\n`;

            // FRAME SECTIONS
            s2k += `TABLE:  "FRAME SECTION PROPERTIES 01 - GENERAL"\n`;
            s2k += `SectionName,Material,Shape,t3,t2\n`;
            s2k += `COL250x400,C25,Rectangular,0.4,0.25\n`;
            s2k += `BEAM250x350,C25,Rectangular,0.35,0.25\n\n`;

            // JOINT RESTRAINTS
            s2k += `TABLE:  "JOINT RESTRAINT ASSIGNMENTS"\n`;
            s2k += `Joint,U1,U2,U3,R1,R2,R3\n`;
            for (let col of state.columns) {
                s2k += `${jointMap[col.id][0]},Yes,Yes,Yes,Yes,Yes,Yes\n`;
            }
            s2k += `\n`;

            // LOAD PATTERNS
            s2k += `TABLE:  "LOAD PATTERN DEFINITIONS"\n`;
            s2k += `LoadPat,DesignType,SelfWtMult\n`;
            s2k += `DEAD,DEAD,1\n`;
            s2k += `LIVE,LIVE,0\n`;
            s2k += `SDL,SUPER DEAD,0\n\n`;

            // JOINT LOADS
            s2k += `TABLE:  "JOINT LOADS - FORCE"\n`;
            s2k += `Joint,LoadPat,CoordSys,F1,F2,F3,M1,M2,M3\n`;

            for (let col of state.columns) {
                const load = col.loadPerFloor || col.tribArea * 13.5;
                for (let s = 1; s <= storeys; s++) {
                    s2k += `${jointMap[col.id][s]},DEAD,GLOBAL,0,0,-${load.toFixed(2)},0,0,0\n`;
                }
            }
            s2k += `\n`;

            s2k += `END TABLE DATA\n`;

            downloadFile(s2k, 'structure.s2k', 'text/plain');
        }

        // ========== Tekla Export ==========
        function exportTekla() {
            const storeys = parseInt(document.getElementById('numStoreys').value) || 2;
            const storyHeight = 3000; // mm

            let tekla = `# Tekla Structural Designer Import\n`;
            tekla += `# Generated by Tributary Pro - Pang-Masa Engineering\n`;
            tekla += `# ${new Date().toLocaleString()}\n\n`;

            tekla += `# GRID SYSTEM\n`;
            tekla += `[GRIDS]\n`;

            // X Grid lines
            let xLines = [0];
            for (let s of state.xSpans) xLines.push(xLines[xLines.length - 1] + s);
            const letters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
            for (let i = 0; i < xLines.length; i++) {
                tekla += `X,${letters[i]},${(xLines[i] * 1000).toFixed(0)}\n`;
            }

            // Y Grid lines
            let yLines = [0];
            for (let s of state.ySpans) yLines.push(yLines[yLines.length - 1] + s);
            for (let i = 0; i < yLines.length; i++) {
                tekla += `Y,${i + 1},${(yLines[i] * 1000).toFixed(0)}\n`;
            }
            tekla += `\n`;

            // LEVELS
            tekla += `[LEVELS]\n`;
            for (let s = 0; s <= storeys; s++) {
                const name = s === 0 ? 'Ground' : s === storeys ? 'Roof' : `Floor ${s}`;
                tekla += `${name},${s * storyHeight}\n`;
            }
            tekla += `\n`;

            // COLUMNS
            tekla += `[COLUMNS]\n`;
            tekla += `# ID,GridX,GridY,StartLevel,EndLevel,Width,Depth\n`;
            for (let col of state.columns) {
                for (let s = 0; s < storeys; s++) {
                    const startLevel = s === 0 ? 'Ground' : `Floor ${s}`;
                    const endLevel = s === storeys - 1 ? 'Roof' : `Floor ${s + 1}`;
                    tekla += `${col.id}_S${s + 1},${letters[col.xi]},${col.yi + 1},${startLevel},${endLevel},250,400\n`;
                }
            }
            tekla += `\n`;

            // LOADS
            tekla += `[AREA LOADS]\n`;
            tekla += `# LoadCase,Level,Load(kN/m2)\n`;
            const DL = parseFloat(document.getElementById('deadLoad').value) || 5.0;
            const LL = parseFloat(document.getElementById('liveLoad').value) || 2.0;

            for (let s = 1; s <= storeys; s++) {
                const level = s === storeys ? 'Roof' : `Floor ${s}`;
                tekla += `Dead,${level},${DL.toFixed(1)}\n`;
                tekla += `Live,${level},${LL.toFixed(1)}\n`;
            }
            tekla += `\n`;

            // TRIBUTARY AREAS (custom data)
            tekla += `[TRIBUTARY AREAS]\n`;
            tekla += `# Column,Area(m2),Load/Floor(kN)\n`;
            for (let col of state.columns) {
                tekla += `${col.id},${col.tribArea.toFixed(2)},${(col.loadPerFloor || 0).toFixed(0)}\n`;
            }

            downloadFile(tekla, 'structure_tekla.txt', 'text/plain');
        }

        // Helper function to download files
        function downloadFile(content, filename, contentType) {
            const blob = new Blob([content], { type: contentType });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);

            // Hide export menu
            document.getElementById('exportMenu').style.display = 'none';
        }
    </script>
</body>

</html>