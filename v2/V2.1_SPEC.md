# ðŸ“Œ Tributary Pro v2.1 - Area Shapes + Centroids Spec

**Approved by:** Lum
**Date:** December 15, 2025
**Status:** APPROVED - Ready for Implementation

---

## ðŸŽ¯ Goal

Upgrade `Tributary Pro v2.0` into **v2.1** where:

1. Keep correct beam tributary areas & loads (v2.0 baseline)
2. **Materialize tributary shapes** (polygons) on slab
3. Compute and display **area + centroid coordinates** for each shape

*Think of it as the old AutoLISP triangle-area workflow, pero browser-based, with clean geometry, and exportable data.*

---

## 1. Data Model Changes

### Extend beam object:
```javascript
beam.tributaryRegions = []; 
// Each region:
{
  id: string,              // e.g. "R-BX-2-1-top"
  slabId: string,          // link back to slab (e.g. "S-1-1")
  polygon: [{ x, y }, ...],// closed polygon in global coords
  area: number,            // mÂ² (from polygon formula)
  cx: number,              // centroid x
  cy: number,              // centroid y
  tributaryWidth: number,  // effective width for this beam
  w: number                // kN/m contributed by this region
}
```

### Add slab ID:
```javascript
slab.id = `S-${slab.yi + 1}-${slab.xi + 1}`;
```

---

## 2. Geometry & Area Logic

### 2.1 Two-Way Slab (45Â° Distribution)

Use 4 triangular regions to center:

```javascript
const cx_mid = (x0 + x1) / 2;
const cy_mid = (y0 + y1) / 2;

// Top region (triangle):
const topRegion = [
  { x: x0,     y: y0 },     // left-top corner
  { x: x1,     y: y0 },     // right-top corner
  { x: cx_mid, y: cy_mid }  // slab center
];

// Bottom region:
const bottomRegion = [
  { x: x0,     y: y1 },
  { x: x1,     y: y1 },
  { x: cx_mid, y: cy_mid }
];

// Left region:
const leftRegion = [
  { x: x0, y: y0 },
  { x: x0, y: y1 },
  { x: cx_mid, y: cy_mid }
];

// Right region:
const rightRegion = [
  { x: x1, y: y0 },
  { x: x1, y: y1 },
  { x: cx_mid, y: cy_mid }
];
```

### 2.2 One-Way Slab

Split into 2 rectangles:

```javascript
// If lx < ly â†’ spanning in Y (supported by left/right beams):
const midX = (x0 + x1) / 2;

const leftRegion = [
  { x: x0,   y: y0 },
  { x: midX, y: y0 },
  { x: midX, y: y1 },
  { x: x0,   y: y1 }
];

const rightRegion = [
  { x: midX, y: y0 },
  { x: x1,   y: y0 },
  { x: x1,   y: y1 },
  { x: midX, y: y1 }
];
```

---

## 3. Polygon Area & Centroid Formula

```javascript
function computePolygonAreaAndCentroid(points) {
  let A = 0;
  let Cx = 0;
  let Cy = 0;
  const n = points.length;

  for (let i = 0; i < n; i++) {
    const { x: x0, y: y0 } = points[i];
    const { x: x1, y: y1 } = points[(i + 1) % n];
    const cross = x0 * y1 - x1 * y0;
    A  += cross;
    Cx += (x0 + x1) * cross;
    Cy += (y0 + y1) * cross;
  }

  A *= 0.5;
  const factor = 1 / (6 * A);

  return {
    area: Math.abs(A),
    cx: Cx * factor,
    cy: Cy * factor
  };
}
```

---

## 4. Generating Tributary Regions

```javascript
function generateTributaryRegions(pu) {
  // Reset per-beam regions
  for (let beam of state.beams) {
    beam.tributaryRegions = [];
    beam.tributaryArea = 0;
    beam.tributaryWidth = 0;
    beam.w = 0;
  }

  for (let slab of state.slabs) {
    // Build regions based on 2-way or 1-way logic
    // Compute area + centroid for each polygon
    // Normalize so total = slab.area
    // Add to beam's tributaryRegions array
  }

  // Final totals per beam
  for (let beam of state.beams) {
    beam.tributaryWidth = beam.tributaryArea / beam.span;
    beam.w = pu * beam.tributaryWidth;
  }
}
```

Call order:
```javascript
generateBeams(pu);
generateTributaryRegions(pu);
calculateBeamReactions();
calculateColumnLoads();
```

---

## 5. UI / Visualization Changes

### New Toggle Button:
`Areas` button in toolbar (active/inactive)

### Behavior:
1. **Areas OFF:** Current behavior (nodes + beams, labels)
2. **Areas ON & no selection:** Draw all tributary polygons with low opacity
3. **Beam selected:** Highlight beam + show only its regions at higher opacity

### Labels at (cx, cy):
```
A = XX.X mÂ²
w = YY.Y kN/m
```

---

## 6. Export: Region Table

New sheet: **`Beam_Tributary_Regions`**

Columns:
- `beam_id`
- `direction` (X/Y)
- `floor` (if applicable)
- `region_id`
- `slab_id`
- `area_m2`
- `centroid_x_m`
- `centroid_y_m`
- `tributary_width_m`
- `w_kN_per_m`

---

## 7. Guardrails

- Don't change existing v2.0 numeric behavior for totals
- Total slab area = sum of all regions
- If using 4 equal triangles, still normalize to exact slab area

---

**This is the bridge to PyNite / OpenSees!** ðŸš€
