<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tributary Pro v2.1 | Structural Load Analysis</title>
    <style>
        /* ========== RESET & VARIABLES ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00d4ff;
            --secondary: #7c3aed;
            --dark: #0f1419;
            --darker: #080b0e;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0d1117 100%);
            min-height: 100vh;
            color: #e6edf3;
            overflow-x: hidden;
        }

        /* ========== HEADER ========== */
        .header {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .logo h1 span {
            color: var(--primary);
        }

        .version-badge {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-left: 8px;
        }

        /* ========== MAIN LAYOUT ========== */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            height: calc(100vh - 60px);
        }

        .panel {
            background: var(--glass);
            border-right: 1px solid var(--border);
            padding: 16px;
            overflow-y: auto;
        }

        .panel:last-child {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        /* ========== INPUT GROUPS ========== */
        .param-group {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .param-group h3 {
            font-size: 0.8rem;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .param-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .param-item label {
            display: block;
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .param-item input,
        .param-item select {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .param-item input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* ========== SPAN INPUTS ========== */
        .span-container {
            margin-bottom: 12px;
        }

        .span-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .span-header h4 {
            font-size: 0.75rem;
            color: #8b949e;
        }

        .add-span-btn {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .span-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            align-items: center;
        }

        .span-row input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .span-row .remove-btn {
            background: rgba(255, 100, 100, 0.3);
            color: #ff6b6b;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        /* ========== CANVAS AREA ========== */
        .canvas-container {
            display: flex;
            flex-direction: column;
            background: var(--darker);
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 20px;
            color: #8b949e;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .tool-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mainCanvas {
            background: #0a0d10;
            cursor: crosshair;
        }

        /* ========== RESULTS PANEL ========== */
        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .summary-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .summary-card .label {
            font-size: 0.65rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .summary-card .value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
        }

        .summary-card .unit {
            font-size: 0.65rem;
            color: #8b949e;
        }

        /* ========== RESULTS TABLE ========== */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .results-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            text-align: left;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
        }

        .results-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border);
        }

        .results-table tr:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        /* ========== BUTTONS ========== */
        .action-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
        }

        /* ========== LOAD PATH INDICATOR ========== */
        .load-path {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(0, 212, 255, 0.1));
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: center;
        }

        .load-path h4 {
            color: var(--success);
            font-size: 0.75rem;
            margin-bottom: 6px;
        }

        .load-path .path {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .load-path .arrow {
            color: var(--primary);
            margin: 0 8px;
        }
    </style>
</head>

<body>
    <!-- ========== HEADER ========== -->
    <header class="header">
        <div class="logo">
            <div class="logo-icon">üìê</div>
            <h1>Tributary <span>Pro</span> <span class="version-badge">v2.1</span></h1>
        </div>
        <div class="header-actions">
            <button class="tool-btn" onclick="calculate()">üîÑ Calculate</button>
            <button class="tool-btn" onclick="exportResults()">üì§ Export</button>
        </div>
    </header>

    <!-- ========== MAIN LAYOUT ========== -->
    <div class="app-container">
        <!-- ========== LEFT PANEL: INPUTS ========== -->
        <div class="panel">
            <div class="panel-header">üì• Input Parameters</div>

            <!-- Load Path Indicator -->
            <div class="load-path">
                <h4>‚úÖ v2.0 Load Path (Correct)</h4>
                <div class="path">
                    SLAB <span class="arrow">‚Üí</span>
                    BEAMS <span class="arrow">‚Üí</span>
                    COLUMNS
                </div>
            </div>

            <!-- Grid Spans -->
            <div class="param-group">
                <h3>üìè X-Direction Spans (m)</h3>
                <div id="xSpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('x')">+ Add X Span</button>
            </div>

            <div class="param-group">
                <h3>üìê Y-Direction Spans (m)</h3>
                <div id="ySpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('y')">+ Add Y Span</button>
            </div>

            <!-- Load Parameters -->
            <div class="param-group">
                <h3>‚¨áÔ∏è Load Parameters</h3>
                <div class="param-grid">
                    <div class="param-item">
                        <!-- DL_super: superimposed dead load (kPa), EXCLUDING slab self-weight -->
                        <label>DL Super (kPa) <span style="font-size:0.6rem;color:#f59e0b"
                                title="Finishes, partitions, ceiling - NOT slab weight">‚ìò</span></label>
                        <input type="number" id="dlSuper" value="2.0" step="0.5" min="0">
                    </div>
                    <div class="param-item">
                        <label>Live Load (kPa)</label>
                        <input type="number" id="liveLoad" value="2.0" step="0.5" min="0">
                    </div>
                    <div class="param-item">
                        <label>Slab Thickness (mm)</label>
                        <input type="number" id="slabThickness" value="150" step="10" min="100">
                    </div>
                    <div class="param-item">
                        <label>Floors</label>
                        <input type="number" id="numFloors" value="3" step="1" min="1" max="50">
                    </div>
                </div>
            </div>

            <!-- Calculate Button -->
            <button class="action-btn" onclick="calculate()">
                üîÑ Calculate Loads
            </button>
        </div>

        <!-- ========== CENTER: CANVAS ========== -->
        <div class="canvas-container">
            <div class="canvas-toolbar">
                <button class="tool-btn active" id="selectTool">üîç Select</button>
                <button class="tool-btn" onclick="zoomIn()">‚ûï Zoom In</button>
                <button class="tool-btn" onclick="zoomOut()">‚ûñ Zoom Out</button>
                <button class="tool-btn" onclick="fitView()">‚ä° Fit</button>
                <button class="tool-btn" id="toggleLabels" onclick="toggleLabels()">üè∑Ô∏è Labels</button>
                <button class="tool-btn" id="toggleAreas" onclick="toggleAreas()">üî∫ Areas</button>
            </div>
            <div class="canvas-wrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>

        <!-- ========== RIGHT PANEL: RESULTS ========== -->
        <div class="panel">
            <div class="panel-header">üìä Results</div>

            <!-- Summary Cards -->
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="label">Total Slab Area</div>
                    <div class="value" id="totalArea">0</div>
                    <div class="unit">m¬≤</div>
                </div>
                <div class="summary-card">
                    <div class="label">Factored Load</div>
                    <div class="value" id="factoredLoad">0</div>
                    <div class="unit">kPa</div>
                </div>
                <div class="summary-card">
                    <div class="label">Total/Floor</div>
                    <div class="value" id="totalPerFloor">0</div>
                    <div class="unit">kN</div>
                </div>
                <div class="summary-card">
                    <div class="label">Max Column</div>
                    <div class="value" id="maxColumn">0</div>
                    <div class="unit">kN</div>
                </div>
            </div>

            <!-- Column Results Table -->
            <div class="param-group">
                <h3>üèõÔ∏è Column Loads (Per Floor)</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>Load (kN)</th>
                            </tr>
                        </thead>
                        <tbody id="columnResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Beam Results -->
            <div class="param-group">
                <h3>üìè Beam Loads</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Beam</th>
                                <th>w (kN/m)</th>
                                <th>R (kN)</th>
                            </tr>
                        </thead>
                        <tbody id="beamResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== JAVASCRIPT ========== -->
    <script>
        // ========================================
        // TRIBUTARY PRO v2.0 - CORE ENGINE
        // ========================================
        // Load Path: SLAB ‚Üí BEAMS ‚Üí COLUMNS
        // Per Lum's Refined Spec (Dec 15, 2025)
        // ========================================

        // ========== STATE ==========
        const state = {
            xSpans: [4.0, 4.0],      // X-direction bay sizes (m)
            ySpans: [5.0, 5.0],      // Y-direction bay sizes (m)

            // Load parameters
            dlSuper: 2.0,            // Superimposed dead load (kPa) - NOT slab weight
            liveLoad: 2.0,           // Live load (kPa)
            slabThickness: 150,      // mm
            numFloors: 3,

            // Generated data
            columns: [],             // Column objects
            beams: [],               // Beam objects
            slabs: [],               // Slab panel objects

            // View state
            scale: 50,
            offsetX: 100,
            offsetY: 100,
            showLabels: true,
            showAreas: false,
            selectedBeam: null
        };

        // ========== CANVAS SETUP ==========
        let canvas, ctx;

        function initCanvas() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            draw();
        }

        // ========== SPAN UI ==========
        function renderSpans() {
            renderSpanInputs('x', state.xSpans, 'xSpansContainer');
            renderSpanInputs('y', state.ySpans, 'ySpansContainer');
        }

        function renderSpanInputs(dir, spans, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            spans.forEach((span, i) => {
                const row = document.createElement('div');
                row.className = 'span-row';
                row.innerHTML = `
                    <span style="color:#8b949e;font-size:0.7rem;width:30px;">${dir.toUpperCase()}${i + 1}</span>
                    <input type="number" value="${span}" step="0.5" min="1" max="20"
                           onchange="updateSpan('${dir}', ${i}, this.value)">
                    <button class="remove-btn" onclick="removeSpan('${dir}', ${i})" 
                            ${spans.length <= 1 ? 'disabled' : ''}>√ó</button>
                `;
                container.appendChild(row);
            });
        }

        function updateSpan(dir, index, value) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans[index] = parseFloat(value) || 4.0;
            calculate();
        }

        function addSpan(dir) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans.push(4.0);
            renderSpans();
            calculate();
        }

        function removeSpan(dir, index) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            if (spans.length > 1) {
                spans.splice(index, 1);
                renderSpans();
                calculate();
            }
        }
        // ========== POLYGON UTILITIES (v2.1) ==========

        /**
         * Compute area and centroid of a polygon using shoelace formula
         * @param {Array} points - Array of {x, y} objects
         * @returns {Object} - {area, cx, cy}
         */
        function computePolygonAreaAndCentroid(points) {
            let A = 0;
            let Cx = 0;
            let Cy = 0;
            const n = points.length;

            for (let i = 0; i < n; i++) {
                const { x: x0, y: y0 } = points[i];
                const { x: x1, y: y1 } = points[(i + 1) % n];
                const cross = x0 * y1 - x1 * y0;
                A += cross;
                Cx += (x0 + x1) * cross;
                Cy += (y0 + y1) * cross;
            }

            A *= 0.5;
            const factor = A !== 0 ? 1 / (6 * A) : 0;

            return {
                area: Math.abs(A),
                cx: Cx * factor,
                cy: Cy * factor
            };
        }

        // ========== CORE CALCULATIONS ==========

        /**
         * Main calculation function
         * Implements: SLAB ‚Üí BEAMS ‚Üí COLUMNS load path
         */
        function calculate() {
            // Read input values
            state.dlSuper = parseFloat(document.getElementById('dlSuper').value) || 2.0;
            state.liveLoad = parseFloat(document.getElementById('liveLoad').value) || 2.0;
            state.slabThickness = parseFloat(document.getElementById('slabThickness').value) || 150;
            state.numFloors = parseInt(document.getElementById('numFloors').value) || 3;

            // Step 1: Generate grid coordinates
            generateGrid();

            // Step 2: Generate slab panels
            generateSlabs();

            // Step 3: Calculate factored load
            // p_u = 1.2 * (DL_super + slab_weight) + 1.6 * LL
            const slabWeight = 24 * (state.slabThickness / 1000); // kN/m¬≤ = kPa
            const pu = 1.2 * (state.dlSuper + slabWeight) + 1.6 * state.liveLoad;

            // Step 4: Generate beams and calculate tributary widths
            generateBeams(pu);

            // Step 5: Calculate beam reactions
            calculateBeamReactions();

            // Step 6: Calculate column loads (sum of beam reactions)
            calculateColumnLoads();

            // Update UI
            updateResults(pu);
            draw();
        }

        /**
         * Step 1: Generate grid from spans
         * Creates absolute coordinates for column positions
         */
        function generateGrid() {
            // Build X coordinates
            const xCoords = [0];
            for (let span of state.xSpans) {
                xCoords.push(xCoords[xCoords.length - 1] + span);
            }

            // Build Y coordinates
            const yCoords = [0];
            for (let span of state.ySpans) {
                yCoords.push(yCoords[yCoords.length - 1] + span);
            }

            // Generate columns at intersections
            state.columns = [];
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Skip I and O

            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < xCoords.length; xi++) {
                    const id = `${letters[xi]}${yi + 1}`;

                    // Determine column type
                    const isCorner = (xi === 0 || xi === xCoords.length - 1) &&
                        (yi === 0 || yi === yCoords.length - 1);
                    const isEdge = !isCorner && (xi === 0 || xi === xCoords.length - 1 ||
                        yi === 0 || yi === yCoords.length - 1);

                    let type = 'interior';
                    if (isCorner) type = 'corner';
                    else if (isEdge) type = 'edge';

                    state.columns.push({
                        id,
                        x: xCoords[xi],
                        y: yCoords[yi],
                        xi, yi,
                        type,
                        loadPerFloor: 0,
                        totalLoad: 0,
                        connectedBeams: [] // Will store beam IDs
                    });
                }
            }
        }

        /**
         * Step 2: Generate slab panels
         */
        function generateSlabs() {
            state.slabs = [];
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            for (let yi = 0; yi < state.ySpans.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    const lx = state.xSpans[xi]; // Short span
                    const ly = state.ySpans[yi]; // Long span

                    // Check if 2-way (ratio < 2)
                    const ratio = Math.max(lx, ly) / Math.min(lx, ly);
                    const isTwoWay = ratio < 2;

                    state.slabs.push({
                        id: `S-${yi + 1}-${xi + 1}`,  // v2.1: updated ID format
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi + 1],
                        y2: yCoords[yi + 1],
                        lx, ly,
                        area: lx * ly,
                        isTwoWay,
                        xi, yi
                    });
                }
            }
        }

        /**
         * Step 3 & 4: Generate beams and calculate tributary widths
         * v2.1: Now generates polygon regions with area & centroid
         */
        function generateBeams(pu) {
            state.beams = [];

            // X-direction beams (horizontal, span in X)
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            // Create beam objects with zero tributary areas and empty regions
            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    const beamSpan = state.xSpans[xi];
                    const beamId = `BX-${yi + 1}-${xi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'X',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi + 1],
                        y2: yCoords[yi],
                        span: beamSpan,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        tributaryRegions: [],  // v2.1: polygon regions
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // Y-direction beams (along gridlines in X direction)
            for (let xi = 0; xi < xCoords.length; xi++) {
                for (let yi = 0; yi < state.ySpans.length; yi++) {
                    const beamSpan = state.ySpans[yi];
                    const beamId = `BY-${xi + 1}-${yi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'Y',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi],
                        y2: yCoords[yi + 1],
                        span: beamSpan,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        tributaryRegions: [],  // v2.1: polygon regions
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // Map for quick access
            const beamMap = Object.fromEntries(state.beams.map(beam => [beam.id, beam]));

            // v2.1: Generate tributary regions with polygons
            for (let slab of state.slabs) {
                const x0 = slab.x1;
                const x1 = slab.x2;
                const y0 = slab.y1;
                const y1 = slab.y2;
                const cx_mid = (x0 + x1) / 2;
                const cy_mid = (y0 + y1) / 2;

                const topBeamId = `BX-${slab.yi + 1}-${slab.xi + 1}`;
                const bottomBeamId = `BX-${slab.yi + 2}-${slab.xi + 1}`;
                const leftBeamId = `BY-${slab.xi + 1}-${slab.yi + 1}`;
                const rightBeamId = `BY-${slab.xi + 2}-${slab.yi + 1}`;

                if (slab.isTwoWay) {
                    // v2.1: Create 4 triangle regions to center (diagonals)
                    const topPolygon = [
                        { x: x0, y: y0 },
                        { x: x1, y: y0 },
                        { x: cx_mid, y: cy_mid }
                    ];
                    const bottomPolygon = [
                        { x: x0, y: y1 },
                        { x: x1, y: y1 },
                        { x: cx_mid, y: cy_mid }
                    ];
                    const leftPolygon = [
                        { x: x0, y: y0 },
                        { x: x0, y: y1 },
                        { x: cx_mid, y: cy_mid }
                    ];
                    const rightPolygon = [
                        { x: x1, y: y0 },
                        { x: x1, y: y1 },
                        { x: cx_mid, y: cy_mid }
                    ];

                    const regions = [
                        { role: 'top', beamId: topBeamId, polygon: topPolygon },
                        { role: 'bottom', beamId: bottomBeamId, polygon: bottomPolygon },
                        { role: 'left', beamId: leftBeamId, polygon: leftPolygon },
                        { role: 'right', beamId: rightBeamId, polygon: rightPolygon }
                    ];

                    // Compute area + centroid for each polygon
                    let totalRegionArea = 0;
                    for (let reg of regions) {
                        const { area, cx, cy } = computePolygonAreaAndCentroid(reg.polygon);
                        reg.area_raw = area;
                        reg.cx = cx;
                        reg.cy = cy;
                        totalRegionArea += area;
                    }

                    // Normalize so total = slab.area
                    const scale = totalRegionArea > 0 ? slab.area / totalRegionArea : 0;

                    for (let reg of regions) {
                        const beam = beamMap[reg.beamId];
                        if (!beam) continue;

                        const finalArea = reg.area_raw * scale;
                        const tribWidth = finalArea / beam.span;
                        const w = pu * tribWidth;

                        beam.tributaryArea += finalArea;
                        beam.tributaryRegions.push({
                            id: `${reg.beamId}-${reg.role}`,
                            slabId: slab.id,
                            polygon: reg.polygon,
                            area: finalArea,
                            cx: reg.cx,
                            cy: reg.cy,
                            tributaryWidth: tribWidth,
                            w: w
                        });
                    }
                } else {
                    // One-way slab: split into 2 rectangles
                    const midX = (x0 + x1) / 2;
                    const midY = (y0 + y1) / 2;

                    let regions;
                    if (slab.lx < slab.ly) {
                        // Spanning in Y, supported by left/right beams
                        const leftPolygon = [
                            { x: x0, y: y0 },
                            { x: midX, y: y0 },
                            { x: midX, y: y1 },
                            { x: x0, y: y1 }
                        ];
                        const rightPolygon = [
                            { x: midX, y: y0 },
                            { x: x1, y: y0 },
                            { x: x1, y: y1 },
                            { x: midX, y: y1 }
                        ];
                        regions = [
                            { role: 'left', beamId: leftBeamId, polygon: leftPolygon },
                            { role: 'right', beamId: rightBeamId, polygon: rightPolygon }
                        ];
                    } else {
                        // Spanning in X, supported by top/bottom beams
                        const topPolygon = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: x1, y: midY },
                            { x: x0, y: midY }
                        ];
                        const bottomPolygon = [
                            { x: x0, y: midY },
                            { x: x1, y: midY },
                            { x: x1, y: y1 },
                            { x: x0, y: y1 }
                        ];
                        regions = [
                            { role: 'top', beamId: topBeamId, polygon: topPolygon },
                            { role: 'bottom', beamId: bottomBeamId, polygon: bottomPolygon }
                        ];
                    }

                    for (let reg of regions) {
                        const { area, cx, cy } = computePolygonAreaAndCentroid(reg.polygon);
                        const beam = beamMap[reg.beamId];
                        if (!beam) continue;

                        const tribWidth = area / beam.span;
                        const w = pu * tribWidth;

                        beam.tributaryArea += area;
                        beam.tributaryRegions.push({
                            id: `${reg.beamId}-${reg.role}`,
                            slabId: slab.id,
                            polygon: reg.polygon,
                            area: area,
                            cx: cx,
                            cy: cy,
                            tributaryWidth: tribWidth,
                            w: w
                        });
                    }
                }
            }

            // Finalize tributary widths and loads
            for (let beam of state.beams) {
                beam.tributaryWidth = beam.tributaryArea / beam.span;
                beam.w = pu * beam.tributaryWidth;
            }
        }

        /**
         * Step 5: Calculate beam reactions
         * For uniform load: R_left = R_right = w * L / 2
         */
        function calculateBeamReactions() {
            for (let beam of state.beams) {
                // Simply supported beam with uniform load
                // R = w * L / 2
                beam.Rleft = beam.w * beam.span / 2;
                beam.Rright = beam.w * beam.span / 2;
            }
        }

        /**
         * Step 6: Calculate column loads
         * Column load = Sum of all beam reactions at that column
         */
        function calculateColumnLoads() {
            // Reset column loads
            for (let col of state.columns) {
                col.loadPerFloor = 0;
                col.connectedBeams = [];
            }

            // Sum beam reactions to columns
            for (let beam of state.beams) {
                // Find columns at beam ends
                let colLeft, colRight;

                if (beam.direction === 'X') {
                    // X beam: connects columns at same yi, adjacent xi
                    colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                    colRight = state.columns.find(c => c.xi === beam.xi + 1 && c.yi === beam.yi);
                } else {
                    // Y beam: connects columns at same xi, adjacent yi
                    colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                    colRight = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi + 1);
                }

                if (colLeft) {
                    colLeft.loadPerFloor += beam.Rleft;
                    colLeft.connectedBeams.push(beam.id);
                }
                if (colRight) {
                    colRight.loadPerFloor += beam.Rright;
                    colRight.connectedBeams.push(beam.id);
                }
            }

            // Calculate total load (sum across floors, not multiply!)
            for (let col of state.columns) {
                // Each floor has same load pattern
                col.totalLoad = col.loadPerFloor * state.numFloors;
            }
        }

        // ========== UI UPDATES ==========
        function updateResults(pu) {
            // Total area
            const totalArea = state.slabs.reduce((sum, s) => sum + s.area, 0);
            document.getElementById('totalArea').textContent = totalArea.toFixed(1);

            // Factored load
            document.getElementById('factoredLoad').textContent = pu.toFixed(2);

            // Total per floor
            const totalPerFloor = state.columns.reduce((sum, c) => sum + c.loadPerFloor, 0);
            document.getElementById('totalPerFloor').textContent = totalPerFloor.toFixed(0);

            // Max column
            const maxCol = Math.max(...state.columns.map(c => c.loadPerFloor));
            document.getElementById('maxColumn').textContent = maxCol.toFixed(0);

            // Column table
            const colBody = document.getElementById('columnResultsBody');
            colBody.innerHTML = state.columns.map(col => `
                <tr>
                    <td><strong>${col.id}</strong></td>
                    <td style="color:${col.type === 'corner' ? '#f59e0b' : col.type === 'edge' ? '#00d4ff' : '#10b981'}">${col.type}</td>
                    <td>${col.loadPerFloor.toFixed(1)}</td>
                </tr>
            `).join('');

            // Beam table
            const beamBody = document.getElementById('beamResultsBody');
            beamBody.innerHTML = state.beams.slice(0, 20).map(beam => `
                <tr>
                    <td>${beam.id}</td>
                    <td>${beam.w.toFixed(1)}</td>
                    <td>${beam.Rleft.toFixed(1)}</td>
                </tr>
            `).join('');
        }

        // ========== DRAWING ==========
        function draw() {
            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw slabs (filled)
            for (let slab of state.slabs) {
                const x1 = slab.x1 * state.scale + state.offsetX;
                const y1 = slab.y1 * state.scale + state.offsetY;
                const w = slab.lx * state.scale;
                const h = slab.ly * state.scale;

                ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
                ctx.fillRect(x1, y1, w, h);
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                ctx.strokeRect(x1, y1, w, h);
            }

            // v2.1: Draw tributary regions when Areas is ON
            if (state.showAreas) {
                const colors = {
                    top: 'rgba(124, 58, 237, 0.3)',    // Purple
                    bottom: 'rgba(124, 58, 237, 0.3)',
                    left: 'rgba(16, 185, 129, 0.3)',   // Green
                    right: 'rgba(16, 185, 129, 0.3)'
                };
                const strokeColors = {
                    top: '#7c3aed',
                    bottom: '#7c3aed',
                    left: '#10b981',
                    right: '#10b981'
                };

                for (let beam of state.beams) {
                    for (let region of beam.tributaryRegions) {
                        // Draw polygon
                        ctx.beginPath();
                        const firstPt = region.polygon[0];
                        ctx.moveTo(
                            firstPt.x * state.scale + state.offsetX,
                            firstPt.y * state.scale + state.offsetY
                        );
                        for (let i = 1; i < region.polygon.length; i++) {
                            const pt = region.polygon[i];
                            ctx.lineTo(
                                pt.x * state.scale + state.offsetX,
                                pt.y * state.scale + state.offsetY
                            );
                        }
                        ctx.closePath();

                        // Get role from region id
                        const role = region.id.split('-').pop();
                        ctx.fillStyle = colors[role] || 'rgba(255,255,255,0.2)';
                        ctx.fill();
                        ctx.strokeStyle = strokeColors[role] || '#fff';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Draw centroid marker and label
                        const cx = region.cx * state.scale + state.offsetX;
                        const cy = region.cy * state.scale + state.offsetY;

                        // Centroid dot
                        ctx.beginPath();
                        ctx.arc(cx, cy, 4, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();

                        // Label at centroid
                        if (state.showLabels) {
                            ctx.fillStyle = 'rgba(0,0,0,0.7)';
                            ctx.fillRect(cx - 30, cy - 18, 60, 24);
                            ctx.fillStyle = '#00d4ff';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(`A=${region.area.toFixed(1)}m¬≤`, cx, cy - 6);
                            ctx.fillStyle = '#f59e0b';
                            ctx.fillText(`w=${region.w.toFixed(1)}kN/m`, cx, cy + 6);
                        }
                    }
                }
            }

            // Draw beams
            ctx.lineWidth = 3;
            for (let beam of state.beams) {
                const x1 = beam.x1 * state.scale + state.offsetX;
                const y1 = beam.y1 * state.scale + state.offsetY;
                const x2 = beam.x2 * state.scale + state.offsetX;
                const y2 = beam.y2 * state.scale + state.offsetY;

                ctx.strokeStyle = beam.direction === 'X' ? '#7c3aed' : '#10b981';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Draw columns
            for (let col of state.columns) {
                const x = col.x * state.scale + state.offsetX;
                const y = col.y * state.scale + state.offsetY;
                const size = 12;

                // Color by type
                let color = '#10b981'; // Interior
                if (col.type === 'corner') color = '#f59e0b';
                else if (col.type === 'edge') color = '#00d4ff';

                ctx.fillStyle = color;
                ctx.fillRect(x - size / 2, y - size / 2, size, size);

                // Label
                if (state.showLabels && !state.showAreas) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(col.id, x, y - 12);
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(`${col.loadPerFloor.toFixed(0)} kN`, x, y + 20);
                }
            }
        }

        // ========== CONTROLS ==========
        function zoomIn() {
            state.scale *= 1.2;
            draw();
        }

        function zoomOut() {
            state.scale /= 1.2;
            draw();
        }

        function fitView() {
            if (state.columns.length === 0) return;

            const maxX = Math.max(...state.columns.map(c => c.x));
            const maxY = Math.max(...state.columns.map(c => c.y));

            const margin = 150;
            const scaleX = (canvas.width - margin * 2) / maxX;
            const scaleY = (canvas.height - margin * 2) / maxY;
            state.scale = Math.min(scaleX, scaleY, 80);

            state.offsetX = (canvas.width - maxX * state.scale) / 2;
            state.offsetY = (canvas.height - maxY * state.scale) / 2;

            draw();
        }

        function toggleLabels() {
            state.showLabels = !state.showLabels;
            document.getElementById('toggleLabels').classList.toggle('active', state.showLabels);
            draw();
        }

        // v2.1: Toggle Areas visualization
        function toggleAreas() {
            state.showAreas = !state.showAreas;
            document.getElementById('toggleAreas').classList.toggle('active', state.showAreas);
            draw();
        }

        function exportResults() {
            // v2.1: Collect all tributary regions for export
            const tributaryRegions = [];
            for (let beam of state.beams) {
                for (let region of beam.tributaryRegions) {
                    tributaryRegions.push({
                        beam_id: beam.id,
                        direction: beam.direction,
                        region_id: region.id,
                        slab_id: region.slabId,
                        area_m2: region.area,
                        centroid_x_m: region.cx,
                        centroid_y_m: region.cy,
                        tributary_width_m: region.tributaryWidth,
                        w_kN_per_m: region.w
                    });
                }
            }

            const data = {
                version: '2.1',
                timestamp: new Date().toISOString(),
                parameters: {
                    xSpans: state.xSpans,
                    ySpans: state.ySpans,
                    dlSuper: state.dlSuper,
                    liveLoad: state.liveLoad,
                    slabThickness: state.slabThickness,
                    numFloors: state.numFloors
                },
                slabs: state.slabs.map(s => ({
                    id: s.id,
                    x1: s.x1, y1: s.y1,
                    x2: s.x2, y2: s.y2,
                    area: s.area,
                    isTwoWay: s.isTwoWay
                })),
                columns: state.columns.map(c => ({
                    id: c.id,
                    x: c.x, y: c.y,
                    type: c.type,
                    loadPerFloor: c.loadPerFloor,
                    totalLoad: c.totalLoad
                })),
                beams: state.beams.map(b => ({
                    id: b.id,
                    direction: b.direction,
                    x1: b.x1, y1: b.y1,
                    x2: b.x2, y2: b.y2,
                    span: b.span,
                    tributaryArea: b.tributaryArea,
                    w: b.w,
                    Rleft: b.Rleft,
                    Rright: b.Rright
                })),
                tributaryRegions: tributaryRegions  // v2.1: detailed region data
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tributary_pro_v2.1_results.json';
            a.click();
        }

        // ========== INIT ==========
        window.onload = function () {
            initCanvas();
            renderSpans();
            calculate();
            fitView();
        };
    </script>
</body>

</html>