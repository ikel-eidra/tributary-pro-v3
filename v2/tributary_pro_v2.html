<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tributary Pro v2.3 | Structural Load Analysis</title>
    <style>
        /* ========== RESET & VARIABLES ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary: #00d4ff;
            --secondary: #7c3aed;
            --dark: #0f1419;
            --darker: #080b0e;
            --glass: rgba(255, 255, 255, 0.05);
            --border: rgba(255, 255, 255, 0.1);
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
        }

        body {
            font-family: 'Segoe UI', system-ui, -apple-system, sans-serif;
            background: linear-gradient(135deg, #0f1419 0%, #1a1f2e 50%, #0d1117 100%);
            min-height: 100vh;
            color: #e6edf3;
            overflow-x: hidden;
        }

        /* ========== HEADER ========== */
        .header {
            background: rgba(0, 0, 0, 0.5);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 12px 24px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            position: sticky;
            top: 0;
            z-index: 100;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .logo h1 span {
            color: var(--primary);
        }

        .version-badge {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-left: 8px;
        }

        /* ========== MAIN LAYOUT ========== */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            height: calc(100vh - 60px);
        }

        .panel {
            background: var(--glass);
            border-right: 1px solid var(--border);
            padding: 16px;
            overflow-y: auto;
        }

        .panel:last-child {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        /* ========== INPUT GROUPS ========== */
        .param-group {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .param-group h3 {
            font-size: 0.8rem;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .param-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .param-item label {
            display: block;
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .param-item input,
        .param-item select {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .param-item input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* ========== SPAN INPUTS ========== */
        .span-container {
            margin-bottom: 12px;
        }

        .span-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .span-header h4 {
            font-size: 0.75rem;
            color: #8b949e;
        }

        .add-span-btn {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .span-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            align-items: center;
        }

        .span-row input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .span-row .remove-btn {
            background: rgba(255, 100, 100, 0.3);
            color: #ff6b6b;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        /* ========== CANVAS AREA ========== */
        .canvas-container {
            display: flex;
            flex-direction: column;
            background: var(--darker);
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 20px;
            color: #8b949e;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        .tool-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mainCanvas {
            background: #0a0d10;
            cursor: crosshair;
        }

        /* ========== RESULTS PANEL ========== */
        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .summary-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .summary-card .label {
            font-size: 0.65rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .summary-card .value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
        }

        .summary-card .unit {
            font-size: 0.65rem;
            color: #8b949e;
        }

        /* ========== RESULTS TABLE ========== */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.7rem;
        }

        .results-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            text-align: left;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
        }

        .results-table td {
            padding: 8px;
            border-bottom: 1px solid var(--border);
        }

        .results-table tr:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        /* ========== BUTTONS ========== */
        .action-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
        }

        /* ========== LOAD PATH INDICATOR ========== */
        .load-path {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(0, 212, 255, 0.1));
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: center;
        }

        .load-path h4 {
            color: var(--success);
            font-size: 0.75rem;
            margin-bottom: 6px;
        }

        .load-path .path {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .load-path .arrow {
            color: var(--primary);
            margin: 0 8px;
        }

        /* ========== FLOOR TABS ========== */
        .floor-tabs-container {
            margin-bottom: 16px;
        }

        .floor-tabs-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .floor-tabs-header h4 {
            font-size: 0.75rem;
            color: var(--primary);
        }

        .floor-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .floor-tab {
            padding: 6px 12px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #8b949e;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .floor-tab:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--primary);
        }

        .floor-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: transparent;
            color: white;
        }

        .floor-tab.roof {
            border-color: var(--warning);
            color: var(--warning);
        }

        .floor-tab.roof.active {
            background: linear-gradient(135deg, var(--warning), #d97706);
            color: white;
        }

        .add-floor-btn {
            padding: 6px 10px;
            background: transparent;
            border: 1px dashed var(--success);
            border-radius: 6px;
            color: var(--success);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-floor-btn:hover {
            background: rgba(16, 185, 129, 0.1);
        }

        .remove-floor-btn {
            padding: 6px 10px;
            background: transparent;
            border: 1px dashed var(--danger);
            border-radius: 6px;
            color: var(--danger);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .remove-floor-btn:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .floor-info {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin-top: 8px;
        }

        .floor-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .floor-info-header h5 {
            font-size: 0.75rem;
            color: var(--primary);
        }

        .floor-type-badge {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--secondary);
            color: white;
        }

        .floor-type-badge.roof {
            background: var(--warning);
        }
    </style>
</head>

<body>
    <!-- ========== HEADER ========== -->
    <header class="header">
        <div class="logo">
            <div class="logo-icon">üìê</div>
            <h1>Tributary <span>Pro</span> <span class="version-badge">v2.3</span></h1>
        </div>
        <div class="header-actions">
            <button class="tool-btn" onclick="calculate()">üîÑ Calculate</button>
            <button class="tool-btn" onclick="exportResults()">üì§ Export</button>
        </div>
    </header>

    <!-- ========== MAIN LAYOUT ========== -->
    <div class="app-container">
        <!-- ========== LEFT PANEL: INPUTS ========== -->
        <div class="panel">
            <div class="panel-header">üì• Input Parameters</div>

            <!-- Load Path Indicator -->
            <div class="load-path">
                <h4>‚úÖ v2.0 Load Path (Correct)</h4>
                <div class="path">
                    SLAB <span class="arrow">‚Üí</span>
                    BEAMS <span class="arrow">‚Üí</span>
                    COLUMNS
                </div>
            </div>

            <!-- Grid Spans -->
            <div class="param-group">
                <h3>üìè X-Direction Spans (m)</h3>
                <div id="xSpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('x')">+ Add X Span</button>
            </div>

            <div class="param-group">
                <h3>üìê Y-Direction Spans (m)</h3>
                <div id="ySpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('y')">+ Add Y Span</button>
            </div>

            <!-- v2.3: Floor Tabs -->
            <div class="floor-tabs-container">
                <div class="floor-tabs-header">
                    <h4>üè¢ Floors</h4>
                </div>
                <div class="floor-tabs" id="floorTabs">
                    <!-- Dynamically populated -->
                </div>
                <div style="display: flex; gap: 4px; margin-top: 8px;">
                    <button class="add-floor-btn" onclick="addFloor()">+ Add Floor</button>
                    <button class="remove-floor-btn" onclick="removeFloor()">‚àí Remove</button>
                </div>

                <div class="floor-info" id="floorInfo">
                    <div class="floor-info-header">
                        <h5 id="currentFloorName">Ground Floor</h5>
                        <span class="floor-type-badge" id="floorTypeBadge">Typical</span>
                    </div>
                    <div class="param-grid">
                        <div class="param-item">
                            <label>DL Super (kPa) <span style="font-size:0.6rem;color:#f59e0b"
                                    title="Finishes, partitions, ceiling - NOT slab weight">‚ìò</span></label>
                            <input type="number" id="floorDL" value="2.0" step="0.5" min="0"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Live Load (kPa) <span style="font-size:0.6rem;color:#f59e0b"
                                    title="Can be higher for roof parties/water tanks">‚ìò</span></label>
                            <input type="number" id="floorLL" value="2.0" step="0.5" min="0"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Slab Thickness (mm)</label>
                            <input type="number" id="floorSlabThickness" value="150" step="10" min="100"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Height (m)</label>
                            <input type="number" id="floorHeight" value="3.0" step="0.1" min="2.5"
                                onchange="updateCurrentFloor()">
                        </div>
                    </div>
                </div>
            </div>

            <!-- Calculate Button -->
            <button class="action-btn" onclick="calculate()">
                üîÑ Calculate Loads
            </button>
        </div>

        <!-- ========== CENTER: CANVAS ========== -->
        <div class="canvas-container">
            <div class="canvas-toolbar">
                <button class="tool-btn active" id="selectTool">üîç Select</button>
                <button class="tool-btn" onclick="zoomIn()">‚ûï Zoom In</button>
                <button class="tool-btn" onclick="zoomOut()">‚ûñ Zoom Out</button>
                <button class="tool-btn" onclick="fitView()">‚ä° Fit</button>
                <button class="tool-btn active" id="toggleAreas" onclick="toggleAreas()">üî∫ Areas</button>
                <button class="tool-btn" id="toggleLabels" onclick="toggleLabels()">üè∑Ô∏è Labels</button>
            </div>
            <div class="canvas-wrapper">
                <canvas id="mainCanvas"></canvas>
            </div>
        </div>

        <!-- ========== RIGHT PANEL: RESULTS ========== -->
        <div class="panel">
            <div class="panel-header">üìä Results</div>

            <!-- Summary Cards -->
            <div class="summary-grid">
                <div class="summary-card">
                    <div class="label">Total Slab Area</div>
                    <div class="value" id="totalArea">0</div>
                    <div class="unit">m¬≤</div>
                </div>
                <div class="summary-card">
                    <div class="label">Area Balance</div>
                    <div class="value" id="areaBalance">0%</div>
                    <div class="unit" id="areaBalanceDetail">beam vs slab</div>
                </div>
                <div class="summary-card">
                    <div class="label">Factored Load</div>
                    <div class="value" id="factoredLoad">0</div>
                    <div class="unit">kPa</div>
                </div>
                <div class="summary-card">
                    <div class="label">Total/Floor</div>
                    <div class="value" id="totalPerFloor">0</div>
                    <div class="unit">kN</div>
                </div>
                <div class="summary-card">
                    <div class="label">Max Column</div>
                    <div class="value" id="maxColumn">0</div>
                    <div class="unit">kN</div>
                </div>
            </div>

            <!-- Column Results Table -->
            <div class="param-group">
                <h3>üèõÔ∏è Column Loads</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>ID</th>
                                <th>Type</th>
                                <th>Floor (kN)</th>
                                <th>Total (kN)</th>
                            </tr>
                        </thead>
                        <tbody id="columnResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Beam Results -->
            <div class="param-group">
                <h3>üìè Beam Loads</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Beam</th>
                                <th>w (kN/m)</th>
                                <th>R (kN)</th>
                            </tr>
                        </thead>
                        <tbody id="beamResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>
        </div>
    </div>

    <!-- ========== JAVASCRIPT ========== -->
    <script>
        // ========================================
        // TRIBUTARY PRO v2.0 - CORE ENGINE
        // ========================================
        // Load Path: SLAB ‚Üí BEAMS ‚Üí COLUMNS
        // Per Lum's Refined Spec (Dec 15, 2025)
        // ========================================

        // ========== STATE ==========
        const state = {
            xSpans: [4.0, 4.0],      // X-direction bay sizes (m)
            ySpans: [5.0, 5.0],      // Y-direction bay sizes (m)

            // v2.3: Floors array - per floor configurations
            floors: [
                { id: 'GF', name: 'Ground Floor', dlSuper: 2.0, liveLoad: 2.0, slabThickness: 150, height: 3.0, isRoof: false },
                { id: '2F', name: '2nd Floor', dlSuper: 2.0, liveLoad: 2.0, slabThickness: 150, height: 3.0, isRoof: false },
                { id: '3F', name: '3rd Floor', dlSuper: 2.0, liveLoad: 2.0, slabThickness: 150, height: 3.0, isRoof: false },
                { id: 'RF', name: 'Roof', dlSuper: 1.5, liveLoad: 1.0, slabThickness: 120, height: 3.0, isRoof: true }
            ],
            currentFloorIndex: 0,    // Which floor is selected

            // Generated data
            columns: [],             // Column objects
            beams: [],               // Beam objects
            slabs: [],               // Slab panel objects

            // View state
            scale: 50,
            offsetX: 100,
            offsetY: 100,
            showLabels: true,
            showAreas: true  // v2.2: show slice polygons by default
        };

        const MIN_SPAN = 0.25; // m, guard against zero/negative spans

        function sanitizeSpan(value, fallback = 4.0) {
            const numeric = parseFloat(value);
            if (Number.isFinite(numeric) && numeric > MIN_SPAN) return numeric;
            return fallback;
        }

        // ========== CANVAS SETUP ==========
        let canvas, ctx;

        function initCanvas() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            draw();
        }

        // ========== SPAN UI ==========
        function renderSpans() {
            renderSpanInputs('x', state.xSpans, 'xSpansContainer');
            renderSpanInputs('y', state.ySpans, 'ySpansContainer');
        }

        function renderSpanInputs(dir, spans, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            spans.forEach((span, i) => {
                const row = document.createElement('div');
                row.className = 'span-row';
                row.innerHTML = `
                    <span style="color:#8b949e;font-size:0.7rem;width:30px;">${dir.toUpperCase()}${i + 1}</span>
                    <input type="number" value="${span}" step="0.5" min="${MIN_SPAN}" max="20"
                           onchange="updateSpan('${dir}', ${i}, this.value)">
                    <button class="remove-btn" onclick="removeSpan('${dir}', ${i})"
                            ${spans.length <= 1 ? 'disabled' : ''}>√ó</button>
                `;
                container.appendChild(row);
            });
        }

        function updateSpan(dir, index, value) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans[index] = sanitizeSpan(value, spans[index] || 4.0);
            calculate();
        }

        function addSpan(dir) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans.push(4.0);
            renderSpans();
            calculate();
        }

        function removeSpan(dir, index) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            if (spans.length > 1) {
                spans.splice(index, 1);
                renderSpans();
                calculate();
            }
        }

        // ========== v2.3: FLOOR TABS UI ==========

        function getFloorId(index, total) {
            if (index === 0) return 'GF';
            if (index === total - 1) return 'RF';
            return `${index + 1}F`;
        }

        function getFloorName(id, isRoof) {
            if (id === 'GF') return 'Ground Floor';
            if (isRoof || id === 'RF') return 'Roof';
            return `${id.replace('F', '')}${['st', 'nd', 'rd'][parseInt(id) - 2] || 'th'} Floor`;
        }

        function renderFloorTabs() {
            const container = document.getElementById('floorTabs');
            container.innerHTML = '';

            state.floors.forEach((floor, i) => {
                const btn = document.createElement('button');
                btn.className = `floor-tab${i === state.currentFloorIndex ? ' active' : ''}${floor.isRoof ? ' roof' : ''}`;
                btn.textContent = floor.id;
                btn.onclick = () => selectFloor(i);
                container.appendChild(btn);
            });

            updateFloorUI();
        }

        function selectFloor(index) {
            state.currentFloorIndex = index;
            renderFloorTabs();
        }

        function updateFloorUI() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;

            document.getElementById('currentFloorName').textContent = floor.name;
            document.getElementById('floorTypeBadge').textContent = floor.isRoof ? 'Roof' : 'Typical';
            document.getElementById('floorTypeBadge').className = `floor-type-badge${floor.isRoof ? ' roof' : ''}`;

            document.getElementById('floorDL').value = floor.dlSuper;
            document.getElementById('floorLL').value = floor.liveLoad;
            document.getElementById('floorSlabThickness').value = floor.slabThickness;
            document.getElementById('floorHeight').value = floor.height;
        }

        function updateCurrentFloor() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;

            floor.dlSuper = parseFloat(document.getElementById('floorDL').value) || 2.0;
            floor.liveLoad = parseFloat(document.getElementById('floorLL').value) || 2.0;
            floor.slabThickness = parseFloat(document.getElementById('floorSlabThickness').value) || 150;
            floor.height = parseFloat(document.getElementById('floorHeight').value) || 3.0;

            calculate();
        }

        function addFloor() {
            const total = state.floors.length;
            // Insert before roof (last)
            const insertIndex = total > 0 && state.floors[total - 1].isRoof ? total - 1 : total;

            // Rename existing floors
            state.floors.forEach((f, i) => {
                if (i < insertIndex && !f.isRoof && f.id !== 'GF') {
                    // Keep as is
                }
            });

            const newFloor = {
                id: `${insertIndex + 1}F`,
                name: `${insertIndex + 1}${['st', 'nd', 'rd'][insertIndex - 1] || 'th'} Floor`,
                dlSuper: 2.0,
                liveLoad: 2.0,
                slabThickness: 150,
                height: 3.0,
                isRoof: false
            };

            state.floors.splice(insertIndex, 0, newFloor);

            // Update IDs for all floors
            state.floors.forEach((f, i) => {
                if (i === 0) {
                    f.id = 'GF';
                    f.name = 'Ground Floor';
                } else if (i === state.floors.length - 1 && f.isRoof) {
                    f.id = 'RF';
                    f.name = 'Roof';
                } else {
                    f.id = `${i + 1}F`;
                    f.name = `${i + 1}${['st', 'nd', 'rd'][i - 1] || 'th'} Floor`;
                }
            });

            renderFloorTabs();
            calculate();
        }

        function removeFloor() {
            if (state.floors.length <= 2) return; // Keep at least GF + RF

            // Remove the currently selected floor (unless it's GF or RF)
            const floor = state.floors[state.currentFloorIndex];
            if (floor.id === 'GF' || floor.isRoof) {
                // Can't remove GF or RF, remove the last typical floor instead
                const lastTypical = state.floors.findLastIndex(f => !f.isRoof && f.id !== 'GF');
                if (lastTypical > 0) {
                    state.floors.splice(lastTypical, 1);
                }
            } else {
                state.floors.splice(state.currentFloorIndex, 1);
            }

            // Clamp current floor index
            if (state.currentFloorIndex >= state.floors.length) {
                state.currentFloorIndex = state.floors.length - 1;
            }

            // Rename remaining floors
            state.floors.forEach((f, i) => {
                if (i === 0) {
                    f.id = 'GF';
                    f.name = 'Ground Floor';
                } else if (f.isRoof) {
                    f.id = 'RF';
                    f.name = 'Roof';
                } else {
                    f.id = `${i + 1}F`;
                    f.name = `${i + 1}${['st', 'nd', 'rd'][i - 1] || 'th'} Floor`;
                }
            });

            renderFloorTabs();
            calculate();
        }

        // ========== CORE CALCULATIONS ==========

        /**
         * Main calculation function
         * Implements: SLAB ‚Üí BEAMS ‚Üí COLUMNS load path
         * v2.3: Calculates per-floor and cumulative across all floors
         */
        function calculate() {
            // Clean spans to avoid zero/negative values
            state.xSpans = state.xSpans.map(span => sanitizeSpan(span));
            state.ySpans = state.ySpans.map(span => sanitizeSpan(span));

            // Step 1: Generate grid coordinates
            generateGrid();

            // Step 2: Generate slab panels (same for all floors)
            generateSlabs();

            // Reset cumulative column loads
            for (let col of state.columns) {
                col.loadPerFloor = 0;
                col.totalLoad = 0;
                col.floorLoads = [];
            }

            // v2.3: Calculate loads for each floor
            let totalPuSum = 0;
            for (let floor of state.floors) {
                // Calculate factored load for this floor
                const slabWeight = 24 * (floor.slabThickness / 1000); // kN/m¬≤ = kPa
                const pu = 1.2 * (floor.dlSuper + slabWeight) + 1.6 * floor.liveLoad;
                totalPuSum += pu;

                // Generate beams with this floor's pu
                generateBeams(pu);

                // Calculate beam reactions
                calculateBeamReactions();

                // Calculate column loads for this floor
                calculateColumnLoadsForFloor(floor.id);
            }

            // Average pu for display (or use current floor's pu)
            const currentFloor = state.floors[state.currentFloorIndex];
            const currentSlabWeight = 24 * (currentFloor.slabThickness / 1000);
            const puDisplay = 1.2 * (currentFloor.dlSuper + currentSlabWeight) + 1.6 * currentFloor.liveLoad;

            // Update UI
            updateResults(puDisplay);
            draw();
        }

        /**
         * Calculate column loads for a specific floor
         * Adds to cumulative totals
         */
        function calculateColumnLoadsForFloor(floorId) {
            for (let col of state.columns) {
                let floorLoad = 0;
                for (let beam of state.beams) {
                    if (beam.startCol === col.id) floorLoad += beam.Rleft;
                    if (beam.endCol === col.id) floorLoad += beam.Rright;
                }
                col.floorLoads.push({ floorId, load: floorLoad });
                col.totalLoad += floorLoad;
                col.loadPerFloor = floorLoad; // Last floor's load for current display
            }
        }

        /**
         * Step 1: Generate grid from spans
         * Creates absolute coordinates for column positions
         */
        function generateGrid() {
            // Build X coordinates
            const xCoords = [0];
            for (let span of state.xSpans) {
                xCoords.push(xCoords[xCoords.length - 1] + span);
            }

            // Build Y coordinates
            const yCoords = [0];
            for (let span of state.ySpans) {
                yCoords.push(yCoords[yCoords.length - 1] + span);
            }

            // Generate columns at intersections
            state.columns = [];
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Skip I and O

            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < xCoords.length; xi++) {
                    const id = `${letters[xi]}${yi + 1}`;

                    // Determine column type
                    const isCorner = (xi === 0 || xi === xCoords.length - 1) &&
                        (yi === 0 || yi === yCoords.length - 1);
                    const isEdge = !isCorner && (xi === 0 || xi === xCoords.length - 1 ||
                        yi === 0 || yi === yCoords.length - 1);

                    let type = 'interior';
                    if (isCorner) type = 'corner';
                    else if (isEdge) type = 'edge';

                    state.columns.push({
                        id,
                        x: xCoords[xi],
                        y: yCoords[yi],
                        xi, yi,
                        type,
                        loadPerFloor: 0,
                        totalLoad: 0,
                        connectedBeams: [] // Will store beam IDs
                    });
                }
            }
        }

        /**
         * Step 2: Generate slab panels
         */
        function generateSlabs() {
            state.slabs = [];
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            for (let yi = 0; yi < state.ySpans.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    const lx = state.xSpans[xi]; // Short span
                    const ly = state.ySpans[yi]; // Long span

                    // Check if 2-way (ratio < 2)
                    const ratio = Math.max(lx, ly) / Math.min(lx, ly);
                    const isTwoWay = ratio < 2;

                    state.slabs.push({
                        id: `S${yi * state.xSpans.length + xi + 1}`,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi + 1],
                        y2: yCoords[yi + 1],
                        lx, ly,
                        area: lx * ly,
                        isTwoWay,
                        xi, yi
                    });
                }
            }
        }

        /**
         * Step 3 & 4: Generate beams and calculate tributary widths
         * v2.2: Now creates slices per slab with proper 45¬∞ math
         * Short span direction gets MORE load (stiffer)
         */
        function generateBeams(pu) {
            state.beams = [];

            // X-direction beams (horizontal, span in X)
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            // Create beam objects with slices array
            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    const beamSpan = state.xSpans[xi];
                    const beamId = `BX-${yi + 1}-${xi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'X',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi + 1],
                        y2: yCoords[yi],
                        span: beamSpan,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],  // v2.2: per-slab slices
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // Y-direction beams (along gridlines in X direction)
            for (let xi = 0; xi < xCoords.length; xi++) {
                for (let yi = 0; yi < state.ySpans.length; yi++) {
                    const beamSpan = state.ySpans[yi];
                    const beamId = `BY-${xi + 1}-${yi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'Y',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi],
                        y2: yCoords[yi + 1],
                        span: beamSpan,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],  // v2.2: per-slab slices
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // Map for quick access
            const beamMap = Object.fromEntries(state.beams.map(beam => [beam.id, beam]));

            // v2.2: Distribute slab areas with proper slices
            for (let slab of state.slabs) {
                const topBeamId = `BX-${slab.yi + 1}-${slab.xi + 1}`;
                const bottomBeamId = `BX-${slab.yi + 2}-${slab.xi + 1}`;
                const leftBeamId = `BY-${slab.xi + 1}-${slab.yi + 1}`;
                const rightBeamId = `BY-${slab.xi + 2}-${slab.yi + 1}`;

                // Slab coordinates
                const x0 = slab.x1, x1 = slab.x2;
                const y0 = slab.y1, y1 = slab.y2;
                const cx_mid = (x0 + x1) / 2;
                const cy_mid = (y0 + y1) / 2;

                // Helper to create polygon and compute centroid
                function makeSlice(beamId, side, areaSide, poly) {
                    const beam = beamMap[beamId];
                    if (!beam) return;

                    const tribWidth = areaSide / beam.span;
                    const w = pu * tribWidth;

                    // Compute centroid for label placement
                    let cx = 0, cy = 0;
                    for (let pt of poly) { cx += pt.x; cy += pt.y; }
                    cx /= poly.length;
                    cy /= poly.length;

                    beam.tributaryArea += areaSide;
                    beam.slices.push({
                        slabId: slab.id,
                        side: side,
                        area: areaSide,
                        w: w,
                        poly: poly,
                        cx: cx,
                        cy: cy
                    });
                }

                if (slab.isTwoWay) {
                    const h = Math.min(slab.lx, slab.ly) / 2;  // 45¬∞ inset height

                    // Provisional areas based on 45¬∞ triangular/trapezoidal geometry
                    const xSideArea_raw = slab.lx * h / 2; // triangle for X-beams (top/bottom)
                    const trapBase = slab.ly;
                    const trapTop = slab.ly - 2 * h;
                    const ySideArea_raw = trapTop > 0
                        ? (trapBase + trapTop) * h / 2  // trapezoid for Y-beams
                        : slab.ly * h / 2;              // triangle when lines meet

                    // Normalize so total = slab.area
                    const rawTotal = 2 * xSideArea_raw + 2 * ySideArea_raw;
                    const scale = rawTotal > 0 ? slab.area / rawTotal : 0;

                    const A_top = xSideArea_raw * scale;
                    const A_bottom = xSideArea_raw * scale;
                    const A_left = ySideArea_raw * scale;
                    const A_right = ySideArea_raw * scale;

                    // v2.2.1: Proper 45¬∞ polygon visualization
                    // Short span beams get triangles, long span beams get trapezoids
                    let topPoly, bottomPoly, leftPoly, rightPoly;

                    if (slab.lx <= slab.ly) {
                        // Short direction = X, so X-beams (top/bottom) get triangles
                        // Y-beams (left/right) get trapezoids

                        // Top triangle: base at y0, apex at y0 + h
                        topPoly = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: x1 - h, y: y0 + h },
                            { x: x0 + h, y: y0 + h }
                        ];
                        // But wait - this is a trapezoid. For triangle, both ends meet at center
                        // Actually triangle: corners to center point offset by h
                        topPoly = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: (x0 + x1) / 2, y: y0 + h }  // apex at midpoint, h down
                        ];

                        // Bottom triangle: base at y1, apex at y1 - h
                        bottomPoly = [
                            { x: x0, y: y1 },
                            { x: x1, y: y1 },
                            { x: (x0 + x1) / 2, y: y1 - h }
                        ];

                        // Left trapezoid: base ly, top ly - 2h
                        leftPoly = [
                            { x: x0, y: y0 },
                            { x: x0, y: y1 },
                            { x: x0 + h, y: y1 - h },
                            { x: x0 + h, y: y0 + h }
                        ];

                        // Right trapezoid
                        rightPoly = [
                            { x: x1, y: y0 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: y1 - h },
                            { x: x1 - h, y: y0 + h }
                        ];
                    } else {
                        // Short direction = Y, so Y-beams (left/right) get triangles
                        // X-beams (top/bottom) get trapezoids

                        // Left triangle: base at x0, apex at x0 + h
                        leftPoly = [
                            { x: x0, y: y0 },
                            { x: x0, y: y1 },
                            { x: x0 + h, y: (y0 + y1) / 2 }
                        ];

                        // Right triangle
                        rightPoly = [
                            { x: x1, y: y0 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: (y0 + y1) / 2 }
                        ];

                        // Top trapezoid: base lx, top lx - 2h
                        topPoly = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: x1 - h, y: y0 + h },
                            { x: x0 + h, y: y0 + h }
                        ];

                        // Bottom trapezoid
                        bottomPoly = [
                            { x: x0, y: y1 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: y1 - h },
                            { x: x0 + h, y: y1 - h }
                        ];
                    }

                    // Add slices with correct areas (NOT equal!)
                    makeSlice(topBeamId, 'top', A_top, topPoly);
                    makeSlice(bottomBeamId, 'bottom', A_bottom, bottomPoly);
                    makeSlice(leftBeamId, 'left', A_left, leftPoly);
                    makeSlice(rightBeamId, 'right', A_right, rightPoly);
                } else {
                    // One-way slab: split into 2 rectangles
                    const halfArea = slab.area / 2;

                    if (slab.lx < slab.ly) {
                        // Spanning in Y, supported by left/right beams
                        const midX = (x0 + x1) / 2;
                        const leftPoly = [{ x: x0, y: y0 }, { x: midX, y: y0 }, { x: midX, y: y1 }, { x: x0, y: y1 }];
                        const rightPoly = [{ x: midX, y: y0 }, { x: x1, y: y0 }, { x: x1, y: y1 }, { x: midX, y: y1 }];
                        makeSlice(leftBeamId, 'left', halfArea, leftPoly);
                        makeSlice(rightBeamId, 'right', halfArea, rightPoly);
                    } else {
                        // Spanning in X, supported by top/bottom beams
                        const midY = (y0 + y1) / 2;
                        const topPoly = [{ x: x0, y: y0 }, { x: x1, y: y0 }, { x: x1, y: midY }, { x: x0, y: midY }];
                        const bottomPoly = [{ x: x0, y: midY }, { x: x1, y: midY }, { x: x1, y: y1 }, { x: x0, y: y1 }];
                        makeSlice(topBeamId, 'top', halfArea, topPoly);
                        makeSlice(bottomBeamId, 'bottom', halfArea, bottomPoly);
                    }
                }
            }

            // Finalize tributary widths and loads
            for (let beam of state.beams) {
                beam.tributaryWidth = beam.span > 0 ? beam.tributaryArea / beam.span : 0;
                beam.w = pu * beam.tributaryWidth;
            }
        }

        /**
         * Step 5: Calculate beam reactions
         * For uniform load: R_left = R_right = w * L / 2
         */
        function calculateBeamReactions() {
            for (let beam of state.beams) {
                // Simply supported beam with uniform load
                // R = w * L / 2
                beam.Rleft = beam.w * beam.span / 2;
                beam.Rright = beam.w * beam.span / 2;
            }
        }

        /**
         * Step 6: Calculate column loads
         * Column load = Sum of all beam reactions at that column
         */
        function calculateColumnLoads() {
            // Reset column loads
            for (let col of state.columns) {
                col.loadPerFloor = 0;
                col.connectedBeams = [];
            }

            // Sum beam reactions to columns
            for (let beam of state.beams) {
                // Find columns at beam ends
                let colLeft, colRight;

                if (beam.direction === 'X') {
                    // X beam: connects columns at same yi, adjacent xi
                    colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                    colRight = state.columns.find(c => c.xi === beam.xi + 1 && c.yi === beam.yi);
                } else {
                    // Y beam: connects columns at same xi, adjacent yi
                    colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                    colRight = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi + 1);
                }

                if (colLeft) {
                    colLeft.loadPerFloor += beam.Rleft;
                    colLeft.connectedBeams.push(beam.id);
                }
                if (colRight) {
                    colRight.loadPerFloor += beam.Rright;
                    colRight.connectedBeams.push(beam.id);
                }
            }

            // Calculate total load (sum across floors, not multiply!)
            for (let col of state.columns) {
                // Each floor has same load pattern
                col.totalLoad = col.loadPerFloor * state.numFloors;
            }
        }

        // ========== UI UPDATES ==========
        function updateResults(pu) {
            // Total area
            const totalArea = state.slabs.reduce((sum, s) => sum + s.area, 0);
            document.getElementById('totalArea').textContent = totalArea.toFixed(1);

            // Beam tributary area check
            const totalBeamArea = state.beams.reduce((sum, b) => sum + b.tributaryArea, 0);
            const areaBalance = totalArea > 0 ? (totalBeamArea / totalArea) * 100 : 0;
            const areaDelta = totalBeamArea - totalArea;
            const balanceEl = document.getElementById('areaBalance');
            const balanceDetailEl = document.getElementById('areaBalanceDetail');
            balanceEl.textContent = `${areaBalance.toFixed(1)}%`;
            balanceEl.style.color = Math.abs(areaDelta) < 0.01 ? 'var(--success)' : 'var(--warning)';
            balanceDetailEl.textContent = `${areaDelta.toFixed(2)} m¬≤ diff`;

            // Factored load
            document.getElementById('factoredLoad').textContent = pu.toFixed(2);

            // Total per floor (use current selected floor)
            const currentFloor = state.floors[state.currentFloorIndex];
            const totalPerFloor = state.columns.reduce((sum, c) => {
                const floorLoad = c.floorLoads.find(f => f.floorId === currentFloor.id);
                return sum + (floorLoad ? floorLoad.load : 0);
            }, 0);
            document.getElementById('totalPerFloor').textContent = totalPerFloor.toFixed(0);

            // Max column (total across all floors)
            const maxCol = state.columns.length
                ? Math.max(...state.columns.map(c => c.totalLoad))
                : 0;
            document.getElementById('maxColumn').textContent = maxCol.toFixed(0);

            // Column table - show current floor load AND total
            const colBody = document.getElementById('columnResultsBody');
            colBody.innerHTML = state.columns.map(col => {
                const floorLoad = col.floorLoads.find(f => f.floorId === currentFloor.id);
                const thisFloor = floorLoad ? floorLoad.load : 0;
                return `
                <tr>
                    <td><strong>${col.id}</strong></td>
                    <td style="color:${col.type === 'corner' ? '#f59e0b' : col.type === 'edge' ? '#00d4ff' : '#10b981'}">${col.type}</td>
                    <td>${thisFloor.toFixed(1)}</td>
                    <td><strong>${col.totalLoad.toFixed(1)}</strong></td>
                </tr>
            `;
            }).join('');

            // Beam table
            const beamBody = document.getElementById('beamResultsBody');
            beamBody.innerHTML = state.beams.slice(0, 20).map(beam => `
                <tr>
                    <td>${beam.id}</td>
                    <td>${beam.w.toFixed(1)}</td>
                    <td>${beam.Rleft.toFixed(1)}</td>
                </tr>
            `).join('');
        }

        // ========== DRAWING ==========
        function draw() {
            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // Draw slabs (filled)
            for (let slab of state.slabs) {
                const x1 = slab.x1 * state.scale + state.offsetX;
                const y1 = slab.y1 * state.scale + state.offsetY;
                const w = slab.lx * state.scale;
                const h = slab.ly * state.scale;

                ctx.fillStyle = 'rgba(0, 212, 255, 0.1)';
                ctx.fillRect(x1, y1, w, h);
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.3)';
                ctx.strokeRect(x1, y1, w, h);
            }

            // v2.2: Draw slice polygons when Areas is ON
            if (state.showAreas) {
                for (let beam of state.beams) {
                    for (let slice of beam.slices) {
                        // Draw polygon
                        ctx.beginPath();
                        const firstPt = slice.poly[0];
                        ctx.moveTo(
                            firstPt.x * state.scale + state.offsetX,
                            firstPt.y * state.scale + state.offsetY
                        );
                        for (let i = 1; i < slice.poly.length; i++) {
                            const pt = slice.poly[i];
                            ctx.lineTo(
                                pt.x * state.scale + state.offsetX,
                                pt.y * state.scale + state.offsetY
                            );
                        }
                        ctx.closePath();

                        // Color by beam direction
                        const isXBeam = beam.direction === 'X';
                        ctx.fillStyle = isXBeam ? 'rgba(124, 58, 237, 0.25)' : 'rgba(16, 185, 129, 0.25)';
                        ctx.fill();
                        ctx.strokeStyle = isXBeam ? 'rgba(124, 58, 237, 0.6)' : 'rgba(16, 185, 129, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Centroid marker and label
                        const cx = slice.cx * state.scale + state.offsetX;
                        const cy = slice.cy * state.scale + state.offsetY;

                        // White dot at centroid
                        ctx.beginPath();
                        ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();

                        // Label at centroid
                        if (state.showLabels) {
                            ctx.fillStyle = 'rgba(0,0,0,0.75)';
                            ctx.fillRect(cx - 32, cy - 18, 64, 22);
                            ctx.fillStyle = '#00d4ff';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(`A=${slice.area.toFixed(1)}m¬≤`, cx, cy - 6);
                            ctx.fillStyle = '#f59e0b';
                            ctx.fillText(`w=${slice.w.toFixed(1)}kN/m`, cx, cy + 6);
                        }
                    }
                }
            }

            // Draw beams
            ctx.lineWidth = 3;
            for (let beam of state.beams) {
                const x1 = beam.x1 * state.scale + state.offsetX;
                const y1 = beam.y1 * state.scale + state.offsetY;
                const x2 = beam.x2 * state.scale + state.offsetX;
                const y2 = beam.y2 * state.scale + state.offsetY;

                ctx.strokeStyle = beam.direction === 'X' ? '#7c3aed' : '#10b981';
                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();
            }

            // Draw columns
            for (let col of state.columns) {
                const x = col.x * state.scale + state.offsetX;
                const y = col.y * state.scale + state.offsetY;
                const size = 12;

                // Color by type
                let color = '#10b981'; // Interior
                if (col.type === 'corner') color = '#f59e0b';
                else if (col.type === 'edge') color = '#00d4ff';

                ctx.fillStyle = color;
                ctx.fillRect(x - size / 2, y - size / 2, size, size);

                // Label
                if (state.showLabels) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(col.id, x, y - 12);
                    ctx.fillStyle = '#8b949e';
                    ctx.font = '9px sans-serif';
                    ctx.fillText(`${col.loadPerFloor.toFixed(0)} kN`, x, y + 20);
                }
            }
        }

        // ========== CONTROLS ==========
        function zoomIn() {
            state.scale *= 1.2;
            draw();
        }

        function zoomOut() {
            state.scale /= 1.2;
            draw();
        }

        function fitView() {
            if (state.columns.length === 0) return;

            const maxX = Math.max(...state.columns.map(c => c.x));
            const maxY = Math.max(...state.columns.map(c => c.y));

            const margin = 150;
            const scaleX = (canvas.width - margin * 2) / maxX;
            const scaleY = (canvas.height - margin * 2) / maxY;
            state.scale = Math.min(scaleX, scaleY, 80);

            state.offsetX = (canvas.width - maxX * state.scale) / 2;
            state.offsetY = (canvas.height - maxY * state.scale) / 2;

            draw();
        }

        function toggleLabels() {
            state.showLabels = !state.showLabels;
            document.getElementById('toggleLabels').classList.toggle('active', state.showLabels);
            draw();
        }

        // v2.2: Toggle Areas visualization
        function toggleAreas() {
            state.showAreas = !state.showAreas;
            const btn = document.getElementById('toggleAreas');
            if (btn) btn.classList.toggle('active', state.showAreas);
            draw();
        }

        function exportResults() {
            const data = {
                parameters: {
                    xSpans: state.xSpans,
                    ySpans: state.ySpans,
                    dlSuper: state.dlSuper,
                    liveLoad: state.liveLoad,
                    slabThickness: state.slabThickness,
                    numFloors: state.numFloors
                },
                columns: state.columns.map(c => ({
                    id: c.id,
                    type: c.type,
                    loadPerFloor: c.loadPerFloor,
                    totalLoad: c.totalLoad
                })),
                beams: state.beams.map(b => ({
                    id: b.id,
                    w: b.w,
                    R: b.Rleft
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tributary_pro_v2_results.json';
            a.click();
        }

        // ========== INIT ==========
        window.onload = function () {
            initCanvas();
            renderSpans();
            renderFloorTabs();  // v2.3: Render floor tabs
            calculate();
            fitView();
        };
    </script>
</body>

</html>