<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tributary Pro v3.0 | Structural Load Analysis</title>
    <style>
        /* ========== GOOGLE FONTS ========== */
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=Outfit:wght@400;500;600;700&display=swap');

        /* ========== RESET & VARIABLES ========== */
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        /* DARK THEME (Default) */
        :root,
        [data-theme="dark"] {
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
            --primary: #00d4ff;
            --secondary: #7c3aed;
            --dark-bg: #0d1117;
            --panel-bg: #161b22;
            --surface: #1a1f2e;
            --glass: rgba(255, 255, 255, 0.05);
            --glass-darker: rgba(255, 255, 255, 0.03);
            --border: rgba(255, 255, 255, 0.1);
            --text-primary: #e6edf3;
            --text-muted: #8b949e;
            --success: #10b981;
            --warning: #f59e0b;
            --danger: #ef4444;
            --canvas-bg: #0a0d10;
            --header-bg: rgba(0, 0, 0, 0.5);
            --input-bg: rgba(255, 255, 255, 0.05);
        }

        /* LIGHT THEME (Clean Professional) - WCAG Compliant High Contrast */
        [data-theme="light"] {
            --font-main: 'Outfit', system-ui, -apple-system, sans-serif;
            --primary: #1d4ed8;
            --secondary: #7c3aed;
            --dark-bg: #f8fafc;
            --panel-bg: #ffffff;
            --surface: #f1f5f9;
            --glass: rgba(15, 23, 42, 0.03);
            --glass-darker: rgba(15, 23, 42, 0.06);
            --border: #e2e8f0;
            --text-primary: #0f172a;
            --text-muted: #475569;
            --success: #16a34a;
            --warning: #ca8a04;
            --danger: #dc2626;
            --canvas-bg: #f8fafc;
            --header-bg: #ffffff;
            --input-bg: #f1f5f9;
            /* High contrast button colors */
            --btn-text: #1e293b;
            --btn-border: #cbd5e1;
            --btn-hover: #1d4ed8;
        }

        /* PAPER MATTE THEME (Engineering - Monochrome) */
        [data-theme="blueprint"] {
            --font-main: 'Inter', system-ui, -apple-system, sans-serif;
            --primary: #000000;
            /* Black */
            --secondary: #333333;
            /* Dark Gray */
            --dark-bg: #f5f5f0;
            /* Off-White Paper */
            --panel-bg: #f5f5f0;
            /* Off-White Panels */
            --surface: #ffffff;
            /* White surface */
            --glass: rgba(0, 0, 0, 0.03);
            --glass-darker: rgba(0, 0, 0, 0.05);
            --border: rgba(0, 0, 0, 0.2);
            /* Black borders */
            --text-primary: #000000;
            /* Black text */
            --text-muted: #666666;
            /* Gray muted */
            --success: #333333;
            /* Dark Gray (was green) */
            --warning: #333333;
            /* Dark Gray (was orange) */
            --danger: #333333;
            /* Dark Gray (was red) */
            --canvas-bg: #f5f5f0;
            /* Off-White canvas */
            --header-bg: #f5f5f0;
            /* Off-White header */
            --input-bg: transparent;
        }

        /* Paper Matte Button Overrides */
        [data-theme="blueprint"] .tool-btn,
        [data-theme="blueprint"] .action-btn,
        [data-theme="blueprint"] .view-btn,
        [data-theme="blueprint"] .plan-tab,
        [data-theme="blueprint"] .floor-tab,
        [data-theme="blueprint"] .layer-btn,
        [data-theme="blueprint"] .add-span-btn {
            background: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
            text-transform: uppercase;
            font-weight: 500;
        }

        [data-theme="blueprint"] .tool-btn:hover,
        [data-theme="blueprint"] .action-btn:hover,
        [data-theme="blueprint"] .view-btn:hover {
            background: #f0f0f0 !important;
            color: #000000 !important;
        }

        [data-theme="blueprint"] .tool-btn.active,
        [data-theme="blueprint"] .action-btn.active,
        [data-theme="blueprint"] .view-btn.active,
        [data-theme="blueprint"] .plan-tab.active,
        [data-theme="blueprint"] .floor-tab.active,
        [data-theme="blueprint"] .layer-btn.active {
            background: #e8eef4 !important;
            /* Pastel Gray-Blue */
            color: #1e3a5f !important;
            /* Navy Blue text */
            border-color: #1e3a5f !important;
            /* Navy Blue border */
            font-weight: 600 !important;
        }

        /* Paper Matte - Strip ALL Remaining Colors */
        /* Remove span buttons (red X) - make black */
        [data-theme="blueprint"] .remove-span-btn,
        [data-theme="blueprint"] .remove-floor-btn,
        [data-theme="blueprint"] button[onclick*="removeSpan"],
        [data-theme="blueprint"] button[onclick*="removeFloor"] {
            background: transparent !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
        }

        /* Checkboxes - black accent */
        [data-theme="blueprint"] input[type="checkbox"] {
            accent-color: #000000 !important;
        }

        /* All labels and headings - UPPERCASE + Black */
        [data-theme="blueprint"] .panel-header,
        [data-theme="blueprint"] h3,
        [data-theme="blueprint"] .param-group h3,
        [data-theme="blueprint"] .result-label,
        [data-theme="blueprint"] label,
        [data-theme="blueprint"] .settings-label,
        [data-theme="blueprint"] .settings-header span {
            text-transform: uppercase !important;
            color: #000000 !important;
        }

        /* Theme toggle buttons */
        [data-theme="blueprint"] .theme-option {
            background: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
            text-transform: uppercase !important;
        }

        [data-theme="blueprint"] .theme-option.active {
            background: #000000 !important;
            color: #ffffff !important;
        }

        /* Badges - monochrome */
        [data-theme="blueprint"] .typical-badge,
        [data-theme="blueprint"] [class*="badge"] {
            background: #333333 !important;
            color: #ffffff !important;
            border: none !important;
        }

        /* Info icons - black/gray */
        [data-theme="blueprint"] .info-icon,
        [data-theme="blueprint"] [class*="info"] {
            color: #666666 !important;
        }

        /* Footer - white bg, black text */
        [data-theme="blueprint"] footer,
        [data-theme="blueprint"] .footer {
            background: #f5f5f0 !important;
            color: #000000 !important;
        }

        /* AI Button - hide or make monochrome */
        [data-theme="blueprint"] .ai-fab,
        [data-theme="blueprint"] .ai-button,
        [data-theme="blueprint"] [class*="ai-"] {
            background: #000000 !important;
            color: #ffffff !important;
        }

        /* Load Summary and Result Cards - white bg */
        [data-theme="blueprint"] .load-summary,
        [data-theme="blueprint"] .result-card,
        [data-theme="blueprint"] .result-box,
        [data-theme="blueprint"] [class*="result"] {
            background: #ffffff !important;
            border: 1px solid #000000 !important;
            color: #000000 !important;
        }

        /* Status labels (corner/edge) - black text */
        [data-theme="blueprint"] .column-type,
        [data-theme="blueprint"] [class*="type-"],
        [data-theme="blueprint"] [class*="status"] {
            color: #000000 !important;
            background: transparent !important;
        }

        /* Input fields - white bg, black border */
        [data-theme="blueprint"] input,
        [data-theme="blueprint"] select,
        [data-theme="blueprint"] textarea {
            background: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
        }

        /* Panel background - off-white */
        [data-theme="blueprint"] .panel,
        [data-theme="blueprint"] .results-panel {
            background: #f5f5f0 !important;
        }

        /* Override any remaining colored gradients */
        [data-theme="blueprint"] [style*="gradient"],
        [data-theme="blueprint"] [style*="background:"] {
            --any-color-override: inherit;
        }

        /* Paper Matte - Override ALL inline styles with colors */
        [data-theme="blueprint"] *[style*="color:"],
        [data-theme="blueprint"] *[style*="background"] {
            color: #000000 !important;
            background: transparent !important;
        }

        /* Grand Total highlight - white bg */
        [data-theme="blueprint"] .grand-total,
        [data-theme="blueprint"] .total-value,
        [data-theme="blueprint"] [class*="grand"],
        [data-theme="blueprint"] [class*="total"] {
            background: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
        }

        /* Summary cards - white bg, black text */
        [data-theme="blueprint"] .summary-card,
        [data-theme="blueprint"] .summary-grid .value,
        [data-theme="blueprint"] .summary-grid .label {
            background: #ffffff !important;
            color: #000000 !important;
        }

        /* AI Fab button - make black or hide */
        [data-theme="blueprint"] #ai-fab,
        [data-theme="blueprint"] .ai-fab,
        [data-theme="blueprint"] .ethos-button,
        [data-theme="blueprint"] [id*="ethos"],
        [data-theme="blueprint"] [class*="ethos"] {
            background: #000000 !important;
            color: #ffffff !important;
            border: 1px solid #000000 !important;
        }

        /* Footer - white bg, black text */
        [data-theme="blueprint"] .status-bar,
        [data-theme="blueprint"] [class*="footer"],
        [data-theme="blueprint"] .credits {
            background: #f5f5f0 !important;
            color: #000000 !important;
        }

        [data-theme="blueprint"] .status-bar a,
        [data-theme="blueprint"] .credits a {
            color: #000000 !important;
            text-decoration: underline !important;
        }

        /* Column type labels - black text */
        [data-theme="blueprint"] .col-type,
        [data-theme="blueprint"] td span[style*="color"] {
            color: #000000 !important;
        }

        /* Override ALL span colors in results */
        [data-theme="blueprint"] .results td span,
        [data-theme="blueprint"] .column-table span {
            color: #000000 !important;
        }

        /* Paper Matte - Remove ALL gray/black backgrounds from toolbars */
        [data-theme="blueprint"] .plan-tabs,
        [data-theme="blueprint"] .view-toggle,
        [data-theme="blueprint"] .layer-toggles,
        [data-theme="blueprint"] .canvas-toolbar {
            background: transparent !important;
        }

        /* Paper Matte - Remove gray backgrounds from param groups and span inputs */
        [data-theme="blueprint"] .param-group,
        [data-theme="blueprint"] .span-inputs,
        [data-theme="blueprint"] .floor-group,
        [data-theme="blueprint"] .span-input,
        [data-theme="blueprint"] .cantilever-span-input,
        [data-theme="blueprint"] [class*="span-"] {
            background: transparent !important;
        }

        /* Paper Matte - Make layer buttons and plan tabs have just black border */
        [data-theme="blueprint"] .layer-btn,
        [data-theme="blueprint"] .plan-tab,
        [data-theme="blueprint"] .view-btn {
            background: #ffffff !important;
            color: #000000 !important;
            border: 1px solid #000000 !important;
            text-transform: uppercase !important;
        }

        /* Paper Matte - Canvas Grid Mesh Background (50cm x 50cm pattern) */
        /* Animated Gradient for "passing lights" effect */
        [data-theme="blueprint"] .canvas-wrapper,
        [data-theme="blueprint"] #mainCanvas {
            background-color: #e2e8f0 !important;
            /* Slightly darker white (Slate-200) */
            position: relative;
            overflow: hidden;
            /* Contain the animation */
        }

        /* Subtle "passing lights" animation */
        [data-theme="blueprint"] .canvas-wrapper::before {
            content: "";
            position: absolute;
            top: 0;
            left: -100%;
            width: 200%;
            height: 100%;
            background: linear-gradient(90deg,
                    transparent 30%,
                    rgba(255, 255, 255, 0.6) 50%,
                    transparent 70%);
            transform: skewX(-20deg);
            animation: lightSweep 12s infinite linear;
            pointer-events: none;
            z-index: 0;
            /* Behind canvas (since canvas is transparent) */
        }

        @keyframes lightSweep {
            0% {
                transform: translateX(-50%) skewX(-20deg);
            }

            100% {
                transform: translateX(50%) skewX(-20deg);
            }
        }

        /* Dropdown Menu Styles */
        .settings-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 6px;
            padding: 8px;
            min-width: 180px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
            z-index: 2000;
            display: flex;
            flex-direction: column;
            gap: 4px;
        }

        .settings-dropdown.hidden {
            display: none;
        }

        [data-theme="blueprint"] .settings-dropdown {
            background: #ffffff !important;
            border: 1px solid #000000 !important;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.1);
        }

        .menu-item-header {
            font-size: 0.65rem;
            color: var(--text-muted);
            margin: 4px 0 2px 4px;
            font-weight: 600;
        }

        [data-theme="blueprint"] .menu-item-header {
            color: #888;
            text-transform: uppercase;
        }

        .menu-item {
            background: transparent;
            border: none;
            color: var(--text-primary);
            padding: 8px 12px;
            text-align: left;
            cursor: pointer;
            border-radius: 4px;
            font-size: 0.85rem;
        }

        .menu-item:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        [data-theme="blueprint"] .menu-item {
            color: #000000 !important;
            font-weight: 500;
        }

        [data-theme="blueprint"] .menu-item:hover {
            background: #f0f0f0 !important;
        }

        /* Paper Matte - Uniform font size */
        [data-theme="blueprint"] .panel,
        [data-theme="blueprint"] .results-panel,
        [data-theme="blueprint"] label,
        [data-theme="blueprint"] input,
        [data-theme="blueprint"] button,
        [data-theme="blueprint"] .tool-btn,
        [data-theme="blueprint"] .layer-btn,
        [data-theme="blueprint"] .plan-tab {
            font-size: 0.75rem !important;
        }


        body {
            font-family: var(--font-main);
            background: linear-gradient(135deg, var(--dark-bg) 0%, var(--surface) 50%, var(--dark-bg) 100%);
            min-height: 100vh;
            color: var(--text-primary);
            overflow-x: hidden;
            font-size: 14px;
        }

        /* Scrollbar styles for dark theme */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }

        ::-webkit-scrollbar-track {
            background: var(--panel-bg);
        }

        ::-webkit-scrollbar-thumb {
            background: rgba(255, 255, 255, 0.15);
            border-radius: 4px;
        }

        ::-webkit-scrollbar-thumb:hover {
            background: rgba(255, 255, 255, 0.25);
        }

        /* ========== HEADER ========== */
        .header {
            background: var(--header-bg);
            backdrop-filter: blur(10px);
            border-bottom: 1px solid var(--border);
            padding: 8px 16px;
            height: 60px;
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-wrap: nowrap;
            gap: 16px;
            position: sticky;
            top: 0;
            z-index: 100;
            overflow-x: auto;
            white-space: nowrap;
        }

        .logo {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .logo-icon {
            width: 36px;
            height: 36px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-radius: 8px;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 18px;
        }

        .logo h1 {
            font-size: 1.2rem;
            font-weight: 600;
        }

        .logo h1 span {
            color: var(--primary);
        }

        .version-badge {
            background: var(--secondary);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-size: 0.65rem;
            font-weight: 600;
            margin-left: 8px;
        }

        .header-actions {
            display: flex;
            align-items: center;
            gap: 8px;
            flex-wrap: nowrap;
        }

        /* ========== SETTINGS PANEL ========== */
        .settings-panel {
            position: absolute;
            top: 70px;
            right: 20px;
            background: var(--panel-bg);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 16px;
            z-index: 200;
            min-width: 220px;
            box-shadow: 0 4px 20px rgba(0, 0, 0, 0.3);
        }

        .settings-panel.hidden {
            display: none;
        }

        .settings-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 16px;
            font-weight: 600;
            font-size: 0.9rem;
            color: var(--text-primary);
        }

        .settings-close {
            background: none;
            border: none;
            color: var(--text-muted);
            cursor: pointer;
            font-size: 1rem;
            padding: 4px;
        }

        .settings-close:hover {
            color: var(--text-primary);
        }

        .settings-section {
            margin-bottom: 12px;
        }

        .settings-label {
            font-size: 0.7rem;
            color: var(--text-muted);
            text-transform: uppercase;
            letter-spacing: 0.5px;
            margin-bottom: 8px;
        }

        .theme-toggle-group {
            display: flex;
            gap: 8px;
        }

        .theme-option {
            flex: 1;
            padding: 10px 12px;
            background: var(--surface);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-muted);
            font-size: 0.75rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .theme-option:hover {
            background: var(--glass);
            color: var(--text-primary);
        }

        .theme-option.active {
            background: var(--primary);
            color: white;
            border-color: var(--primary);
        }

        .settings-gear {
            font-size: 1rem;
        }

        /* ========== MAIN LAYOUT ========== */
        .app-container {
            display: grid;
            grid-template-columns: 300px 1fr 320px;
            height: calc(100vh - 60px);
        }

        .panel {
            background: var(--glass);
            border-right: 1px solid var(--border);
            padding: 16px;
            overflow-y: auto;
        }

        .panel:last-child {
            border-right: none;
            border-left: 1px solid var(--border);
        }

        .panel-header {
            font-size: 0.75rem;
            text-transform: uppercase;
            letter-spacing: 1px;
            color: #8b949e;
            margin-bottom: 16px;
            padding-bottom: 8px;
            border-bottom: 1px solid var(--border);
        }

        /* ========== INPUT GROUPS ========== */
        .param-group {
            background: rgba(0, 0, 0, 0.2);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 12px;
        }

        .param-group h3 {
            font-size: 0.8rem;
            color: var(--primary);
            margin-bottom: 10px;
        }

        .param-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .param-item {
            background: rgba(0, 0, 0, 0.3);
            padding: 10px;
            border-radius: 8px;
        }

        .param-item label {
            display: block;
            font-size: 0.7rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .param-item input,
        .param-item select {
            width: 100%;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .param-item input:focus {
            outline: none;
            border-color: var(--primary);
        }

        /* ========== SPAN INPUTS ========== */
        .span-container {
            margin-bottom: 12px;
        }

        .span-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .span-header h4 {
            font-size: 0.75rem;
            color: #8b949e;
        }

        .add-span-btn {
            background: var(--primary);
            color: #000;
            border: none;
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 0.7rem;
            cursor: pointer;
        }

        .span-row {
            display: flex;
            gap: 8px;
            margin-bottom: 6px;
            align-items: center;
        }

        .span-row input {
            flex: 1;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 8px;
            color: #fff;
            font-size: 0.85rem;
        }

        .span-row .remove-btn {
            background: rgba(255, 100, 100, 0.3);
            color: #ff6b6b;
            border: none;
            width: 24px;
            height: 24px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
        }

        /* ========== CANVAS AREA ========== */
        .canvas-container {
            display: flex;
            flex-direction: column;
            background: var(--darker);
        }

        .canvas-toolbar {
            display: flex;
            gap: 8px;
            padding: 8px 12px;
            background: rgba(0, 0, 0, 0.3);
            border-bottom: 1px solid var(--border);
            flex-wrap: wrap;
        }

        .tool-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 20px;
            color: #8b949e;
            font-size: 0.75rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .tool-btn:hover {
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
        }

        /* v3.0 FIX: Light theme button visibility */
        [data-theme="light"] .tool-btn {
            color: #1e293b;
            border-color: #94a3b8;
            font-weight: 500;
        }

        [data-theme="light"] .tool-btn:hover {
            background: #2563eb;
            color: #fff;
            border-color: #2563eb;
        }

        /* v3.0 FIX: Comprehensive Light theme text contrast */
        [data-theme="light"] h3,
        [data-theme="light"] h4,
        [data-theme="light"] .sidebar-header,
        [data-theme="light"] .section-title {
            color: #0f172a !important;
        }

        [data-theme="light"] label,
        [data-theme="light"] .label-text,
        [data-theme="light"] .input-label {
            color: #334155 !important;
        }

        [data-theme="light"] .stat-value,
        [data-theme="light"] .metric-value,
        [data-theme="light"] .result-value,
        [data-theme="light"] .total-value {
            color: #0f172a !important;
            text-shadow: none !important;
        }

        [data-theme="light"] .stat-label,
        [data-theme="light"] .metric-label,
        [data-theme="light"] .result-label {
            color: #475569 !important;
        }

        [data-theme="light"] input,
        [data-theme="light"] select,
        [data-theme="light"] textarea {
            background: #ffffff !important;
            color: #0f172a !important;
            border-color: #cbd5e1 !important;
        }

        [data-theme="light"] input:focus,
        [data-theme="light"] select:focus {
            border-color: #2563eb !important;
            box-shadow: 0 0 0 3px rgba(37, 99, 235, 0.1) !important;
        }

        [data-theme="light"] .card,
        [data-theme="light"] .result-card,
        [data-theme="light"] .metric-card {
            background: #ffffff !important;
            border: 1px solid #e2e8f0 !important;
        }

        [data-theme="light"] table th {
            background: #f1f5f9 !important;
            color: #0f172a !important;
        }

        [data-theme="light"] table td {
            color: #1e293b !important;
            border-color: #e2e8f0 !important;
        }

        [data-theme="light"] .grand-total,
        [data-theme="light"] .summary-total {
            background: #f0fdf4 !important;
            color: #166534 !important;
            border: 1px solid #86efac !important;
        }

        .tool-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }

        .canvas-wrapper {
            flex: 1;
            position: relative;
            overflow: hidden;
        }

        #mainCanvas {
            background: var(--canvas-bg);
            cursor: crosshair;
        }

        /* ========== RESULTS PANEL ========== */
        .summary-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 8px;
            margin-bottom: 16px;
        }

        .summary-card {
            background: rgba(0, 0, 0, 0.3);
            padding: 12px;
            border-radius: 8px;
            text-align: center;
        }

        .summary-card .label {
            font-size: 0.65rem;
            color: #8b949e;
            margin-bottom: 4px;
        }

        .summary-card .value {
            font-size: 1.3rem;
            font-weight: 700;
            color: var(--primary);
        }

        .summary-card .unit {
            font-size: 0.65rem;
            color: #8b949e;
        }

        /* ========== RESULTS TABLE ========== */
        .results-table {
            width: 100%;
            border-collapse: collapse;
            font-size: 0.85rem;
        }

        .results-table th {
            background: rgba(0, 0, 0, 0.3);
            padding: 8px;
            text-align: left;
            color: var(--primary);
            border-bottom: 1px solid var(--border);
        }

        .results-table td {
            padding: 10px 8px;
            border-bottom: 1px solid var(--border);
        }

        /* Global select styling for visibility */
        select {
            background: var(--surface) !important;
            color: #fff !important;
            border: 1px solid var(--border);
            border-radius: 4px;
            padding: 6px 8px;
        }

        select option {
            background: var(--surface);
            color: #fff;
        }

        .results-table tr:hover {
            background: rgba(0, 212, 255, 0.05);
        }

        /* ========== BUTTONS ========== */
        .action-btn {
            width: 100%;
            padding: 12px;
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border: none;
            border-radius: 8px;
            color: #fff;
            font-weight: 600;
            cursor: pointer;
            margin-top: 12px;
            transition: all 0.2s;
        }

        .action-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 5px 20px rgba(0, 212, 255, 0.3);
        }

        /* ========== LOAD PATH INDICATOR ========== */
        .load-path {
            background: linear-gradient(135deg, rgba(16, 185, 129, 0.1), rgba(0, 212, 255, 0.1));
            border: 1px solid var(--success);
            border-radius: 8px;
            padding: 12px;
            margin-bottom: 16px;
            text-align: center;
        }

        .load-path h4 {
            color: var(--success);
            font-size: 0.75rem;
            margin-bottom: 6px;
        }

        .load-path .path {
            font-size: 0.9rem;
            font-weight: 600;
        }

        .load-path .arrow {
            color: var(--primary);
            margin: 0 8px;
        }

        /* ========== FLOOR TABS ========== */
        .floor-tabs-container {
            margin-bottom: 16px;
        }

        .floor-tabs-header {
            display: flex;
            align-items: center;
            gap: 8px;
            margin-bottom: 8px;
        }

        .floor-tabs-header h4 {
            font-size: 0.75rem;
            color: var(--primary);
        }

        .floor-tabs {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .floor-tab {
            padding: 6px 12px;
            background: var(--glass);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #8b949e;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .floor-tab:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--primary);
        }

        .floor-tab.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: transparent;
            color: white;
        }

        .floor-tab.roof {
            border-color: var(--warning);
            color: var(--warning);
        }

        .floor-tab.roof.active {
            background: linear-gradient(135deg, var(--warning), #d97706);
            color: white;
        }

        .add-floor-btn {
            padding: 6px 10px;
            background: transparent;
            border: 1px dashed var(--success);
            border-radius: 6px;
            color: var(--success);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .add-floor-btn:hover {
            background: rgba(16, 185, 129, 0.1);
        }

        .remove-floor-btn {
            padding: 6px 10px;
            background: transparent;
            border: 1px dashed var(--danger);
            border-radius: 6px;
            color: var(--danger);
            font-size: 0.7rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .remove-floor-btn:hover {
            background: rgba(239, 68, 68, 0.1);
        }

        .floor-info {
            background: rgba(0, 212, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 8px;
            padding: 10px;
            margin-top: 8px;
        }

        .floor-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 8px;
        }

        .floor-info-header h5 {
            font-size: 0.75rem;
            color: var(--primary);
        }

        .floor-type-badge {
            font-size: 0.6rem;
            padding: 2px 6px;
            border-radius: 4px;
            background: var(--secondary);
            color: white;
        }

        .floor-type-badge.roof {
            background: var(--warning);
        }

        /* ========== v2.4: VIEW TOGGLE ========== */
        .view-toggle {
            display: flex;
            gap: 4px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px;
            border-radius: 8px;
            margin-right: 8px;
        }

        .view-btn {
            padding: 6px 12px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 6px;
            color: #8b949e;
            font-size: 0.7rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.2s;
        }

        .view-btn:hover {
            background: rgba(0, 212, 255, 0.1);
            border-color: var(--primary);
        }

        .view-btn.active {
            background: linear-gradient(135deg, var(--primary), var(--secondary));
            border-color: transparent;
            color: white;
        }

        #container3D {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            display: none;
        }

        #container3D.active {
            display: block;
        }

        .canvas-wrapper {
            position: relative;
        }

        /* ========== v3.0: CANTILEVER INPUTS ========== */
        .cantilever-section {
            display: grid;
            gap: 8px;
        }

        .cantilever-edge {
            background: rgba(245, 158, 11, 0.08);
            border: 1px solid rgba(245, 158, 11, 0.3);
            border-radius: 6px;
            padding: 8px;
        }

        .cantilever-edge-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 6px;
        }

        .cantilever-edge-header label {
            font-size: 0.7rem;
            color: var(--warning);
            font-weight: 600;
        }

        .cantilever-spans {
            display: flex;
            flex-wrap: wrap;
            gap: 4px;
        }

        .cantilever-span-input {
            display: flex;
            align-items: center;
            gap: 4px;
            background: rgba(0, 0, 0, 0.3);
            padding: 4px 6px;
            border-radius: 4px;
        }

        .cantilever-span-input span {
            font-size: 0.6rem;
            color: #8b949e;
            min-width: 20px;
        }

        .cantilever-span-input input {
            width: 50px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid var(--border);
            border-radius: 3px;
            padding: 4px;
            color: #fff;
            font-size: 0.75rem;
            text-align: center;
        }

        .cantilever-span-input input:focus {
            outline: none;
            border-color: var(--warning);
        }

        /* ========== v3.0: 2D PLAN TABS ========== */
        .plan-tabs {
            display: flex;
            gap: 2px;
            background: rgba(0, 0, 0, 0.4);
            padding: 3px;
            border-radius: 8px;
            margin-left: 8px;
        }

        .plan-tab {
            padding: 5px 12px;
            background: transparent;
            border: 1px solid transparent;
            border-radius: 6px;
            color: var(--text-muted, #8b949e);
            font-size: 0.7rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
        }

        .plan-tab:hover {
            background: rgba(255, 255, 255, 0.05);
            color: var(--text-primary);
        }

        .plan-tab.active {
            background: var(--primary);
            color: #000;
            font-weight: 600;
        }

        /* Layer Toggle Buttons */
        .layer-toggles {
            display: flex;
            gap: 4px;
            margin-left: auto;
            padding-left: 12px;
            border-left: 1px solid var(--border);
        }

        .layer-btn {
            padding: 4px 8px;
            background: transparent;
            border: 1px solid var(--border);
            border-radius: 4px;
            color: var(--text-muted);
            font-size: 0.65rem;
            cursor: pointer;
            transition: all 0.2s;
        }

        .layer-btn:hover {
            background: rgba(255, 255, 255, 0.1);
        }

        .layer-btn.active {
            background: var(--primary);
            color: #000;
            border-color: var(--primary);
        }
    </style>

    <!-- v2.4: Three.js for 3D View -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
</head>

<body>
    <!-- ========== HEADER ========== -->
    <header class="header">
        <!-- Hamburger Menu (Settings) + Title - TOGETHER on LEFT -->
        <div style="display: flex; align-items: center; gap: 8px; position: relative;">
            <button class="tool-btn settings-gear" onclick="toggleDropdown()" title="Menu">
                ☰
            </button>
            <!-- Dropdown Menu -->
            <div id="settingsDropdown" class="settings-dropdown hidden">
                <div class="menu-item-header">THEME</div>
                <button id="themeBtn-midnight" class="menu-item"
                    onclick="setTheme('dark'); toggleDropdown()">Midnight</button>
                <button id="themeBtn-papermatte" class="menu-item"
                    onclick="setTheme('blueprint'); toggleDropdown()">Paper Matte</button>
                <div style="height:1px; background:#ddd; margin:4px 0; opacity:0.3;"></div>
                <button class="menu-item" onclick="resetProject(); toggleDropdown()">New Project</button>
                <button class="menu-item" onclick="saveProject(); toggleDropdown()">Save JSON</button>
            </div>

            <span style="font-weight: 600; font-size: 1rem; color: #000000; text-transform: uppercase;">TRIBUTARY PRO
                <span style="font-weight: 400;">v3.0</span></span>
        </div>
        <div class="header-actions">
            <button class="tool-btn" onclick="calculate()">Calculate</button>
            <button class="tool-btn" id="addBeamBtn" onclick="toggleBeamMode()"
                title="Click to add framing beam, then click-drag on canvas">Add Beam</button>
            <button class="tool-btn" onclick="exportResults()">Report</button>
            <button class="tool-btn" onclick="exportToSTAAD()">STAAD</button>
            <button class="tool-btn" onclick="exportToETABS()">ETABS</button>
            <button class="tool-btn" onclick="copySTAADToClipboard()"
                title="Copy STAAD code to clipboard (if download fails)">Copy</button>
            <button class="tool-btn" onclick="exportToDXF()" title="Export 2D plan to AutoCAD DXF">DXF</button>
            <button class="tool-btn" onclick="resetProject()"
                title="Reset to default values (new project)">Reset</button>
            <button class="tool-btn" onclick="refreshView()" title="Refresh calculations and redraw">Refresh</button>
        </div>
    </header>

    <!-- ========== MAIN LAYOUT ========== -->
    <div class="app-container">
        <!-- ========== LEFT PANEL: INPUTS ========== -->
        <div class="panel">
            <div class="panel-header">Input Parameters</div>

            <!-- Grid Spans -->
            <div class="param-group">
                <h3>X-Direction Spans (m)</h3>
                <div id="xSpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('x')">+ Add X Span</button>
            </div>

            <div class="param-group">
                <h3>Y-Direction Spans (m)</h3>
                <div id="ySpansContainer" class="span-container"></div>
                <button class="add-span-btn" onclick="addSpan('y')">+ Add Y Span</button>
            </div>

            <!-- v2.3: Floor Tabs -->
            <div class="floor-tabs-container">
                <div class="floor-tabs-header">
                    <h4>Floors</h4>
                </div>
                <div class="floor-tabs" id="floorTabs">
                    <!-- Dynamically populated -->
                </div>
                <div style="display: flex; gap: 4px; margin-top: 8px;">
                    <button class="add-floor-btn" onclick="addFloor()">+ Add Floor</button>
                    <button class="remove-floor-btn" onclick="removeFloor()">− Remove</button>
                </div>

                <!-- v2.6: GF Checkbox (suspended slabs start from 2F) -->
                <div style="margin-top: 10px; padding: 8px; background: rgba(255,193,7,0.1); border-radius: 6px;">
                    <label style="display: flex; align-items: center; gap: 8px; cursor: pointer; font-size: 0.75rem;">
                        <input type="checkbox" id="gfSuspended" onchange="toggleGFSuspended()">
                        <span>GF Suspended (elevated house)</span>
                    </label>
                    <!-- Elevation Height - visible when GF Suspended is checked -->
                    <div id="elevationSection" style="display: none; margin-top: 8px;">
                        <label style="font-size: 0.65rem; color: #8b949e;">Elevation Height:</label>
                        <select id="elevationHeight" onchange="updateGFElevation(parseFloat(this.value)); calculate()"
                            style="width: 100%; padding: 4px; margin-top: 2px; background: var(--surface); border: 1px solid var(--border); border-radius: 4px; color: white; font-size: 0.7rem;">
                            <option value="0.9">0.9 m</option>
                            <option value="1.0">1.0 m</option>
                            <option value="1.2" selected>1.2 m</option>
                            <option value="1.5">1.5 m</option>
                            <option value="1.8">1.8 m</option>
                        </select>
                    </div>
                    <div style="font-size: 0.65rem; color: #8b949e; margin-top: 4px;">
                        If unchecked, GF slab loads are excluded (typical for ground-bearing slabs)
                    </div>
                </div>

                <!-- v2.6: NSCP Building Type Preset -->
                <div style="margin-top: 10px;">
                    <label style="font-size: 0.7rem; color: #8b949e;">NSCP Building Type:</label>
                    <select id="buildingType" onchange="applyNSCPPreset()"
                        style="width: 100%; padding: 6px; margin-top: 4px; background: var(--surface); border: 1px solid var(--border); border-radius: 6px; color: white;">
                        <option value="residential">Residential (LL: 1.9 kPa)</option>
                        <option value="residential_heavy">Residential Heavy (LL: 2.4 kPa)</option>
                        <option value="office">Office (LL: 2.4 kPa)</option>
                        <option value="commercial">Commercial/Retail (LL: 4.8 kPa)</option>
                        <option value="school">School/Assembly (LL: 4.8 kPa)</option>
                        <option value="hospital">Hospital (LL: 3.8 kPa)</option>
                    </select>
                </div>

                <div class="floor-info" id="floorInfo">
                    <div class="floor-info-header">
                        <h5 id="currentFloorName">Ground Floor</h5>
                        <span class="floor-type-badge" id="floorTypeBadge">Typical</span>
                    </div>
                    <div class="param-grid">
                        <div class="param-item">
                            <label>DL Super (kPa) <span style="font-size:0.6rem;color:#f59e0b"
                                    title="Finishes, partitions, ceiling - NOT slab weight">ⓘ</span></label>
                            <input type="number" id="floorDL" value="2.0" step="0.5" min="0"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Live Load (kPa) <span style="font-size:0.6rem;color:#f59e0b"
                                    title="Can be higher for roof parties/water tanks">ⓘ</span></label>
                            <input type="number" id="floorLL" value="2.0" step="0.5" min="0"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Slab Thickness (mm)</label>
                            <input type="number" id="floorSlabThickness" value="150" step="10" min="100"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Height (m)</label>
                            <input type="number" id="floorHeight" value="3.0" step="0.1" min="2.5"
                                onchange="updateCurrentFloor()">
                        </div>
                        <div class="param-item">
                            <label>Wall Load (kN/m) <span style="font-size:0.6rem;color:#f59e0b"
                                    title="Line load for walls on beams (150mm CHB @3m ≈ 6.0)">ⓘ</span></label>
                            <input type="number" id="floorWallLoad" value="6.0" step="0.5" min="0"
                                onchange="updateCurrentFloor()">
                        </div>
                    </div>
                </div>
            </div>

            <!-- v3.0: Material Properties for Member Sizing -->
            <div class="param-group">
                <h3>Material & Member Sizing</h3>
                <div class="param-grid">
                    <div class="param-item">
                        <label>f'c (MPa)</label>
                        <select id="fcInput" onchange="state.fc = parseFloat(this.value); calculate();">
                            <option value="17">17 MPa</option>
                            <option value="21" selected>21 MPa</option>
                            <option value="24">24 MPa</option>
                            <option value="28">28 MPa</option>
                            <option value="35">35 MPa</option>
                        </select>
                    </div>
                    <div class="param-item">
                        <label>fy (MPa)</label>
                        <select id="fyInput" onchange="state.fy = parseFloat(this.value); calculate();">
                            <option value="275">Grade 40 (275)</option>
                            <option value="415" selected>Grade 60 (415)</option>
                        </select>
                    </div>
                </div>
                <div class="param-grid" style="margin-top: 8px;">
                    <div class="param-item">
                        <label>Column b (mm)</label>
                        <input type="number" id="columnWidthInput" value="0" min="0" max="600" step="50"
                            onchange="state.defaultColumnB = parseInt(this.value); calculate();"
                            title="0 = Auto (NSCP Pu sizing)">
                    </div>
                    <div class="param-item">
                        <label>Column h (mm)</label>
                        <input type="number" id="columnDepthInput" value="0" min="0" max="800" step="50"
                            onchange="state.defaultColumnH = parseInt(this.value); calculate();"
                            title="0 = Auto (same as b)">
                    </div>
                    <div class="param-item">
                        <label>Beam b (mm)</label>
                        <input type="number" id="beamWidthInput" value="250" min="200" max="500" step="25"
                            onchange="state.defaultBeamB = parseInt(this.value); calculate();">
                    </div>
                    <div class="param-item">
                        <label>Beam h (mm)</label>
                        <input type="number" id="beamDepthInput" value="0" min="0" max="800" step="50"
                            onchange="state.defaultBeamH = parseInt(this.value); calculate();"
                            title="0 = Auto (use L/16 rule)">
                    </div>
                </div>
                <div style="font-size: 0.7rem; color: var(--text-secondary); margin-top: 4px;">
                    💡 Set to 0 for auto-sizing (NSCP rules). Column h=0 means square.
                </div>
            </div>

            <!-- v2.5: Footing Parameters -->
            <div class="param-group">
                <h3>Footing Parameters</h3>
                <div class="param-grid">
                    <div class="param-item">
                        <label>Depth (m)</label>
                        <select id="footingDepth" onchange="calculate()">
                            <option value="1.2">1.2 m</option>
                            <option value="1.5" selected>1.5 m</option>
                            <option value="1.8">1.8 m</option>
                        </select>
                    </div>
                    <div class="param-item">
                        <label>Soil Bearing (kPa)</label>
                        <input type="number" id="soilBearing" value="150" step="10" min="50" onchange="calculate()">
                    </div>
                </div>
            </div>

            <!-- v3.0: Cantilever Configuration -->
            <div class="param-group">
                <h3>Cantilevers (m)</h3>
                <div class="cantilever-section">
                    <div class="cantilever-edge">
                        <div class="cantilever-edge-header">
                            <label>↑ Top Edge</label>
                        </div>
                        <div class="cantilever-spans" id="cantileverTop"></div>
                    </div>
                    <div class="cantilever-edge">
                        <div class="cantilever-edge-header">
                            <label>→ Right Edge</label>
                        </div>
                        <div class="cantilever-spans" id="cantileverRight"></div>
                    </div>
                    <div class="cantilever-edge">
                        <div class="cantilever-edge-header">
                            <label>↓ Bottom Edge</label>
                        </div>
                        <div class="cantilever-spans" id="cantileverBottom"></div>
                    </div>
                    <div class="cantilever-edge">
                        <div class="cantilever-edge-header">
                            <label>← Left Edge</label>
                        </div>
                        <div class="cantilever-spans" id="cantileverLeft"></div>
                    </div>
                </div>
                <div style="font-size: 0.6rem; color: #8b949e; margin-top: 6px;">
                    Enter cantilever length per span (0 = no cantilever)
                </div>
            </div>

            <!-- Calculate Button -->
            <button class="action-btn" onclick="calculate()">
                Calculate Loads
            </button>

            <!-- v3.0: Save/Load Project Buttons -->
            <div style="display:flex;gap:6px;margin-top:8px;">
                <button class="tool-btn" onclick="saveProject()" style="flex:1;" title="Download project as JSON file">
                    Save
                </button>
                <button class="tool-btn" onclick="document.getElementById('loadProjectInput').click()" style="flex:1;"
                    title="Load project from JSON file">
                    Load
                </button>
                <input type="file" id="loadProjectInput" accept=".json" onchange="loadProject(event)"
                    style="display:none;">
            </div>

            <!-- v3.0: Export to Analysis Software -->
            <div class="param-group" style="margin-top: 12px; padding: 10px;">
                <h3 style="margin-bottom: 8px;">EXPORT TO ANALYSIS SOFTWARE</h3>
                <div style="display:flex;gap:6px;">
                    <button class="tool-btn" onclick="exportToSTAAD()" style="flex:1;"
                        title="Export to STAAD.Pro (.std file)">
                        STAAD
                    </button>
                    <button class="tool-btn" onclick="exportToETABS()" style="flex:1;"
                        title="Export to ETABS (.e2k file)">
                        ETABS
                    </button>
                </div>
                <div style="display:flex;gap:6px;margin-top:6px;">
                    <button class="tool-btn" onclick="copySTAADToClipboard()"
                        style="flex:1;font-size:0.65rem;padding:4px;" title="Copy STAAD code to clipboard">
                        COPY STAAD
                    </button>
                    <button class="tool-btn" onclick="copyETABSToClipboard()"
                        style="flex:1;font-size:0.65rem;padding:4px;" title="Copy ETABS code to clipboard">
                        COPY ETABS
                    </button>
                </div>

                <!-- v3.0: Universal BIM Export -->
                <div style="margin-top:8px;border-top:1px solid rgba(0,0,0,0.1);padding-top:8px;">
                    <div style="font-size:0.65rem;color:#000000;margin-bottom:4px;">UNIVERSAL BIM (REVIT, ARCHICAD,
                        TEKLA)</div>
                    <button class="tool-btn" onclick="exportToIFC()" style="width:100%;"
                        title="Export to IFC format for Revit, ArchiCAD, Tekla, and all BIM software">
                        EXPORT TO IFC (REVIT/BIM)
                    </button>
                </div>
            </div>

        </div>


        <!-- ========== CENTER: CANVAS ========== -->
        <div class="canvas-container">
            <div class="canvas-toolbar">
                <!-- v2.4: View Toggle -->
                <div class="view-toggle">
                    <button class="view-btn active" id="view2D" onclick="setView('2d')">2D Plan</button>
                    <button class="view-btn" id="view3D" onclick="setView('3d')">3D View</button>
                </div>

                <!-- v3.0: 2D Plan Tabs -->
                <div class="plan-tabs" id="planTabs">
                    <button class="plan-tab active" id="tabAnalysis" onclick="setPlanTab('analysis')">
                        Analysis</button>
                    <button class="plan-tab" id="tabStructural" onclick="setPlanTab('structural')">Structural
                        Plan</button>
                    <button class="plan-tab" id="tabFoundation" onclick="setPlanTab('foundation')">Foundation
                        Plan</button>
                </div>

                <!-- Layer Toggles (inspired by Sia's design) -->
                <div class="layer-toggles">
                    <button class="layer-btn active" id="layerGrid" onclick="toggleLayer('grid')">GRID</button>
                    <button class="layer-btn active" id="layerAreas" onclick="toggleLayer('areas')">Areas</button>
                    <button class="layer-btn active" id="layerBeams" onclick="toggleLayer('beams')">Beams</button>
                    <button class="layer-btn active" id="layerCols" onclick="toggleLayer('cols')">Cols</button>
                </div>

                <button class="tool-btn" id="panTool" onclick="togglePan()">Pan</button>
                <button class="tool-btn" onclick="zoomIn()">Zoom In</button>
                <button class="tool-btn" onclick="zoomOut()">Zoom Out</button>
                <button class="tool-btn" onclick="fitView()">Fit</button>
                <button class="tool-btn active" id="toggleAreas" onclick="toggleAreas()">Areas</button>
                <button class="tool-btn" id="toggleLabels" onclick="toggleLabels()">Labels</button>
                <button class="tool-btn" id="gridToggleBtn" onclick="toggleSubGrid()" title="Show 1m gridlines">
                    Grid</button>
                <button class="tool-btn" id="addCustomBeamBtn" onclick="showCustomBeamDialog()"
                    title="Add framing beam via dialog (gridline-based)">Stair Beam</button>
                <button class="tool-btn" id="addPlantedColBtn" onclick="togglePlantedColumnMode(event)"
                    title="Click to select beam for planted column. Shift+Click for grid/custom placement.">
                    Planted Col</button>
                <button class="tool-btn" id="colAlignBtn" onclick="toggleColumnAlignment()"
                    title="Toggle edge column alignment (Centered ↔ Flush to Grid)">Col: Center</button>
            </div>
            <div class="canvas-wrapper">
                <canvas id="mainCanvas"></canvas>
                <!-- v2.4: 3D Container -->
                <div id="container3D"></div>
            </div>
        </div>

        <!-- ========== RIGHT PANEL: RESULTS ========== -->
        <div class="panel">
            <div class="panel-header">Results</div>

            <!-- Compact Results Table (Paper Matte style) -->
            <div class="results-table-container" style="overflow-x:auto; margin-top:8px; border: 1px solid #000;">
                <table class="compact-table"
                    style="width:100%; border-collapse: collapse; font-family: monospace; font-size: 0.75rem; color: #000;">
                    <tr style="border-bottom: 2px solid #000; background: #e8eef4;">
                        <th style="text-align:left; padding:6px; font-weight:bold;">METRIC</th>
                        <th style="text-align:right; padding:6px; font-weight:bold;">VALUE</th>
                        <th style="text-align:left; padding:6px; font-weight:bold;">UNIT</th>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">TOTAL SLAB AREA</td>
                        <td style="text-align:right; padding:4px; font-weight:bold;" id="totalArea">0</td>
                        <td style="padding:4px;">m²</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">AREA BALANCE</td>
                        <td style="text-align:right; padding:4px;" id="areaBalance">0%</td>
                        <td style="padding:4px; font-size:0.65rem;" id="areaBalanceDetail">beam vs slab</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">FACTORED LOAD</td>
                        <td style="text-align:right; padding:4px;" id="factoredLoad">0</td>
                        <td style="padding:4px;">kPa</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">TOTAL/FLOOR</td>
                        <td style="text-align:right; padding:4px;" id="totalPerFloor">0</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 2px solid #000;">
                        <td style="padding:4px;">MAX COLUMN</td>
                        <td style="text-align:right; padding:4px;" id="maxColumn">0</td>
                        <td style="padding:4px;">kN</td>
                    </tr>

                    <!-- Load Summary Header -->
                    <tr style="background:#000; color:#fff;">
                        <td colspan="3" style="padding:6px; font-weight:bold; letter-spacing:1px; text-align:center;">
                            LOAD SUMMARY</td>
                    </tr>

                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">SLAB DL</td>
                        <td style="text-align:right; padding:4px;" id="sumSlabDL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">LIVE LOAD</td>
                        <td style="text-align:right; padding:4px;" id="sumLL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">BEAM DL</td>
                        <td style="text-align:right; padding:4px;" id="sumBeamDL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">COLUMN DL</td>
                        <td style="text-align:right; padding:4px;" id="sumColDL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 1px solid #ccc;">
                        <td style="padding:4px;">TIE BEAM</td>
                        <td style="text-align:right; padding:4px;" id="sumTieBeamDL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <tr style="border-bottom: 2px solid #000;">
                        <td style="padding:4px;">FOOTINGS</td>
                        <td style="text-align:right; padding:4px;" id="sumFootingDL">-</td>
                        <td style="padding:4px;">kN</td>
                    </tr>
                    <!-- Grand Total -->
                    <tr style="background:#f8fafc; font-weight:bold;">
                        <td style="padding:8px; border-right:1px solid #000;">GRAND TOTAL</td>
                        <td style="text-align:right; padding:8px; font-size:1rem;" id="grandTotal">-</td>
                        <td style="padding:8px;">kN</td>
                    </tr>
                </table>
            </div>

            <!-- Column Results Table -->
            <div class="param-group">
                <h3>Column Loads & Footings</h3>
                <div style="max-height: 300px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th title="Toggle to remove column (L/U shapes)">✓</th>
                                <th>ID</th>
                                <th>Type</th>
                                <th title="v3.0: Set column start floor (planted columns)">Start</th>
                                <th>Floor (kN)</th>
                                <th>Total (kN)</th>
                                <th title="Load breakdown">📊</th>
                                <th>Size (mm)</th>
                                <th>Footing (m)</th>
                            </tr>
                        </thead>
                        <tbody id="columnResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- Beam Results -->
            <div class="param-group">
                <h3>📏 Beam Loads</h3>
                <div style="max-height: 200px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Beam</th>
                                <th>w (kN/m)</th>
                                <th>R (kN)</th>
                                <th>b×h (mm)</th>
                            </tr>
                        </thead>
                        <tbody id="beamResultsBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- v3.2: Footing Schedule -->
            <div class="param-group">
                <h3>🧱 Footing Schedule</h3>
                <div style="max-height: 180px; overflow-y: auto;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Footing</th>
                                <th>Column</th>
                                <th>Size (m)</th>
                                <th>Thk (mm)</th>
                            </tr>
                        </thead>
                        <tbody id="footingScheduleBody">
                            <!-- Dynamic content -->
                        </tbody>
                    </table>
                </div>
            </div>

            <!-- v3.2: Tie Beam Schedule -->
            <div class="param-group">
                <h3>🔗 Tie Beam Size</h3>
                <div style="display:flex;gap:12px;align-items:center;">
                    <label>Width (mm):
                        <input type="number" id="tieBeamWidth" value="200" min="150" max="400" step="25"
                            style="width:60px;padding:4px;background:rgba(0,0,0,0.3);border:1px solid var(--border);border-radius:4px;color:white;text-align:center;"
                            onchange="updateTieBeamSize()">
                    </label>
                    <label>Depth (mm):
                        <input type="number" id="tieBeamDepth" value="350" min="250" max="600" step="50"
                            style="width:60px;padding:4px;background:rgba(0,0,0,0.3);border:1px solid var(--border);border-radius:4px;color:white;text-align:center;"
                            onchange="updateTieBeamSize()">
                    </label>
                </div>
                <p style="font-size:0.6rem;color:#8b949e;margin-top:4px;">Min: 200×350mm (NBC)</p>
            </div>

            <!-- v3.2: Member Dimensions table removed - size controls now in individual schedules -->

            <!-- v3.0: Concrete Volume Summary -->
            <div class="param-group">
                <h3>🧱 Concrete Volume</h3>
                <div id="concreteVolumeSection" style="font-size:0.75rem;">
                    <table class="results-table">
                        <thead>
                            <tr>
                                <th>Element</th>
                                <th>Qty</th>
                                <th>Volume (m³)</th>
                            </tr>
                        </thead>
                        <tbody id="concreteVolumeBody">
                            <!-- Dynamic content -->
                        </tbody>
                        <tfoot>
                            <tr style="background:rgba(16,185,129,0.15);font-weight:bold;">
                                <td colspan="2">TOTAL</td>
                                <td id="totalConcreteVolume">-</td>
                            </tr>
                        </tfoot>
                    </table>
                </div>
            </div>

            <!-- v3.0: Schedules Button -->
            <div class="param-group" style="text-align:center;">
                <button onclick="showSchedulesModal()" style="
                    width: 100%;
                    padding: 12px;
                    background: linear-gradient(135deg, #6366f1, #8b5cf6);
                    border: none;
                    border-radius: 8px;
                    color: white;
                    font-weight: bold;
                    cursor: pointer;
                    font-size: 0.9rem;
                    display: flex;
                    align-items: center;
                    justify-content: center;
                    gap: 8px;
                ">📋 View Schedules</button>
            </div>
        </div>
    </div>

    <!-- v3.0: Custom Beam Modal Dialog -->
    <div id="customBeamModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1000; justify-content:center; align-items:center;">
        <div
            style="background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:24px; min-width:320px; box-shadow:0 20px 40px rgba(0,0,0,0.5);">
            <h3 style="color:#00d4ff; margin:0 0 16px 0; display:flex; align-items:center; gap:8px;">🪜 Add Custom Beam
            </h3>

            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Direction</label>
                <select id="cbDir"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                    <option value="X">X-Direction (Horizontal beam at Y position)</option>
                    <option value="Y">Y-Direction (Vertical beam at X position)</option>
                </select>
            </div>

            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Reference
                    Gridline</label>
                <select id="cbRefGridline"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                    <!-- Populated dynamically -->
                </select>
            </div>

            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Offset from Gridline
                    (m)</label>
                <input type="number" id="cbOffset" value="1.5" step="0.1" min="0.1"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
            </div>

            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:16px;">
                <div>
                    <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">From Span</label>
                    <select id="cbFromSpan"
                        style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                        <!-- Populated dynamically -->
                    </select>
                </div>
                <div>
                    <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">To Span</label>
                    <select id="cbToSpan"
                        style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                        <!-- Populated dynamically -->
                    </select>
                </div>
            </div>

            <div
                style="font-size:0.7rem; color:#f59e0b; background:rgba(245,158,11,0.1); padding:8px; border-radius:6px; margin-bottom:16px;">
                💡 Beam will be placed perpendicular to the chosen direction, at the offset distance from the reference
                gridline.
            </div>

            <div style="display:flex; gap:8px;">
                <button onclick="hideCustomBeamDialog()"
                    style="flex:1; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#8b949e; cursor:pointer;">Cancel</button>
                <button onclick="addCustomBeam()"
                    style="flex:1; padding:10px; background:linear-gradient(135deg,#f59e0b,#d97706); border:none; border-radius:6px; color:white; font-weight:600; cursor:pointer;">Add
                    Beam</button>
            </div>
        </div>
    </div>

    <!-- v3.0: Planted Column Modal Dialog -->
    <div id="plantedColumnModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1000; justify-content:center; align-items:center;">
        <div
            style="background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:24px; min-width:360px; box-shadow:0 20px 40px rgba(0,0,0,0.5);">
            <h3 style="color:#8b5cf6; margin:0 0 16px 0; display:flex; align-items:center; gap:8px;">⏫ Add Planted
                Column
            </h3>

            <!-- v3.0: Placement Mode Toggle -->
            <div
                style="display:flex; gap:4px; margin-bottom:16px; background:rgba(0,0,0,0.3); padding:4px; border-radius:8px;">
                <button id="pcModeGrid" onclick="setPCPlacementMode('grid')"
                    style="flex:1; padding:8px; border:none; border-radius:6px; cursor:pointer; font-size:0.75rem; font-weight:600; background:linear-gradient(135deg,#8b5cf6,#6366f1); color:white;">
                    📍 Grid Location
                </button>
                <button id="pcModeCustom" onclick="setPCPlacementMode('custom')"
                    style="flex:1; padding:8px; border:none; border-radius:6px; cursor:pointer; font-size:0.75rem; font-weight:600; background:transparent; color:#8b949e;">
                    📐 Custom X,Y
                </button>
            </div>

            <!-- Grid Location Mode -->
            <div id="pcGridSection" style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Grid Location</label>
                <select id="pcGridLocation"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                    <!-- Populated dynamically -->
                </select>
            </div>

            <!-- Custom X,Y Mode (hidden by default) -->
            <div id="pcCustomSection" style="display:none; margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">📐 Custom Coordinates
                    (meters from origin)</label>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <div>
                        <label style="font-size:0.65rem; color:#6366f1;">X (m)</label>
                        <input type="number" id="pcCustomX" value="0" step="0.1" min="0"
                            style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(139,92,246,0.4); border-radius:6px; color:white;"
                            placeholder="X coord">
                    </div>
                    <div>
                        <label style="font-size:0.65rem; color:#6366f1;">Y (m)</label>
                        <input type="number" id="pcCustomY" value="0" step="0.1" min="0"
                            style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(139,92,246,0.4); border-radius:6px; color:white;"
                            placeholder="Y coord">
                    </div>
                </div>
                <div style="font-size:0.65rem; color:#8b949e; margin-top:4px;">💡 Tip: Click on canvas to auto-fill
                    coordinates!</div>
            </div>

            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Starting Floor
                    (Column appears from this floor upward)</label>
                <select id="pcStartFloor"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                    <!-- Populated dynamically -->
                </select>
            </div>

            <div style="margin-bottom:16px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Column Size
                    (mm)</label>
                <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px;">
                    <input type="number" id="pcWidthB" value="300" min="200" max="1000" step="50"
                        style="padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;"
                        placeholder="Width (b)">
                    <input type="number" id="pcDepthH" value="300" min="200" max="1000" step="50"
                        style="padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;"
                        placeholder="Depth (h)">
                </div>
            </div>

            <div
                style="font-size:0.7rem; color:#8b5cf6; background:rgba(139,92,246,0.1); padding:8px; border-radius:6px; margin-bottom:16px;">
                💡 A planted column starts from an upper floor (e.g., 2F) instead of the ground. It transfers load to
                beams below.
            </div>

            <div style="display:flex; gap:8px;">
                <button onclick="hidePlantedColumnDialog()"
                    style="flex:1; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#8b949e; cursor:pointer;">Cancel</button>
                <button onclick="addPlantedColumn()"
                    style="flex:1; padding:10px; background:linear-gradient(135deg,#8b5cf6,#6366f1); border:none; border-radius:6px; color:white; font-weight:600; cursor:pointer;">Add
                    Column</button>
            </div>
        </div>
    </div>

    <!-- v3.0: Beam Offset Dialog for Planted Column Placement -->
    <div id="beamOffsetModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1002; justify-content:center; align-items:center;">
        <div
            style="background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(139,92,246,0.5); border-radius:12px; padding:24px; min-width:320px; box-shadow:0 20px 40px rgba(139,92,246,0.2);">
            <h3 style="color:#8b5cf6; margin:0 0 16px 0; display:flex; align-items:center; gap:8px;">⏫ Place Column on
                Beam</h3>

            <!-- Beam Info -->
            <div style="background:rgba(0,0,0,0.3); padding:12px; border-radius:8px; margin-bottom:16px;">
                <div style="font-size:0.7rem; color:#8b949e; margin-bottom:4px;">Selected Beam:</div>
                <div id="pcBeamInfo" style="color:#00d4ff; font-weight:bold;">-</div>
            </div>

            <!-- Offset Input -->
            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">
                    Offset from Start (m) <span id="pcOffsetDirection" style="color:#f59e0b;">→</span>
                </label>
                <input type="number" id="pcBeamOffset" value="1.0" step="0.1" min="0.1"
                    style="width:100%; padding:10px; background:rgba(0,0,0,0.3); border:1px solid rgba(139,92,246,0.5); border-radius:6px; color:white; font-size:1rem;">
                <div id="pcOffsetRange" style="font-size:0.65rem; color:#8b949e; margin-top:4px;">Range: 0.1 - 8.0 m
                </div>
            </div>

            <!-- Start Floor -->
            <div style="margin-bottom:12px;">
                <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Start Floor</label>
                <select id="pcBeamStartFloor"
                    style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                    <!-- Populated dynamically -->
                </select>
            </div>

            <!-- Column Size -->
            <div style="display:grid; grid-template-columns:1fr 1fr; gap:8px; margin-bottom:16px;">
                <div>
                    <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Width b
                        (mm)</label>
                    <input type="number" id="pcBeamColB" value="250" step="50" min="150" max="600"
                        style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                </div>
                <div>
                    <label style="display:block; font-size:0.75rem; color:#8b949e; margin-bottom:4px;">Depth h
                        (mm)</label>
                    <input type="number" id="pcBeamColH" value="250" step="50" min="150" max="600"
                        style="width:100%; padding:8px; background:rgba(0,0,0,0.3); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:white;">
                </div>
            </div>

            <div
                style="font-size:0.7rem; color:#f59e0b; background:rgba(245,158,11,0.1); padding:8px; border-radius:6px; margin-bottom:16px;">
                💡 Column will be placed as a <strong>point load</strong> on this beam
            </div>

            <div style="display:flex; gap:8px;">
                <button onclick="hideBeamOffsetDialog()"
                    style="flex:1; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#8b949e; cursor:pointer;">Cancel</button>
                <button onclick="placePlantedColumnOnBeam()"
                    style="flex:1; padding:10px; background:linear-gradient(135deg,#8b5cf6,#6366f1); border:none; border-radius:6px; color:white; font-weight:600; cursor:pointer;">Place
                    Column</button>
            </div>
        </div>
    </div>

    <!-- v3.0: Column Context Menu (appears on column click) -->
    <div id="columnContextMenu"
        style="display:none; position:fixed; background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:8px 0; min-width:180px; box-shadow:0 10px 30px rgba(0,0,0,0.5); z-index:1001;">
        <div id="columnMenuTitle"
            style="padding:8px 16px; color:#00d4ff; font-weight:bold; border-bottom:1px solid rgba(255,255,255,0.1); margin-bottom:4px;">
            Column A1</div>
        <button class="ctx-menu-btn" onclick="toggleSelectedColumn()">🔄 Toggle Active</button>
        <div style="border-top:1px solid rgba(255,255,255,0.1); margin:4px 0;"></div>
        <div style="padding:4px 16px; font-size:0.7rem; color:#8b949e;">Set as Planted Column:</div>
        <div id="plantedFloorOptions">
            <!-- Populated dynamically -->
        </div>
        <button class="ctx-menu-btn" onclick="clearPlantedFloor()" style="color:#ef4444;">🚫 Clear Planted
            (Ground)</button>
    </div>

    <!-- v3.2: Universal Member Context Menu (right-click on beams/slabs) -->
    <div id="memberContextMenu"
        style="display:none; position:fixed; background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(255,255,255,0.2); border-radius:8px; padding:8px 0; min-width:160px; box-shadow:0 10px 30px rgba(0,0,0,0.5); z-index:1001;">
        <div id="memberMenuTitle"
            style="padding:8px 16px; color:#00d4ff; font-weight:bold; border-bottom:1px solid rgba(255,255,255,0.1); margin-bottom:4px;">
            Beam B-1</div>
        <button class="ctx-menu-btn" onclick="deleteMemberFromMenu()" style="color:#ef4444;">🗑️ Delete</button>
        <button class="ctx-menu-btn" id="memberLockBtn" onclick="toggleMemberLocked()" style="color:#f59e0b;">🔒
            Lock</button>
        <button class="ctx-menu-btn" onclick="restoreMemberFromMenu()" style="color:#10b981;">♻️ Restore</button>
        <button class="ctx-menu-btn" onclick="hideMemberMenu()">❌ Cancel</button>
    </div>

    <!-- v3.0: Schedules Modal -->
    <div id="schedulesModal"
        style="display:none; position:fixed; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.7); z-index:1000; justify-content:center; align-items:center;">
        <div
            style="background:linear-gradient(135deg,#1e293b,#0f172a); border:1px solid rgba(255,255,255,0.2); border-radius:12px; padding:24px; width:90%; max-width:900px; max-height:80vh; overflow:hidden; box-shadow:0 20px 40px rgba(0,0,0,0.5);">
            <div style="display:flex; justify-content:space-between; align-items:center; margin-bottom:16px;">
                <h3 style="color:#00d4ff; margin:0; display:flex; align-items:center; gap:8px;">📋 Beam & Column
                    Schedules</h3>
                <button onclick="hideSchedulesModal()"
                    style="background:none; border:none; color:#8b949e; font-size:1.5rem; cursor:pointer;">&times;</button>
            </div>

            <!-- Tabs -->
            <div style="display:flex; gap:8px; margin-bottom:16px;">
                <button id="schedTabBeams" class="sched-tab active" onclick="switchScheduleTab('beams')">📏
                    Beams</button>
                <button id="schedTabColumns" class="sched-tab" onclick="switchScheduleTab('columns')">🏛️
                    Columns</button>
            </div>

            <!-- Beam Schedule -->
            <div id="scheduleBeamsPanel" style="max-height:50vh; overflow:auto;">
                <table class="results-table" style="width:100%;">
                    <thead>
                        <tr>
                            <th>Beam ID</th>
                            <th>Dir</th>
                            <th>Span (m)</th>
                            <th>Size (mm)</th>
                            <th>Start Col</th>
                            <th>End Col</th>
                            <th>w (kN/m)</th>
                            <th>R (kN)</th>
                        </tr>
                    </thead>
                    <tbody id="scheduleBeamsBody">
                        <!-- Dynamic -->
                    </tbody>
                </table>
            </div>

            <!-- Column Schedule -->
            <div id="scheduleColumnsPanel" style="display:none; max-height:50vh; overflow:auto;">
                <table class="results-table" style="width:100%;">
                    <thead>
                        <tr>
                            <th>Col ID</th>
                            <th>Type</th>
                            <th>Size (mm)</th>
                            <th>Total Load (kN)</th>
                            <th>Footing (m)</th>
                            <th>Planted?</th>
                            <th>Floors Active</th>
                        </tr>
                    </thead>
                    <tbody id="scheduleColumnsBody">
                        <!-- Dynamic -->
                    </tbody>
                </table>
            </div>

            <div style="display:flex; gap:8px; margin-top:16px;">
                <button onclick="exportScheduleCSV()"
                    style="flex:1; padding:10px; background:linear-gradient(135deg,#10b981,#059669); border:none; border-radius:6px; color:white; cursor:pointer; font-weight:bold;">📥
                    Export CSV</button>
                <button onclick="hideSchedulesModal()"
                    style="flex:1; padding:10px; background:rgba(255,255,255,0.1); border:1px solid rgba(255,255,255,0.2); border-radius:6px; color:#8b949e; cursor:pointer;">Close</button>
            </div>
        </div>
    </div>

    <style>
        /* Column context menu button styles */
        .ctx-menu-btn {
            display: block;
            width: 100%;
            padding: 8px 16px;
            background: none;
            border: none;
            color: #e2e8f0;
            text-align: left;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .ctx-menu-btn:hover {
            background: rgba(99, 102, 241, 0.2);
        }

        /* Schedule tab styles */
        .sched-tab {
            padding: 8px 16px;
            background: rgba(255, 255, 255, 0.05);
            border: 1px solid rgba(255, 255, 255, 0.1);
            border-radius: 6px;
            color: #8b949e;
            cursor: pointer;
            font-size: 0.85rem;
        }

        .sched-tab.active {
            background: rgba(99, 102, 241, 0.3);
            border-color: #6366f1;
            color: #e2e8f0;
        }
    </style>


    <!-- ========== JAVASCRIPT ========== -->
    <script>
        // ========================================
        // TRIBUTARY PRO v2.0 - CORE ENGINE
        // ========================================
        // Load Path: SLAB → BEAMS → COLUMNS
        // Per Lum's Refined Spec (Dec 15, 2025)
        // ========================================

        // ========== STATE ==========
        const state = {
            xSpans: [4.0, 4.0],      // X-direction bay sizes (m)
            ySpans: [5.0, 5.0],      // Y-direction bay sizes (m)

            // v3.0: Cantilever configuration per edge span
            // Each array element = cantilever length for that span index (0 = no cantilever)
            cantilevers: {
                top: [0, 0],      // Length matching xSpans - cantilever above first row
                bottom: [0, 0],   // Length matching xSpans - cantilever below last row
                left: [0, 0],     // Length matching ySpans - cantilever left of first column
                right: [0, 0]     // Length matching ySpans - cantilever right of last column
            },

            // v2.3: Floors array - per floor configurations
            // v2.7: Corrected floor logic:
            //   Without GF Suspended: 2F | RF (2 tabs = 2 suspended slabs)
            //   With GF Suspended: GF | 2F | RF (3 tabs = 3 suspended slabs)
            //   GF tab is added dynamically when checkbox is checked
            // v3.0 FIX: Each floor has its own cantilevers, customBeams, voidSlabs, deletedBeams
            floors: [
                {
                    id: '2F', name: '2nd Floor', dlSuper: 2.0, liveLoad: 2.0, slabThickness: 150, height: 3.0, wallLoad: 6.0, isRoof: false,
                    cantilevers: { top: [0, 0], bottom: [0, 0], left: [0, 0], right: [0, 0] },
                    customBeams: [], voidSlabs: [], deletedBeams: [], lockedBeams: [], lockedSlabs: []
                },
                {
                    id: 'RF', name: 'Roof', dlSuper: 1.5, liveLoad: 1.0, slabThickness: 120, height: 3.0, wallLoad: 0, isRoof: true,
                    cantilevers: { top: [0, 0], bottom: [0, 0], left: [0, 0], right: [0, 0] },
                    customBeams: [], voidSlabs: [], deletedBeams: [], lockedBeams: [], lockedSlabs: []
                }
            ],
            currentFloorIndex: 0,    // Which floor is selected

            // Generated data
            columns: [],             // Column objects
            beams: [],               // Beam objects
            slabs: [],               // Slab panel objects

            // View state
            scale: 50,
            offsetX: 100,
            offsetY: 100,
            showLabels: true,
            showAreas: true,  // v2.2: show slice polygons by default
            isPanning: false, // v2.4: pan mode
            isDragging: false,
            lastMouseX: 0,
            lastMouseY: 0,

            // v2.5: Footing state
            footingDepth: 1.5,
            soilBearing: 150,  // kPa

            // v2.6: GF suspended toggle
            gfSuspended: false,  // If false, GF slab loads excluded (ground-bearing)

            // v3.0: Tie beam sizing (calculated from longest span)
            // Depth = max(longestSpan/10, 0.3m), Width = max(largestFooting, 0.25m)
            tieBeamH: 0.4,   // m - will be calculated
            tieBeamW: 0.25,  // m - will be calculated

            // v3.0: Material properties for member sizing
            fc: 21,            // Concrete f'c in MPa (21, 24, 28, 35)
            fy: 415,           // Steel fy in MPa (275 = Grade 40, 415 = Grade 60)
            concreteDensity: 24,  // kN/m³ for self-weight calculation
            defaultColumnB: 0,    // Default column width (mm), 0 = auto (NSCP)
            defaultColumnH: 0,    // Default column depth (mm), 0 = same as b (square)
            defaultBeamB: 250,    // Default beam width (mm), 0 = auto
            defaultBeamH: 0,      // Default beam depth (mm), 0 = auto (L/16 rule)

            // v3.0: Custom beams for staircase framing (per floor - stored in floor object)
            addingBeam: false,     // Mode flag for adding beams
            beamDrawStart: null,   // Start point when drawing beam
            nextCustomBeamId: 1,   // Counter for unique beam IDs

            // v3.0: Void slabs for U-shape/L-shape layouts (per floor - stored in floor object)
            voidSlabs: [],          // Legacy global - now per floor

            // v3.0: Grid and snap settings for precise element placement
            showSubGrid: false,     // Toggle for 1m sub-gridlines overlay
            snapEnabled: false,     // Toggle for snap-to-grid
            snapSize: 0.1,          // Snap increment in meters (0.1m = 10cm default)

            // v3.0: Undo stack for restoring deleted items
            undoStack: [],           // Array of {type, data, floorId} for undo operations

            // v3.1: Column alignment relative to gridlines
            // 'center' = column center on gridline (default)
            // 'outer' = outer face of edge columns on gridline
            // 'inner' = inner face on gridline
            columnAlignment: 'center'
        };

        // ========== v3.0: PLAN TABS & LAYER TOGGLES ==========
        let currentPlanTab = 'analysis';  // 'analysis' or 'structural'
        let layerVisibility = {
            grid: true,
            areas: true,
            beams: true,
            cols: true
        };

        // v3.0: Planted column beam placement mode
        let placingPlantedColumn = false;   // True when user is placing a planted column on a beam
        let selectedBeamForPC = null;       // Beam selected for planted column placement

        // Set active plan tab
        function setPlanTab(tab) {
            currentPlanTab = tab;
            // Update tab buttons
            document.querySelectorAll('.plan-tab').forEach(btn => btn.classList.remove('active'));
            if (tab === 'analysis') {
                document.getElementById('tabAnalysis').classList.add('active');
            } else if (tab === 'structural') {
                document.getElementById('tabStructural').classList.add('active');
            } else if (tab === 'foundation') {
                document.getElementById('tabFoundation').classList.add('active');
            }
            // Redraw canvas
            draw();
            console.log(`v3.0: Switched to ${tab} tab`);
        }

        // Toggle layer visibility
        function toggleLayer(layer) {
            layerVisibility[layer] = !layerVisibility[layer];
            const btn = document.getElementById('layer' + layer.charAt(0).toUpperCase() + layer.slice(1));
            if (btn) {
                btn.classList.toggle('active', layerVisibility[layer]);
            }
            draw();
            console.log(`v3.0: Layer ${layer} = ${layerVisibility[layer]}`);
        }

        const MIN_SPAN = 0.25; // m, guard against zero/negative spans

        function sanitizeSpan(value, fallback = 4.0) {
            const numeric = parseFloat(value);
            if (Number.isFinite(numeric) && numeric > MIN_SPAN) return numeric;
            return fallback;
        }

        // ========== v3.1: COLUMN GRID ALIGNMENT ==========
        // Toggle between centered and outer-aligned edge columns
        function toggleColumnAlignment() {
            if (state.columnAlignment === 'center') {
                state.columnAlignment = 'outer';
            } else {
                state.columnAlignment = 'center';
            }

            // Update button text
            const btn = document.getElementById('colAlignBtn');
            if (btn) {
                if (state.columnAlignment === 'outer') {
                    btn.textContent = '📍 Col: Flush';
                    btn.style.background = 'linear-gradient(135deg, #10b981, #047857)';
                    btn.style.color = 'white';
                    btn.style.borderColor = '#10b981';
                } else {
                    btn.textContent = '📍 Col: Center';
                    btn.style.background = 'transparent';
                    btn.style.color = '#10b981';
                    btn.style.borderColor = '#10b981';
                }
            }

            console.log(`v3.1: Column alignment = ${state.columnAlignment}`);
            draw();
        }

        // ========== CANVAS SETUP ==========
        let canvas, ctx;

        function initCanvas() {
            canvas = document.getElementById('mainCanvas');
            ctx = canvas.getContext('2d');
            resizeCanvas();
            window.addEventListener('resize', resizeCanvas);
            // v2.7: Click on column to toggle active state
            canvas.addEventListener('click', handleCanvasClick);
            // v3.0: Mouseup for beam drawing
            canvas.addEventListener('mouseup', finishBeamDraw);
        }

        function resizeCanvas() {
            const wrapper = canvas.parentElement;
            canvas.width = wrapper.clientWidth;
            canvas.height = wrapper.clientHeight;
            draw();
        }

        // NOTE: handleCanvasClick is defined later (around line 4083) with full functionality
        // including: beam mode, beam deletion, slab void, column context menu, and Shift+Click-to-place

        // v3.0: Finish beam drawing (placeholder for beam draw mode)
        function finishBeamDraw(e) {
            // Beam drawing logic is in draw() - this handles mouseup
            if (!state.addingBeam || !state.beamDrawStart) return;
            // Beam completion logic handled elsewhere
        }

        // ========== SPAN UI ==========
        function renderSpans() {
            renderSpanInputs('x', state.xSpans, 'xSpansContainer');
            renderSpanInputs('y', state.ySpans, 'ySpansContainer');
        }

        function renderSpanInputs(dir, spans, containerId) {
            const container = document.getElementById(containerId);
            container.innerHTML = '';

            spans.forEach((span, i) => {
                const row = document.createElement('div');
                row.className = 'span-row';
                row.innerHTML = `
                    <span style="color:#8b949e;font-size:0.7rem;width:30px;">${dir.toUpperCase()}${i + 1}</span>
                    <input type="number" value="${span}" step="0.5" min="${MIN_SPAN}" max="20"
                           onchange="updateSpan('${dir}', ${i}, this.value)">
                    <button class="remove-btn" onclick="removeSpan('${dir}', ${i})"
                            ${spans.length <= 1 ? 'disabled' : ''}>×</button>
                `;
                container.appendChild(row);
            });
        }

        function updateSpan(dir, index, value) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans[index] = sanitizeSpan(value, spans[index] || 4.0);
            calculate();
        }

        function addSpan(dir) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            spans.push(4.0);
            syncCantileversToSpans();  // v3.0: Keep cantilever arrays in sync
            renderSpans();
            renderCantileverInputs();  // v3.0: Re-render cantilever inputs
            calculate();
        }

        function removeSpan(dir, index) {
            const spans = dir === 'x' ? state.xSpans : state.ySpans;
            if (spans.length > 1) {
                spans.splice(index, 1);
                syncCantileversToSpans();  // v3.0: Keep cantilever arrays in sync
                renderSpans();
                renderCantileverInputs();  // v3.0: Re-render cantilever inputs
                calculate();
            }
        }

        // ========== v3.0: CANTILEVER UI ==========

        // Sync cantilever arrays when spans change
        function syncCantileversToSpans() {
            // Top/Bottom match xSpans length
            while (state.cantilevers.top.length < state.xSpans.length) {
                state.cantilevers.top.push(0);
            }
            while (state.cantilevers.top.length > state.xSpans.length) {
                state.cantilevers.top.pop();
            }
            while (state.cantilevers.bottom.length < state.xSpans.length) {
                state.cantilevers.bottom.push(0);
            }
            while (state.cantilevers.bottom.length > state.xSpans.length) {
                state.cantilevers.bottom.pop();
            }

            // Left/Right match ySpans length
            while (state.cantilevers.left.length < state.ySpans.length) {
                state.cantilevers.left.push(0);
            }
            while (state.cantilevers.left.length > state.ySpans.length) {
                state.cantilevers.left.pop();
            }
            while (state.cantilevers.right.length < state.ySpans.length) {
                state.cantilevers.right.push(0);
            }
            while (state.cantilevers.right.length > state.ySpans.length) {
                state.cantilevers.right.pop();
            }

            // v3.0 FIX: Also sync per-floor cantilever arrays for all floors
            for (const floor of state.floors) {
                if (!floor.cantilevers) continue;

                // Top/Bottom match xSpans length
                while (floor.cantilevers.top.length < state.xSpans.length) floor.cantilevers.top.push(0);
                while (floor.cantilevers.top.length > state.xSpans.length) floor.cantilevers.top.pop();
                while (floor.cantilevers.bottom.length < state.xSpans.length) floor.cantilevers.bottom.push(0);
                while (floor.cantilevers.bottom.length > state.xSpans.length) floor.cantilevers.bottom.pop();

                // Left/Right match ySpans length
                while (floor.cantilevers.left.length < state.ySpans.length) floor.cantilevers.left.push(0);
                while (floor.cantilevers.left.length > state.ySpans.length) floor.cantilevers.left.pop();
                while (floor.cantilevers.right.length < state.ySpans.length) floor.cantilevers.right.push(0);
                while (floor.cantilevers.right.length > state.ySpans.length) floor.cantilevers.right.pop();
            }
        }

        // Render cantilever input fields for all 4 edges
        function renderCantileverInputs() {
            syncCantileversToSpans();

            // Top edge (follows X spans)
            renderCantileverEdge('cantileverTop', 'top', state.xSpans, 'X');
            // Bottom edge (follows X spans)
            renderCantileverEdge('cantileverBottom', 'bottom', state.xSpans, 'X');
            // Left edge (follows Y spans)
            renderCantileverEdge('cantileverLeft', 'left', state.ySpans, 'Y');
            // Right edge (follows Y spans)
            renderCantileverEdge('cantileverRight', 'right', state.ySpans, 'Y');
        }

        function renderCantileverEdge(containerId, edge, spans, axis) {
            const container = document.getElementById(containerId);
            if (!container) return;

            container.innerHTML = '';
            const values = state.cantilevers[edge];

            spans.forEach((span, i) => {
                const inputDiv = document.createElement('div');
                inputDiv.className = 'cantilever-span-input';
                inputDiv.innerHTML = `
                    <span>${axis}${i + 1}</span>
                    <input type="number" value="${values[i] || 0}" step="0.1" min="0" max="5"
                           onchange="updateCantilever('${edge}', ${i}, this.value)"
                           title="Cantilever for ${axis}${i + 1} span (${span}m)">
                `;
                container.appendChild(inputDiv);
            });
        }

        // v3.0: Update cantilever value (Global UI + Per Floor Persistence)
        function updateCantilever(edge, index, value) {

            const numValue = parseFloat(value) || 0;
            const clamped = Math.max(0, Math.min(5, numValue));  // Clamp 0-5m

            // 1. Update Global UI state (what binds to inputs currently)
            state.cantilevers[edge][index] = clamped;

            // 2. Persist to Current Floor
            // This ensures that when we generate loads for this floor, we use these values
            const currentFloor = state.floors[state.currentFloorIndex];
            if (currentFloor) {
                if (!currentFloor.cantilevers) {
                    // Init structure if missing
                    currentFloor.cantilevers = {
                        top: [...state.cantilevers.top],
                        bottom: [...state.cantilevers.bottom],
                        left: [...state.cantilevers.left],
                        right: [...state.cantilevers.right]
                    };
                }
                currentFloor.cantilevers[edge][index] = clamped;
            }

            calculate();
        }

        // ========== v3.1: MEMBER DIMENSIONS TABLE ==========
        // CAD Layers for DXF Export
        const CAD_LAYERS = {
            GRID: 'A-GRID',           // Gridlines
            GRID_BUBBLE: 'A-GRID-IDEN', // Grid bubbles/identifiers
            DIMENSION: 'A-ANNO-DIMS',  // Dimensions
            BEAM: 'S-BEAM',           // Structural beams
            COLUMN: 'S-COLS',         // Structural columns
            SLAB: 'S-SLAB',           // Slab outlines
            TEXT: 'A-ANNO-TEXT'       // General text/labels
        };

        // Update member dimensions from the table and sync with left panel
        function updateMemberDimensions() {
            // Read values from dimension table
            const colB = parseInt(document.getElementById('dimColB')?.value) || 250;
            const colD = parseInt(document.getElementById('dimColD')?.value) || 250;
            const beamB = parseInt(document.getElementById('dimBeamB')?.value) || 250;
            const beamD = parseInt(document.getElementById('dimBeamD')?.value) || 400;

            // Update state
            state.defaultColumnB = colB;
            state.defaultColumnH = colD;
            state.defaultBeamB = beamB;
            state.defaultBeamH = beamD;

            // Sync with left panel inputs (if they exist)
            const colBInput = document.getElementById('columnWidthInput');
            const colDInput = document.getElementById('columnDepthInput');
            const beamBInput = document.getElementById('beamWidthInput');
            const beamDInput = document.getElementById('beamDepthInput');

            if (colBInput) colBInput.value = colB;
            if (colDInput) colDInput.value = colD;
            if (beamBInput) beamBInput.value = beamB;
            if (beamDInput) beamDInput.value = beamD;

            console.log(`v3.1: Member dimensions updated - Col: ${colB}x${colD}, Beam: ${beamB}x${beamD}`);

            // Recalculate to redraw
            calculate();
        }

        // Sync dimension table FROM state (called on load/project load)
        function syncDimensionTable() {
            const dimColB = document.getElementById('dimColB');
            const dimColD = document.getElementById('dimColD');
            const dimBeamB = document.getElementById('dimBeamB');
            const dimBeamD = document.getElementById('dimBeamD');

            if (dimColB) dimColB.value = state.defaultColumnB || 250;
            if (dimColD) dimColD.value = state.defaultColumnH || 250;
            if (dimBeamB) dimBeamB.value = state.defaultBeamB || 250;
            if (dimBeamD) dimBeamD.value = state.defaultBeamH || 400;
        }

        // ========== v2.3: FLOOR TABS UI ==========

        function getFloorId(index, total) {
            if (index === 0) return 'GF';
            if (index === total - 1) return 'RF';
            return `${index + 1}F`;
        }

        function getFloorName(id, isRoof) {
            if (id === 'GF') return 'Ground Floor';
            if (isRoof || id === 'RF') return 'Roof';
            return `${id.replace('F', '')}${['st', 'nd', 'rd'][parseInt(id) - 2] || 'th'} Floor`;
        }

        function renderFloorTabs() {
            const container = document.getElementById('floorTabs');
            container.innerHTML = '';

            state.floors.forEach((floor, i) => {
                const btn = document.createElement('button');
                btn.className = `floor-tab${i === state.currentFloorIndex ? ' active' : ''}${floor.isRoof ? ' roof' : ''}`;
                btn.textContent = floor.id;
                btn.onclick = () => selectFloor(i);
                container.appendChild(btn);
            });

            updateFloorUI();
        }

        function selectFloor(index) {
            state.currentFloorIndex = index;
            renderFloorTabs();

            // v3.0: Recalculate to regenerate slabs with per-floor void data
            calculate();

            // Refresh column table to show this floor's loads
            if (state.columns.length > 0) {
                const currentFloor = state.floors[state.currentFloorIndex];
                const currentSlabWeight = 24 * (currentFloor.slabThickness / 1000);
                const puDisplay = 1.2 * (currentFloor.dlSuper + currentSlabWeight) + 1.6 * currentFloor.liveLoad;

                // Update factored load display
                document.getElementById('factoredLoad').textContent = puDisplay.toFixed(2);

                // Update column table
                updateColumnTable();
            }
        }


        function updateColumnTable() {
            const currentFloor = state.floors[state.currentFloorIndex];
            if (!currentFloor) return;

            // Total per floor (use current selected floor)
            const totalPerFloor = state.columns.reduce((sum, c) => {
                const floorLoad = c.floorLoads.find(f => f.floorId === currentFloor.id);
                return sum + (floorLoad ? floorLoad.load : 0);
            }, 0);
            document.getElementById('totalPerFloor').textContent = totalPerFloor.toFixed(0);

            // Max column (total across all floors)
            const maxCol = state.columns.length
                ? Math.max(...state.columns.map(c => c.totalLoad))
                : 0;
            document.getElementById('maxColumn').textContent = maxCol.toFixed(0);

            // v3.0: Build floor options for dropdown (empty = ground)
            const floorOptions = state.floors.map(f =>
                `<option value="${f.id}">${f.id}</option>`
            ).join('');

            // v3.1: Generate column type IDs based on size (C1, C2, etc.)
            // Columns with same BxD get same type
            const columnTypeMap = new Map();  // key: "BxD" -> type number
            let nextColType = 1;
            state.columns.forEach(col => {
                if (col.active === false) return;
                const b = col.overrideB || col.suggestedB || 250;
                const h = col.overrideH || col.suggestedH || 250;
                const sizeKey = `${b}x${h}`;
                if (!columnTypeMap.has(sizeKey)) {
                    columnTypeMap.set(sizeKey, nextColType++);
                }
            });

            function getColumnTypeId(col) {
                const b = col.overrideB || col.suggestedB || 250;
                const h = col.overrideH || col.suggestedH || 250;
                const sizeKey = `${b}x${h}`;
                return `C${columnTypeMap.get(sizeKey) || 1}`;
            }

            // v3.0: Column table with b×h size, planted column dropdown, and toggle checkbox
            const colBody = document.getElementById('columnResultsBody');
            colBody.innerHTML = state.columns.map(col => {
                const floorLoad = col.floorLoads.find(f => f.floorId === currentFloor.id);
                const thisFloor = floorLoad ? floorLoad.load : 0;
                const footingStr = col.footingSize ? `${col.footingSize.toFixed(1)}×${col.footingSize.toFixed(1)}` : '-';
                // v3.0: Per-floor active state
                const isActiveOnThisFloor = isColumnActiveOnFloor(col, currentFloor.id);
                const isActiveOnAnyFloor = col.active !== false;
                // v3.0: Show column size as b×h
                const colSizeStr = col.suggestedB && col.suggestedH
                    ? `${col.suggestedB}×${col.suggestedH}` : '-';
                // v3.0: Planted column indicator
                const isPlanted = col.startFloor ? true : false;
                // v3.0: Partial indicator - active on some floors but not this one
                const isPartial = isActiveOnAnyFloor && !isActiveOnThisFloor;
                // v3.0: Get column type for THIS floor (not global)
                const colType = getColumnTypeForFloor(col, currentFloor.id);
                // v3.1: Get column type ID (C1, C2 based on size)
                const colTypeId = isActiveOnAnyFloor ? getColumnTypeId(col) : '-';
                // v3.0: Calculate breakdown totals
                let totalSlabLoad = 0, totalBeamDL = 0;
                col.floorLoads.forEach(fl => {
                    totalSlabLoad += (fl.slabLoad || 0);
                    totalBeamDL += (fl.beamDL || 0);
                });
                const colDL = col.columnDL || 0;
                const tieBeamDL = col.tieBeamDL || 0;
                const footingDL = col.footingDL || 0;

                // v3.0: Breakdown tooltip text
                const breakdownText = `LOAD BREAKDOWN for ${col.id}:
━━━━━━━━━━━━━━━━
📦 Slab+LL:    ${totalSlabLoad.toFixed(1)} kN
📏 Beam DL:    ${totalBeamDL.toFixed(1)} kN
🏛️ Column DL:  ${colDL.toFixed(1)} kN
🔗 Tie Beam:   ${tieBeamDL.toFixed(1)} kN
🧱 Footing:    ${footingDL.toFixed(1)} kN
━━━━━━━━━━━━━━━━
📊 TOTAL:      ${(col.totalLoadWithDL || col.totalLoad).toFixed(1)} kN`;

                return `
        <tr style="${!isActiveOnThisFloor ? 'opacity:0.4;text-decoration:line-through;' : ''} ${isPlanted ? 'background:rgba(249,115,22,0.1);' : ''} ${isPartial ? 'background:rgba(59,130,246,0.1);' : ''}">
            <td style="text-align:center;" title="Toggle column on ${currentFloor.id} only">
                <input type="checkbox" ${isActiveOnThisFloor ? 'checked' : ''} onchange="toggleColumn('${col.id}')" style="cursor:pointer;width:16px;height:16px;">
            </td>
            <td><strong style="color:#00d4ff;">${colTypeId}-${col.id}</strong></td>
            <td style="color:${colType === 'corner' ? '#f59e0b' : colType === 'edge' ? '#00d4ff' : '#10b981'}">${colType}</td>
            <td>
                <select onchange="setColumnStartFloor('${col.id}', this.value)" style="padding:2px;font-size:0.65rem;background:#1a1f2e;color:#fff;border:1px solid ${isPlanted ? '#f97316' : '#444'};border-radius:4px;width:50px;">
                    <option value="" ${!col.startFloor ? 'selected' : ''}>GND</option>
                    ${state.floors.map(f =>
                    `<option value="${f.id}" ${col.startFloor === f.id ? 'selected' : ''}>${f.id}</option>`
                ).join('')}
                </select>
            </td>
            <td>${isActiveOnThisFloor ? thisFloor.toFixed(1) : '-'}</td>
            <td><strong>${isActiveOnAnyFloor ? col.totalLoad.toFixed(1) : '-'}</strong></td>
            <td style="text-align:center;">
                ${isActiveOnAnyFloor ? `<button onclick="alert('${breakdownText.replace(/'/g, "\\'")}');" style="cursor:pointer;background:transparent;border:1px solid #00d4ff;color:#00d4ff;border-radius:4px;padding:2px 6px;font-size:0.6rem;" title="Click for load breakdown">📊</button>` : '-'}
            </td>
            <td style="color:#10b981;">
                ${isActiveOnAnyFloor ? `
                <input type="number" value="${col.overrideB || col.suggestedB || ''}" min="150" max="800" step="50"
                       style="width:35px;padding:1px;font-size:0.6rem;background:#1a1f2e;color:#10b981;border:1px solid ${col.overrideB ? '#10b981' : '#444'};border-radius:3px;font-weight:bold;"
                       onchange="setColumnSize('${col.id}', 'b', this.value)" title="Column width (mm)">×
                <input type="number" value="${col.overrideH || col.suggestedH || ''}" min="150" max="800" step="50"
                       style="width:35px;padding:1px;font-size:0.6rem;background:#1a1f2e;color:#10b981;border:1px solid ${col.overrideH ? '#10b981' : '#444'};border-radius:3px;font-weight:bold;"
                       onchange="setColumnSize('${col.id}', 'h', this.value)" title="Column depth (mm)">
                ` : '-'}
            </td>
            <td style="color:#8b5cf6">${isActiveOnAnyFloor && !isPlanted ? footingStr : (isPlanted ? '<span style="color:#f97316">planted</span>' : '-')}</td>
        </tr>
    `;
            }).join('');

            // v3.0: Also update summary panel
            updateLoadSummary();
        }

        // v3.0: Update load summary panel with totals
        function updateLoadSummary() {
            let sumSlabDL = 0, sumLL = 0, sumBeamDL = 0, sumColDL = 0, sumTieBeamDL = 0, sumFootingDL = 0;

            // Calculate slab area and loads
            const numFloors = state.floors.length;
            const slabArea = state.slabs.reduce((sum, s) => {
                if (s.isVoid || s.isCantilever) return sum;
                return sum + (Math.abs(s.x2 - s.x1) * Math.abs(s.y2 - s.y1));
            }, 0);

            // Slab DL = area × thickness × concrete density × floors × 1.2 factor
            const slabThickM = (state.slabThickness || 150) / 1000;
            sumSlabDL = slabArea * slabThickM * (state.concreteDensity || 24) * numFloors * 1.2;

            // LL = area × LL intensity × floors × 1.6 factor
            sumLL = slabArea * (state.LL || 2.0) * numFloors * 1.6;

            // Sum from columns
            state.columns.forEach(col => {
                if (col.active === false) return;
                sumColDL += (col.columnDL || 0);
                sumTieBeamDL += (col.tieBeamDL || 0);
                sumFootingDL += (col.footingDL || 0);
            });

            // Sum beam DL
            sumBeamDL = (state.totalBeamSelfWeight || 0) * numFloors * 1.2;

            // Update UI
            const fmt = (v) => v > 0 ? v.toFixed(0) + ' kN' : '-';
            document.getElementById('sumSlabDL').textContent = fmt(sumSlabDL);
            document.getElementById('sumLL').textContent = fmt(sumLL);
            document.getElementById('sumBeamDL').textContent = fmt(sumBeamDL);
            document.getElementById('sumColDL').textContent = fmt(sumColDL);
            document.getElementById('sumTieBeamDL').textContent = fmt(sumTieBeamDL);
            document.getElementById('sumFootingDL').textContent = fmt(sumFootingDL);

            const grandTotal = sumSlabDL + sumLL + sumBeamDL + sumColDL + sumTieBeamDL + sumFootingDL;
            document.getElementById('grandTotal').textContent = grandTotal.toFixed(0) + ' kN';
        }


        // v3.0: Helper - Check if floorId is at or above startFloor
        // Used for planted columns (columns that start above ground)
        function isFloorAtOrAbove(floorId, startFloor) {
            const floorIdx = state.floors.findIndex(f => f.id === floorId);
            const startIdx = state.floors.findIndex(f => f.id === startFloor);
            // Higher index = higher floor (GF=0, 2F=1, RF=2)
            return floorIdx >= startIdx;
        }

        // v2.7: Toggle column active state (for L/U layouts)
        // v3.0: Now per-floor - toggling on RF doesn't affect 2F
        function toggleColumn(colId, floorId = null) {
            const col = state.columns.find(c => c.id === colId);
            if (!col) return;

            // Use current floor if not specified
            const targetFloor = floorId || state.floors[state.currentFloorIndex].id;

            // Initialize activePerFloor if not exists (migrate from old boolean)
            if (!col.activePerFloor) {
                col.activePerFloor = {};
                state.floors.forEach(f => {
                    col.activePerFloor[f.id] = col.active !== false;
                });
            }

            // Toggle for this specific floor
            col.activePerFloor[targetFloor] = !col.activePerFloor[targetFloor];

            // Update legacy active flag (true if active on ANY floor)
            col.active = Object.values(col.activePerFloor).some(v => v);

            console.log(`v3.0: Column ${colId} toggled on ${targetFloor}: ${col.activePerFloor[targetFloor] ? 'ON' : 'OFF'}`);

            calculate();  // Recalculate loads
            recalculateColumnTypes(targetFloor); // v3.0: Recalculate for THIS floor specifically
            render3DFrame();  // Re-render 3D
        }

        // v3.0: Check if column is active on a specific floor
        function isColumnActiveOnFloor(col, floorId) {
            if (!col) return false;

            // v3.0 FIX: Planted columns are inactive on floors BELOW their startFloor
            if (col.startFloor || col.isPlanted) {
                const startFloorId = col.startFloor;
                if (startFloorId && !isFloorAtOrAbove(floorId, startFloorId)) {
                    return false;  // Column doesn't exist on floors below startFloor
                }
            }

            if (col.activePerFloor) {
                return col.activePerFloor[floorId] !== false;
            }
            return col.active !== false;
        }

        // v3.2: Update tie beam size from input controls
        function updateTieBeamSize() {
            const widthInput = document.getElementById('tieBeamWidth');
            const depthInput = document.getElementById('tieBeamDepth');

            state.tieBeamWidth = parseInt(widthInput.value) || 200;
            state.tieBeamDepth = parseInt(depthInput.value) || 350;

            // Enforce minimums (NBC code)
            if (state.tieBeamWidth < 200) {
                state.tieBeamWidth = 200;
                widthInput.value = 200;
            }
            if (state.tieBeamDepth < 350) {
                state.tieBeamDepth = 350;
                depthInput.value = 350;
            }

            console.log(`v3.2: Tie beam size updated: ${state.tieBeamWidth}×${state.tieBeamDepth}mm`);
            draw();
        }

        // v3.2: Update footing schedule table
        function updateFootingSchedule() {
            const tbody = document.getElementById('footingScheduleBody');
            if (!tbody) return;

            // Get columns with footings (non-planted or ground-floor planted)
            const footingColumns = state.columns.filter(col => {
                if (col.active === false) return false;
                if (col.startFloor && col.startFloor !== 'GND' && col.startFloor !== '1F') return false;
                return true;
            });

            // Group by footing size (similar columns get same footing type)
            const footingTypes = {};
            footingColumns.forEach(col => {
                const size = col.footingSize || 1.0;
                const sizeKey = size.toFixed(2);
                if (!footingTypes[sizeKey]) {
                    footingTypes[sizeKey] = {
                        size: size,
                        count: 0,
                        typeId: `F${Object.keys(footingTypes).length + 1}`,
                        columns: []
                    };
                }
                footingTypes[sizeKey].count++;
                footingTypes[sizeKey].columns.push(col.id);
            });

            // Build schedule rows
            let html = '';
            Object.values(footingTypes).forEach(ft => {
                // v3.2: Fixed 300mm thickness for all footings (NSCP/NBC minimum)
                const depthMm = 300;

                html += `
                    <tr>
                        <td><strong style="color:#10b981;">${ft.typeId}</strong></td>
                        <td style="font-size:0.6rem;color:#94a3b8;">${ft.columns.slice(0, 3).join(', ')}${ft.columns.length > 3 ? '...' : ''}</td>
                        <td>${ft.size.toFixed(2)}×${ft.size.toFixed(2)}</td>
                        <td>${depthMm}</td>
                    </tr>
                `;
            });

            tbody.innerHTML = html || '<tr><td colspan="4" style="text-align:center;color:#8b949e;">No footings</td></tr>';
        }

        // v3.0: Set column start floor (for planted columns)
        function setColumnStartFloor(colId, floorId) {
            const col = state.columns.find(c => c.id === colId);
            if (col) {
                col.startFloor = floorId || null;  // null = from ground
                calculate();  // Recalculate with new start floor
                render3DFrame();  // Re-render 3D
                console.log(`v3.0: Column ${colId} planted at ${floorId || 'Ground'}`);
            }
        }

        // v3.0: Set column size override (manual b×h)
        function setColumnSize(colId, dim, value) {
            const col = state.columns.find(c => c.id === colId);
            if (col) {
                const numValue = parseInt(value) || 0;
                // Round to nearest 50mm
                const roundedValue = Math.round(numValue / 50) * 50;
                const clampedValue = Math.max(150, Math.min(800, roundedValue));

                if (dim === 'b') {
                    col.overrideB = clampedValue > 0 ? clampedValue : null;
                    col.suggestedB = clampedValue;  // Update displayed value
                } else {
                    col.overrideH = clampedValue > 0 ? clampedValue : null;
                    col.suggestedH = clampedValue;
                }

                console.log(`v3.0: Column ${colId} size override: ${col.suggestedB}×${col.suggestedH}mm`);

                // Recalculate footings with new column size (affects self-weight)
                calculateFootingSizes();
                updateColumnTable();
                draw();  // v3.2: Refresh structural plan with new column size
                render3DFrame();
            }
        }

        // v3.0: Set beam size override (manual b×h)
        function setBeamSize(beamId, dim, value) {
            const beam = state.beams.find(b => b.id === beamId);
            if (beam) {
                const numValue = parseInt(value) || 0;
                // Round to nearest 50mm
                const roundedValue = Math.round(numValue / 50) * 50;

                if (dim === 'b') {
                    const clampedValue = Math.max(200, Math.min(500, roundedValue));
                    beam.overrideB = clampedValue > 0 ? clampedValue : null;
                    beam.suggestedB = clampedValue;
                } else {
                    const clampedValue = Math.max(300, Math.min(800, roundedValue));
                    beam.overrideH = clampedValue > 0 ? clampedValue : null;
                    beam.suggestedH = clampedValue;
                }

                // Recalculate beam self-weight with new dimensions
                beam.selfWeight = (beam.suggestedB / 1000) * (beam.suggestedH / 1000) * beam.span * state.concreteDensity;

                console.log(`v3.0: Beam ${beamId} size override: ${beam.suggestedB}×${beam.suggestedH}mm`);

                // Recalculate column loads (beam self-weight affects columns)
                calculate();
            }
        }

        // v3.0: Update slab openings table in results panel
        function updateSlabOpeningsTable() {
            const tbody = document.getElementById('slabOpeningsBody');
            if (!tbody) return;

            tbody.innerHTML = state.slabs.map(slab => {
                const openingW = slab.openingW || 0;
                const openingH = slab.openingH || 0;
                const openingArea = openingW * openingH;
                const netArea = slab.area - openingArea;
                const hasOpening = openingArea > 0;

                return `
                <tr style="${hasOpening ? 'background:rgba(239,68,68,0.1);' : ''}">
                    <td><strong>${slab.id}</strong></td>
                    <td style="font-size:0.65rem;">${slab.lx.toFixed(1)}×${slab.ly.toFixed(1)}</td>
                    <td>
                        <input type="number" value="${openingW}" step="0.1" min="0" max="${slab.lx}" 
                               style="width:40px;padding:2px;font-size:0.65rem;background:#1a1f2e;color:#fff;border:1px solid ${hasOpening ? '#ef4444' : '#444'};border-radius:3px;"
                               onchange="setSlabOpening('${slab.id}', 'w', this.value)">×
                        <input type="number" value="${openingH}" step="0.1" min="0" max="${slab.ly}"
                               style="width:40px;padding:2px;font-size:0.65rem;background:#1a1f2e;color:#fff;border:1px solid ${hasOpening ? '#ef4444' : '#444'};border-radius:3px;"
                               onchange="setSlabOpening('${slab.id}', 'h', this.value)">
                    </td>
                    <td style="color:${hasOpening ? '#ef4444' : '#10b981'}">${netArea.toFixed(1)} m²</td>
                </tr>
            `;
            }).join('');
        }

        // v3.0: Set opening dimension for a slab
        function setSlabOpening(slabId, dim, value) {
            const slab = state.slabs.find(s => s.id === slabId);
            if (slab) {
                const numValue = parseFloat(value) || 0;
                if (dim === 'w') {
                    slab.openingW = Math.min(numValue, slab.lx * 0.9);  // Max 90% of slab width
                } else {
                    slab.openingH = Math.min(numValue, slab.ly * 0.9);  // Max 90% of slab height
                }
                // Recalculate net area
                slab.netArea = slab.area - (slab.openingW || 0) * (slab.openingH || 0);
                console.log(`v3.0: Slab ${slabId} opening set to ${slab.openingW}×${slab.openingH}m (net: ${slab.netArea.toFixed(1)}m²)`);

                // Recalculate loads with new net areas
                calculate();
            }
        }

        // v2.7: Recalculate column types based on ACTIVE columns only
        // This identifies new corners/edges when columns are disabled (for L/U shapes)
        // v3.0: Recalculate column types (corner/edge/interior) for a specific floor
        function recalculateColumnTypes(floorId = null) {
            // Use current floor if not specified
            const targetFloorId = floorId || state.floors[state.currentFloorIndex]?.id;
            const maxXi = Math.max(...state.columns.map(c => c.xi));
            const maxYi = Math.max(...state.columns.map(c => c.yi));

            // v3.0: Helper uses per-floor active state - returns BOOLEAN
            function hasActiveAt(xi, yi) {
                const col = state.columns.find(c => c.xi === xi && c.yi === yi);
                if (!col) return false;  // v3.0: Explicitly return false for out-of-bounds
                return isColumnActiveOnFloor(col, targetFloorId);
            }

            for (let col of state.columns) {
                // v3.0: Skip if column is inactive on this floor
                if (!isColumnActiveOnFloor(col, targetFloorId)) continue;

                const { xi, yi } = col;

                // Count active neighbors in each direction
                const hasLeft = hasActiveAt(xi - 1, yi);
                const hasRight = hasActiveAt(xi + 1, yi);
                const hasUp = hasActiveAt(xi, yi - 1);
                const hasDown = hasActiveAt(xi, yi + 1);

                // Also check diagonals for re-entrant corner detection
                const hasUpLeft = hasActiveAt(xi - 1, yi - 1);
                const hasUpRight = hasActiveAt(xi + 1, yi - 1);
                const hasDownLeft = hasActiveAt(xi - 1, yi + 1);
                const hasDownRight = hasActiveAt(xi + 1, yi + 1);

                const horizNeighbors = (hasLeft ? 1 : 0) + (hasRight ? 1 : 0);
                const vertNeighbors = (hasUp ? 1 : 0) + (hasDown ? 1 : 0);
                const totalNeighbors = horizNeighbors + vertNeighbors;

                // Determine column type based on orthogonal neighbors ONLY
                // Diagonal gaps don't make a column a corner - structural load still goes through orthogonal neighbors

                // v3.0: Initialize typePerFloor if not exists
                if (!col.typePerFloor) col.typePerFloor = {};

                let newType = 'interior';
                if (totalNeighbors === 4) {
                    // Has neighbors on all 4 sides = always interior
                    newType = 'interior';
                } else if (totalNeighbors === 3) {
                    // Missing 1 orthogonal neighbor = edge column
                    newType = 'edge';
                } else if (totalNeighbors === 2) {
                    // Check if L-shape (corner) or in-line (edge)
                    const isLShape = (hasLeft && hasUp) || (hasLeft && hasDown) ||
                        (hasRight && hasUp) || (hasRight && hasDown);
                    newType = isLShape ? 'corner' : 'edge';
                } else {
                    // 0 or 1 neighbor = corner (edge case)
                    newType = 'corner';
                }

                // v3.0: Store type per floor AND update global type for current floor
                col.typePerFloor[targetFloorId] = newType;
                col.type = newType;  // Also update global for backward compatibility
            }
        }

        // v3.0: Get column type for a specific floor
        function getColumnTypeForFloor(col, floorId) {
            if (!col) return 'interior';
            if (col.typePerFloor && col.typePerFloor[floorId]) {
                return col.typePerFloor[floorId];
            }
            return col.type || 'interior';
        }

        function updateFloorUI() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;

            document.getElementById('currentFloorName').textContent = floor.name;
            document.getElementById('floorTypeBadge').textContent = floor.isRoof ? 'Roof' : 'Typical';
            document.getElementById('floorTypeBadge').className = `floor-type-badge${floor.isRoof ? ' roof' : ''}`;

            document.getElementById('floorDL').value = floor.dlSuper;
            document.getElementById('floorLL').value = floor.liveLoad;
            document.getElementById('floorSlabThickness').value = floor.slabThickness;
            document.getElementById('floorHeight').value = floor.height;
            document.getElementById('floorWallLoad').value = floor.wallLoad || 0;
        }

        function updateCurrentFloor() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;

            floor.dlSuper = parseFloat(document.getElementById('floorDL').value) || 2.0;
            floor.liveLoad = parseFloat(document.getElementById('floorLL').value) || 2.0;
            floor.slabThickness = parseFloat(document.getElementById('floorSlabThickness').value) || 150;
            floor.height = parseFloat(document.getElementById('floorHeight').value) || 3.0;
            floor.wallLoad = parseFloat(document.getElementById('floorWallLoad').value) || 0;

            calculate();
        }

        // v2.6: Toggle GF suspended slab
        // v2.7: Now dynamically adds/removes GF from floors array
        function toggleGFSuspended() {
            state.gfSuspended = document.getElementById('gfSuspended').checked;

            // Show/hide elevation height dropdown
            const elevSection = document.getElementById('elevationSection');
            if (elevSection) {
                elevSection.style.display = state.gfSuspended ? 'block' : 'none';
            }

            // v2.7: Add or remove GF floor from array
            const hasGF = state.floors.some(f => f.id === 'GF');

            if (state.gfSuspended && !hasGF) {
                // Add GF at the start with per-floor arrays
                const elevHeight = parseFloat(document.getElementById('elevationHeight')?.value) || 1.2;
                const numX = state.xSpans.length;
                const numY = state.ySpans.length;
                state.floors.unshift({
                    id: 'GF',
                    name: 'Ground Floor',
                    dlSuper: 2.0,
                    liveLoad: 2.0,
                    slabThickness: 150,
                    height: elevHeight,
                    isRoof: false,
                    // v3.0 FIX: Per-floor arrays
                    cantilevers: { top: new Array(numX).fill(0), bottom: new Array(numX).fill(0), left: new Array(numY).fill(0), right: new Array(numY).fill(0) },
                    customBeams: [],
                    voidSlabs: [],
                    deletedBeams: []
                });
                state.currentFloorIndex = 0;
            } else if (!state.gfSuspended && hasGF) {
                // Remove GF from the start
                state.floors.shift();
                state.currentFloorIndex = 0;
            }

            renderFloorTabs();
            calculate();
        }

        // v2.6: Apply NSCP preset DL/LL values
        const NSCP_PRESETS = {
            residential: { dlSuper: 1.5, liveLoad: 1.9, roofLL: 1.0, name: 'Residential' },
            residential_heavy: { dlSuper: 2.0, liveLoad: 2.4, roofLL: 1.0, name: 'Residential (Heavy)' },
            office: { dlSuper: 2.0, liveLoad: 2.4, roofLL: 1.0, name: 'Office' },
            commercial: { dlSuper: 2.5, liveLoad: 4.8, roofLL: 1.5, name: 'Commercial/Retail' },
            school: { dlSuper: 2.0, liveLoad: 4.8, roofLL: 1.0, name: 'School/Assembly' },
            hospital: { dlSuper: 2.5, liveLoad: 3.8, roofLL: 1.0, name: 'Hospital' }
        };

        function applyNSCPPreset() {
            const type = document.getElementById('buildingType').value;
            const preset = NSCP_PRESETS[type];
            if (!preset) return;

            // Apply to all floors
            for (let floor of state.floors) {
                floor.dlSuper = preset.dlSuper;
                floor.liveLoad = floor.isRoof ? preset.roofLL : preset.liveLoad;
            }

            // Update current floor UI
            updateFloorUI();
            calculate();
        }

        function addFloor() {
            const total = state.floors.length;
            // Insert before roof (last)
            const insertIndex = total > 0 && state.floors[total - 1].isRoof ? total - 1 : total;

            // Rename existing floors
            state.floors.forEach((f, i) => {
                if (i < insertIndex && !f.isRoof && f.id !== 'GF') {
                    // Keep as is
                }
            });

            // v3.0 FIX: Initialize per-floor arrays for cantilevers, customBeams, voidSlabs
            const numX = state.xSpans.length;
            const numY = state.ySpans.length;
            const newFloor = {
                id: `${insertIndex + 1}F`,
                name: `${insertIndex + 1}${['st', 'nd', 'rd'][insertIndex - 1] || 'th'} Floor`,
                dlSuper: 2.0,
                liveLoad: 2.0,
                slabThickness: 150,
                height: 3.0,
                isRoof: false,
                // v3.0 FIX: Per-floor cantilevers (start with zeros - no cantilevers)
                cantilevers: {
                    top: new Array(numX).fill(0),
                    bottom: new Array(numX).fill(0),
                    left: new Array(numY).fill(0),
                    right: new Array(numY).fill(0)
                },
                customBeams: [],
                voidSlabs: [],
                deletedBeams: []
            };

            state.floors.splice(insertIndex, 0, newFloor);

            // Update IDs for all floors
            state.floors.forEach((f, i) => {
                if (i === 0) {
                    f.id = 'GF';
                    f.name = 'Ground Floor';
                } else if (i === state.floors.length - 1 && f.isRoof) {
                    f.id = 'RF';
                    f.name = 'Roof';
                } else {
                    f.id = `${i + 1}F`;
                    f.name = `${i + 1}${['st', 'nd', 'rd'][i - 1] || 'th'} Floor`;
                }
            });

            renderFloorTabs();
            calculate();
        }

        function removeFloor() {
            if (state.floors.length <= 2) return; // Keep at least GF + RF

            // Remove the currently selected floor (unless it's GF or RF)
            const floor = state.floors[state.currentFloorIndex];
            if (floor.id === 'GF' || floor.isRoof) {
                // Can't remove GF or RF, remove the last typical floor instead
                const lastTypical = state.floors.findLastIndex(f => !f.isRoof && f.id !== 'GF');
                if (lastTypical > 0) {
                    state.floors.splice(lastTypical, 1);
                }
            } else {
                state.floors.splice(state.currentFloorIndex, 1);
            }

            // Clamp current floor index
            if (state.currentFloorIndex >= state.floors.length) {
                state.currentFloorIndex = state.floors.length - 1;
            }

            // Rename remaining floors
            state.floors.forEach((f, i) => {
                if (i === 0) {
                    f.id = 'GF';
                    f.name = 'Ground Floor';
                } else if (f.isRoof) {
                    f.id = 'RF';
                    f.name = 'Roof';
                } else {
                    f.id = `${i + 1}F`;
                    f.name = `${i + 1}${['st', 'nd', 'rd'][i - 1] || 'th'} Floor`;
                }
            });

            renderFloorTabs();
            calculate();
        }

        // ========== CORE CALCULATIONS ==========

        /**
         * Main calculation function
         * Implements: SLAB → BEAMS → COLUMNS load path
         * v2.3: Calculates per-floor and cumulative across all floors
         */
        function calculate() {
            // Clean spans to avoid zero/negative values
            state.xSpans = state.xSpans.map(span => sanitizeSpan(span));
            state.ySpans = state.ySpans.map(span => sanitizeSpan(span));

            // Step 1: Generate grid coordinates
            generateGrid();

            // Step 2: Generate slab panels (MOVED inside loop for per-floor logic)
            // generateSlabs();

            // Reset cumulative column loads
            for (let col of state.columns) {
                col.loadPerFloor = 0;
                col.totalLoad = 0;
                col.floorLoads = [];
            }

            // v2.3: Calculate loads for each floor
            let totalPuSum = 0;
            for (let floor of state.floors) {
                // v2.6: Skip GF if not suspended (ground-bearing slab)
                if (floor.id === 'GF' && !state.gfSuspended) {
                    // Store 0 load for GF to keep array consistent
                    for (let col of state.columns) {
                        col.floorLoads.push({ floorId: floor.id, load: 0 });
                    }
                    continue;
                }

                // Calculate factored load for this floor
                const slabWeight = 24 * (floor.slabThickness / 1000); // kN/m² = kPa
                const pu = 1.2 * (floor.dlSuper + slabWeight) + 1.6 * floor.liveLoad;
                const wallLoad = floor.wallLoad || 0;  // v3.0: Wall load (kN/m)
                totalPuSum += pu;

                // v3.0: Mock global cantilevers to be floor-specific for generation
                const globalCants = state.cantilevers;
                state.cantilevers = getCantilevers(floor.id);

                // v3.0: Generate slabs and beams specific to THIS floor
                generateSlabs(floor.id);
                generateBeams(pu, wallLoad, floor);

                // Step 5: Calculate beam reactions
                calculateBeamReactions();

                // Step 6: Add reactions to columns for this floor
                calculateColumnLoadsForFloor(floor.id);

                // Restore global cantilevers
                state.cantilevers = globalCants;
            }

            // Average pu for display (or use current floor's pu)
            const currentFloor = state.floors[state.currentFloorIndex];
            const currentSlabWeight = 24 * (currentFloor.slabThickness / 1000);
            const puDisplay = 1.2 * (currentFloor.dlSuper + currentSlabWeight) + 1.6 * currentFloor.liveLoad;

            // v2.5: Read footing parameters
            state.footingDepth = parseFloat(document.getElementById('footingDepth').value) || 1.5;
            state.soilBearing = parseFloat(document.getElementById('soilBearing').value) || 150;

            // v3.0: Size all columns and beams FIRST (needed for self-weight calc)
            sizeMembers();

            // v3.0: Calculate footing sizes (includes column/beam/tie beam DL)
            calculateFootingSizes();

            // Update UI
            updateResults(puDisplay);

            // v3.0: Final regeneration for display (Current Floor)
            // This ensures what we see matches the selected floor tab
            const displayCants = state.cantilevers; // UI state
            state.cantilevers = getCantilevers(currentFloor.id);
            generateSlabs(currentFloor.id);
            generateBeams(puDisplay, currentFloor.wallLoad || 0); // Use display PU
            state.cantilevers = displayCants; // Restore UI state

            draw();

            // v3.0: Update concrete volume summary
            updateConcreteVolume();
        }

        /**
         * v3.0: Calculate footing sizes based on total column load
         * Now includes: slab loads + beam DL + column DL + tie beam DL
         * Simple formula: A_req = P / q_allow
         */
        function calculateFootingSizes() {
            const q = state.soilBearing; // kPa
            const numFloors = state.floors.length;
            const floorHeight = state.floors[0]?.height || 3.0;
            const footingDepth = state.footingDepth || 1.5;

            // v2.8: Calculate uniform tie beam sizing from longest span
            const longestSpan = Math.max(...state.xSpans, ...state.ySpans);
            state.tieBeamH = Math.max(0.3, Math.ceil(longestSpan / 10 * 20) / 20);
            state.tieBeamW = 0.25;

            // v3.0: Calculate tie beam DL per column
            // Each column has avg 2 tie beams connecting to it (simplified)
            // Tie beam length approximated as average span
            const avgSpan = (state.xSpans.reduce((a, b) => a + b, 0) + state.ySpans.reduce((a, b) => a + b, 0)) /
                (state.xSpans.length + state.ySpans.length);
            const tieBeamVolume = state.tieBeamW * state.tieBeamH * avgSpan;  // m³ per beam
            const tieBeamWeight = tieBeamVolume * state.concreteDensity;      // kN per beam
            const tieBeamDLPerColumn = tieBeamWeight * 1.2;  // Factored, shared contribution

            for (let col of state.columns) {
                if (col.active === false) {
                    col.footingSize = 0;
                    col.footingThick = 0;
                    continue;
                }

                // v3.0: Planted columns don't get footings (load goes to transfer beam)
                if (col.startFloor) {
                    col.footingSize = 0;
                    col.footingThick = 0;
                    col.isPlanted = true;
                    continue;
                }

                // v3.0: Add column self-weight for all floors
                // Use suggestedB/H if available, else estimate 250×250
                const colB = (col.suggestedB || 250) / 1000;  // m
                const colH = (col.suggestedH || 250) / 1000;  // m
                const colVolume = colB * colH * floorHeight;  // m³ per floor
                const colDL = colVolume * state.concreteDensity * numFloors * 1.2;  // Factored

                // Total load includes: slab+beam (from floors) + column DL + tie beam DL
                const totalFactored = col.totalLoad + colDL + tieBeamDLPerColumn;
                col.totalLoadWithDL = totalFactored;  // Store for display

                // Use unfactored load for footing sizing (service load)
                const P_service = totalFactored / 1.4; // kN

                // Required area
                const A_req = P_service / q; // m²

                // Square footing side (round to 0.1m, min 0.6m)
                let side = Math.sqrt(A_req);
                side = Math.max(0.6, Math.ceil(side * 10) / 10);

                // Thickness estimate (simple: h = side/4, min 0.3m)
                let thick = Math.max(0.3, Math.round(side / 4 * 10) / 10);

                col.footingSize = side;      // m
                col.footingThick = thick;    // m
                col.columnDL = colDL;        // kN (for breakdown)
                col.tieBeamDL = tieBeamDLPerColumn;  // kN (for breakdown)

                // v3.0: Footing self-weight (factored)
                const footingVolume = side * side * thick;  // m³
                col.footingDL = footingVolume * state.concreteDensity * 1.2;  // kN factored
            }

            console.log(`v3.0: Self-weight included - Column DL + Tie beam DL added to footings`);
            console.log(`v3.0: Tie beam sizing - ${(state.tieBeamW * 1000).toFixed(0)}×${(state.tieBeamH * 1000).toFixed(0)}mm`);
        }

        /**
         * v3.0: Check if current floor is at or above the start floor
         * Used for planted columns that don't go to ground
         * @param {string} currentFloorId - The floor being calculated
         * @param {string} startFloorId - The column's starting floor
         * @returns {boolean} true if column exists at this floor
         */
        function isFloorAtOrAbove(currentFloorId, startFloorId) {
            const floorIds = state.floors.map(f => f.id);
            const currentIdx = floorIds.indexOf(currentFloorId);
            const startIdx = floorIds.indexOf(startFloorId);
            // Higher index = higher floor (GF=0, 2F=1, RF=2)
            return currentIdx >= startIdx;
        }

        /**
         * Calculate column loads for a specific floor
         * v3.0: Includes beam reactions AND beam self-weight DL
         * v3.0: Skip planted columns for floors below their startFloor
         * v3.0: Skip columns that are not active on this specific floor
         */
        function calculateColumnLoadsForFloor(floorId) {
            for (let col of state.columns) {
                // v3.0: Skip if column is planted and doesn't exist at this floor
                if (col.startFloor && !isFloorAtOrAbove(floorId, col.startFloor)) {
                    col.floorLoads.push({ floorId, load: 0, isPlanted: true });
                    continue;  // Don't add any load for this floor
                }

                // v3.0: Skip if column is not active on this specific floor
                if (!isColumnActiveOnFloor(col, floorId)) {
                    col.floorLoads.push({ floorId, load: 0, isInactive: true });
                    continue;  // Column removed on this floor
                }

                let floorLoad = 0;
                let beamDL = 0;  // v3.0: Beam self-weight contribution
                for (let beam of state.beams) {
                    // Beam reactions (from slab loads)
                    if (beam.startCol === col.id) floorLoad += beam.Rleft;
                    if (beam.endCol === col.id) floorLoad += beam.Rright;

                    // v3.0: Beam self-weight (half to each end)
                    // selfWeight is total kN, factor by 1.2 for DL
                    if (beam.selfWeight) {
                        const halfWeight = beam.selfWeight / 2 * 1.2;  // Factored
                        if (beam.startCol === col.id) beamDL += halfWeight;
                        if (beam.endCol === col.id) beamDL += halfWeight;
                    }
                }
                const totalFloorLoad = floorLoad + beamDL;
                col.floorLoads.push({ floorId, load: totalFloorLoad, slabLoad: floorLoad, beamDL: beamDL });
                col.totalLoad += totalFloorLoad;
                col.loadPerFloor = totalFloorLoad;
            }
        }

        /**
         * Step 1: Generate grid from spans
         * Creates absolute coordinates for column positions
         */
        function generateGrid() {
            // Build X coordinates
            const xCoords = [0];
            for (let span of state.xSpans) {
                xCoords.push(xCoords[xCoords.length - 1] + span);
            }

            // Build Y coordinates
            const yCoords = [0];
            for (let span of state.ySpans) {
                yCoords.push(yCoords[yCoords.length - 1] + span);
            }

            // Generate columns at intersections
            // v2.7: Preserve active state from existing columns
            const oldColumns = state.columns || [];

            // v3.0: Preserve custom-placed planted columns (not at grid intersections)
            const plantedColumns = oldColumns.filter(c => c.isPlanted === true);

            state.columns = [];
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ'; // Skip I and O

            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < xCoords.length; xi++) {
                    const id = `${letters[xi]}${yi + 1}`;

                    // Determine column type
                    const isCorner = (xi === 0 || xi === xCoords.length - 1) &&
                        (yi === 0 || yi === yCoords.length - 1);
                    const isEdge = !isCorner && (xi === 0 || xi === xCoords.length - 1 ||
                        yi === 0 || yi === yCoords.length - 1);

                    let type = 'interior';
                    if (isCorner) type = 'corner';
                    else if (isEdge) type = 'edge';

                    // v2.7: Check if this column existed before and preserve its active state
                    const oldCol = oldColumns.find(c => c.id === id);
                    const isActive = oldCol ? oldCol.active : true;  // Preserve or default true
                    const startFloor = oldCol?.startFloor || null;   // v3.0: Preserve planted column state
                    const activePerFloor = oldCol?.activePerFloor || null;  // v3.0: Preserve per-floor toggle state
                    const typePerFloor = oldCol?.typePerFloor || null;  // v3.0: Preserve per-floor TYPE state
                    const floorActive = oldCol?.floorActive || null;  // v3.0: Preserve per-floor active state

                    state.columns.push({
                        id,
                        x: xCoords[xi],
                        y: yCoords[yi],
                        xi, yi,
                        type,
                        active: isActive,  // v2.7: Preserved toggle state for L/U shapes
                        startFloor: startFloor,  // v3.0: For planted columns (null = from ground)
                        activePerFloor: activePerFloor,  // v3.0: Per-floor toggle state
                        typePerFloor: typePerFloor,  // v3.0: Per-floor type (corner/edge/interior)
                        floorActive: floorActive,    // v3.0: Per-floor active state
                        loadPerFloor: 0,
                        totalLoad: 0,
                        connectedBeams: [] // Will store beam IDs
                    });
                }
            }

            // v3.0: Re-add planted columns that were placed on beams (not at grid intersections)
            for (const pc of plantedColumns) {
                // Check if this planted column already exists (by position)
                const exists = state.columns.find(c =>
                    Math.abs(c.x - pc.x) < 0.1 && Math.abs(c.y - pc.y) < 0.1
                );
                if (!exists) {
                    // Preserve the planted column with all its properties
                    state.columns.push({
                        ...pc,
                        loadPerFloor: 0,
                        totalLoad: 0
                    });
                    console.log(`v3.0: Preserved planted column ${pc.id} at (${pc.x.toFixed(2)}, ${pc.y.toFixed(2)})`);
                }
            }
        }

        /**
         * Step 2: Generate slab panels
         */
        // v2.7: Helper to get column by grid indices
        function getColumnAt(xi, yi) {
            return state.columns.find(c => c.xi === xi && c.yi === yi);
        }

        /**
         * Step 2: Generate slab panels
         * v3.0: Now accepts floorId to distinct cantilevers
         */
        function generateSlabs(floorId) {
            // v3.0: Preserve existing opening data
            const oldSlabs = state.slabs || [];

            // v3.0: Get per-floor void slabs (FIXED: ensure each floor has its own array)
            const floor = floorId ? state.floors.find(f => f.id === floorId) : state.floors[state.currentFloorIndex];
            if (floor && !floor.voidSlabs) floor.voidSlabs = [];  // Initialize per-floor array
            const floorVoidSlabs = floor ? floor.voidSlabs : [];  // Use per-floor, never fallback to global

            state.slabs = [];
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            for (let yi = 0; yi < state.ySpans.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    // v3.0 FIX: ALWAYS generate all slabs regardless of column state
                    // This prevents cascade deletion when column is toggled

                    const lx = state.xSpans[xi];
                    const ly = state.ySpans[yi];
                    const mainSlabId = `S${yi * state.xSpans.length + xi + 1}`;
                    const x1 = xCoords[xi];
                    const x2 = xCoords[xi + 1];
                    const y1 = yCoords[yi];
                    const y2 = yCoords[yi + 1];

                    // v3.0: Find custom beams that cross this panel
                    const crossingX = [x1, x2];
                    const crossingY = [y1, y2];

                    const floorCustomBeams = floor?.customBeams || [];
                    for (const cb of floorCustomBeams) {
                        // v3.0 FIX: dir='X' means horizontal beam (constant Y), splits Y range
                        // dir='Y' means vertical beam (constant X), splits X range
                        if (cb.dir === 'X' && cb.pos > y1 && cb.pos < y2) {
                            // Horizontal beam at Y=cb.pos splits the Y range
                            if (cb.start < x2 && cb.end > x1) crossingY.push(cb.pos);
                        } else if (cb.dir === 'Y' && cb.pos > x1 && cb.pos < x2) {
                            // Vertical beam at X=cb.pos splits the X range
                            if (cb.start < y2 && cb.end > y1) crossingX.push(cb.pos);
                        }
                    }

                    // Sort unique coordinates
                    const sortedX = [...new Set(crossingX)].sort((a, b) => a - b);
                    const sortedY = [...new Set(crossingY)].sort((a, b) => a - b);

                    // Generate sub-slabs
                    for (let sy = 0; sy < sortedY.length - 1; sy++) {
                        for (let sx = 0; sx < sortedX.length - 1; sx++) {
                            const sx1 = sortedX[sx];
                            const sx2 = sortedX[sx + 1];
                            const sy1 = sortedY[sy];
                            const sy2 = sortedY[sy + 1];
                            const slx = sx2 - sx1;
                            const sly = sy2 - sy1;
                            const subId = (sortedX.length > 2 || sortedY.length > 2)
                                ? `${mainSlabId}_${sx}_${sy}`
                                : mainSlabId;

                            const ratio = Math.max(slx, sly) / Math.min(slx, sly);
                            const isTwoWay = ratio < 2;

                            // Void state from floor's voidSlabs array
                            const isVoid = floorVoidSlabs.includes(subId);

                            state.slabs.push({
                                id: subId,
                                parentId: mainSlabId,
                                x1: sx1, y1: sy1, x2: sx2, y2: sy2,
                                lx: slx, ly: sly,
                                area: slx * sly,
                                isTwoWay,
                                xi, yi, // Grid indices of the parent
                                sx, sy, // Sub-indices
                                isVoid: isVoid
                            });
                        }
                    }
                }
            }

            // v3.0 FIX: Ghost cleanup - remove orphaned voidSlabs references
            // When spans change, slab IDs change and old voidSlabs refs become orphans
            if (floor && floor.voidSlabs && floor.voidSlabs.length > 0) {
                const validSlabIds = state.slabs.map(s => s.id);
                const orphans = floor.voidSlabs.filter(id => !validSlabIds.includes(id));
                if (orphans.length > 0) {
                    orphans.forEach(orphanId => {
                        const idx = floor.voidSlabs.indexOf(orphanId);
                        if (idx >= 0) floor.voidSlabs.splice(idx, 1);
                    });
                    console.log(`v3.0: Cleaned ${orphans.length} orphaned voidSlabs on floor ${floor.id}:`, orphans);
                }
            }

            // v3.0: Generate cantilever slabs (specific to floor if provided)
            generateCantileverSlabs(xCoords, yCoords, floorId);
        }

        // v3.0 FIX: Helper to get effective cantilevers for a floor
        // Now returns per-floor cantilevers ONLY, never falls back to global
        function getCantilevers(floorId) {
            const floor = floorId
                ? state.floors.find(f => f.id === floorId)
                : state.floors[state.currentFloorIndex];

            // GF without suspended mode has no cantilevers
            if (floor?.id === 'GF' && !state.gfSuspended) {
                return { top: [], bottom: [], left: [], right: [] };
            }

            // v3.0 FIX: Return floor-specific cantilevers, or empty if none defined
            // This prevents cantilevers from one floor appearing on all floors
            if (floor?.cantilevers) {
                return floor.cantilevers;
            }

            // v3.0 FIX: No floor-specific cantilevers = return zeros (not global!)
            const numX = state.xSpans.length;
            const numY = state.ySpans.length;
            return {
                top: new Array(numX).fill(0),
                bottom: new Array(numX).fill(0),
                left: new Array(numY).fill(0),
                right: new Array(numY).fill(0)
            };
        }

        // v3.0: Generate cantilever slab panels extending beyond the grid
        function generateCantileverSlabs(xCoords, yCoords, floorId) {
            const cants = getCantilevers(floorId);

            // v3.0: Get per-floor void slabs for cantilevers too
            const currentFloor = state.floors.find(f => f.id === floorId);
            const floorVoidSlabs = currentFloor?.voidSlabs || [];

            // Top cantilevers (above first row, yi = 0)
            for (let xi = 0; xi < state.xSpans.length; xi++) {

                const cantLen = cants.top[xi] || 0;
                if (cantLen > 0) {
                    const spanWidth = state.xSpans[xi];
                    state.slabs.push({
                        id: `SC-T${xi + 1}`,
                        x1: xCoords[xi],
                        y1: -cantLen,  // Extends above grid (negative Y)
                        x2: xCoords[xi + 1],
                        y2: 0,
                        lx: spanWidth,
                        ly: cantLen,
                        area: spanWidth * cantLen,
                        isCantilever: true,
                        cantileverEdge: 'top',
                        spanIndex: xi,
                        supportingBeamId: `BX-1-${xi + 1}`,  // Top edge beam
                        isVoid: floorVoidSlabs.includes(`SC-T${xi + 1}`)
                    });
                }
            }

            // Bottom cantilevers (below last row)
            const maxY = yCoords[yCoords.length - 1];
            const lastYi = state.ySpans.length;  // Last beam row index
            for (let xi = 0; xi < state.xSpans.length; xi++) {
                const cantLen = cants.bottom[xi] || 0;
                if (cantLen > 0) {
                    const spanWidth = state.xSpans[xi];
                    state.slabs.push({
                        id: `SC-B${xi + 1}`,
                        x1: xCoords[xi],
                        y1: maxY,
                        x2: xCoords[xi + 1],
                        y2: maxY + cantLen,  // Extends below grid
                        lx: spanWidth,
                        ly: cantLen,
                        area: spanWidth * cantLen,
                        isCantilever: true,
                        cantileverEdge: 'bottom',
                        spanIndex: xi,
                        supportingBeamId: `BX-${lastYi + 1}-${xi + 1}`,  // Bottom edge beam
                        isVoid: floorVoidSlabs.includes(`SC-B${xi + 1}`)
                    });
                }
            }

            // Left cantilevers (left of first column, xi = 0)
            for (let yi = 0; yi < state.ySpans.length; yi++) {
                const cantLen = cants.left[yi] || 0;
                if (cantLen > 0) {
                    const spanHeight = state.ySpans[yi];
                    state.slabs.push({
                        id: `SC-L${yi + 1}`,
                        x1: -cantLen,  // Extends left of grid (negative X)
                        y1: yCoords[yi],
                        x2: 0,
                        y2: yCoords[yi + 1],
                        lx: cantLen,
                        ly: spanHeight,
                        area: cantLen * spanHeight,
                        isCantilever: true,
                        cantileverEdge: 'left',
                        spanIndex: yi,
                        supportingBeamId: `BY-1-${yi + 1}`,  // Left edge beam
                        isVoid: floorVoidSlabs.includes(`SC-L${yi + 1}`)
                    });
                }
            }

            // Right cantilevers (right of last column)
            const maxX = xCoords[xCoords.length - 1];
            const lastXi = state.xSpans.length;  // Last beam column index
            for (let yi = 0; yi < state.ySpans.length; yi++) {
                const cantLen = cants.right[yi] || 0;
                if (cantLen > 0) {
                    const spanHeight = state.ySpans[yi];
                    state.slabs.push({
                        id: `SC-R${yi + 1}`,
                        x1: maxX,
                        y1: yCoords[yi],
                        x2: maxX + cantLen,  // Extends right of grid
                        y2: yCoords[yi + 1],
                        lx: cantLen,
                        ly: spanHeight,
                        area: cantLen * spanHeight,
                        isCantilever: true,
                        cantileverEdge: 'right',
                        spanIndex: yi,
                        supportingBeamId: `BY-${lastXi + 1}-${yi + 1}`,  // Right edge beam
                        isVoid: floorVoidSlabs.includes(`SC-R${yi + 1}`)
                    });
                }
            }
        }

        // v3.0: Generate cantilever beams (from columns) and edge beams (at cantilever tips)
        function generateCantileverBeams(xCoords, yCoords, letters) {
            const maxX = xCoords[xCoords.length - 1];
            const maxY = yCoords[yCoords.length - 1];

            // TOP CANTILEVERS: Beams extend from columns at yi=0 upward (negative Y)
            for (let xi = 0; xi <= state.xSpans.length; xi++) {
                // Check if any adjacent span has a top cantilever
                const leftCant = xi > 0 ? (state.cantilevers.top[xi - 1] || 0) : 0;
                const rightCant = xi < state.xSpans.length ? (state.cantilevers.top[xi] || 0) : 0;
                const maxCant = Math.max(leftCant, rightCant);

                if (maxCant > 0) {
                    const col = getColumnAt(xi, 0);
                    // v3.0 FIX: Use per-floor check to prevent cascade deletion
                    const currentFloorId = state.floors[state.currentFloorIndex]?.id;
                    if (col && isColumnActiveOnFloor(col, currentFloorId)) {
                        // Cantilever beam from column to edge
                        state.beams.push({
                            id: `BCY-T-${xi + 1}`,
                            direction: 'Y',
                            isCantilever: true,
                            cantileverEdge: 'top',
                            x1: xCoords[xi],
                            y1: -maxCant,
                            x2: xCoords[xi],
                            y2: 0,
                            span: maxCant,
                            startCol: null,  // Free end
                            endCol: col.id,  // Connected to column
                            tributaryWidth: 0,
                            tributaryArea: 0,
                            slices: [],
                            w: 0,
                            Rleft: 0,
                            Rright: 0
                        });
                    }
                }
            }

            // TOP EDGE BEAM: Runs along the top edge of cantilever slabs
            let topEdgeSegments = [];
            for (let xi = 0; xi < state.xSpans.length; xi++) {
                const cantLen = state.cantilevers.top[xi] || 0;
                if (cantLen > 0) {
                    topEdgeSegments.push({ xi, cantLen });
                }
            }
            for (let seg of topEdgeSegments) {
                state.beams.push({
                    id: `BEX-T-${seg.xi + 1}`,
                    direction: 'X',
                    isEdgeBeam: true,
                    cantileverEdge: 'top',
                    x1: xCoords[seg.xi],
                    y1: -seg.cantLen,
                    x2: xCoords[seg.xi + 1],
                    y2: -seg.cantLen,
                    span: state.xSpans[seg.xi],
                    tributaryWidth: 0,
                    tributaryArea: 0,
                    slices: [],
                    w: 0,
                    Rleft: 0,
                    Rright: 0
                });
            }

            // BOTTOM CANTILEVERS: Beams extend from columns at yi=last downward
            const lastYi = state.ySpans.length;
            for (let xi = 0; xi <= state.xSpans.length; xi++) {
                const leftCant = xi > 0 ? (state.cantilevers.bottom[xi - 1] || 0) : 0;
                const rightCant = xi < state.xSpans.length ? (state.cantilevers.bottom[xi] || 0) : 0;
                const maxCant = Math.max(leftCant, rightCant);

                if (maxCant > 0) {
                    const col = getColumnAt(xi, lastYi);
                    // v3.0 FIX: Use per-floor check
                    const currentFloorId = state.floors[state.currentFloorIndex]?.id;
                    if (col && isColumnActiveOnFloor(col, currentFloorId)) {
                        state.beams.push({
                            id: `BCY-B-${xi + 1}`,
                            direction: 'Y',
                            isCantilever: true,
                            cantileverEdge: 'bottom',
                            x1: xCoords[xi],
                            y1: maxY,
                            x2: xCoords[xi],
                            y2: maxY + maxCant,
                            span: maxCant,
                            startCol: col.id,
                            endCol: null,
                            tributaryWidth: 0,
                            tributaryArea: 0,
                            slices: [],
                            w: 0,
                            Rleft: 0,
                            Rright: 0
                        });
                    }
                }
            }

            // BOTTOM EDGE BEAM
            for (let xi = 0; xi < state.xSpans.length; xi++) {
                const cantLen = state.cantilevers.bottom[xi] || 0;
                if (cantLen > 0) {
                    state.beams.push({
                        id: `BEX-B-${xi + 1}`,
                        direction: 'X',
                        isEdgeBeam: true,
                        cantileverEdge: 'bottom',
                        x1: xCoords[xi],
                        y1: maxY + cantLen,
                        x2: xCoords[xi + 1],
                        y2: maxY + cantLen,
                        span: state.xSpans[xi],
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // LEFT CANTILEVERS: Beams extend from columns at xi=0 leftward
            for (let yi = 0; yi <= state.ySpans.length; yi++) {
                const topCant = yi > 0 ? (state.cantilevers.left[yi - 1] || 0) : 0;
                const bottomCant = yi < state.ySpans.length ? (state.cantilevers.left[yi] || 0) : 0;
                const maxCant = Math.max(topCant, bottomCant);

                if (maxCant > 0) {
                    const col = getColumnAt(0, yi);
                    // v3.0 FIX: Use per-floor check
                    const currentFloorId = state.floors[state.currentFloorIndex]?.id;
                    if (col && isColumnActiveOnFloor(col, currentFloorId)) {
                        state.beams.push({
                            id: `BCX-L-${yi + 1}`,
                            direction: 'X',
                            isCantilever: true,
                            cantileverEdge: 'left',
                            x1: -maxCant,
                            y1: yCoords[yi],
                            x2: 0,
                            y2: yCoords[yi],
                            span: maxCant,
                            startCol: null,
                            endCol: col.id,
                            tributaryWidth: 0,
                            tributaryArea: 0,
                            slices: [],
                            w: 0,
                            Rleft: 0,
                            Rright: 0
                        });
                    }
                }
            }

            // LEFT EDGE BEAM
            for (let yi = 0; yi < state.ySpans.length; yi++) {
                const cantLen = state.cantilevers.left[yi] || 0;
                if (cantLen > 0) {
                    state.beams.push({
                        id: `BEY-L-${yi + 1}`,
                        direction: 'Y',
                        isEdgeBeam: true,
                        cantileverEdge: 'left',
                        x1: -cantLen,
                        y1: yCoords[yi],
                        x2: -cantLen,
                        y2: yCoords[yi + 1],
                        span: state.ySpans[yi],
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // RIGHT CANTILEVERS: Beams extend from columns at xi=last rightward
            const lastXi = state.xSpans.length;
            for (let yi = 0; yi <= state.ySpans.length; yi++) {
                const topCant = yi > 0 ? (state.cantilevers.right[yi - 1] || 0) : 0;
                const bottomCant = yi < state.ySpans.length ? (state.cantilevers.right[yi] || 0) : 0;
                const maxCant = Math.max(topCant, bottomCant);

                if (maxCant > 0) {
                    const col = getColumnAt(lastXi, yi);
                    // v3.0 FIX: Use per-floor check
                    const currentFloorId = state.floors[state.currentFloorIndex]?.id;
                    if (col && isColumnActiveOnFloor(col, currentFloorId)) {
                        state.beams.push({
                            id: `BCX-R-${yi + 1}`,
                            direction: 'X',
                            isCantilever: true,
                            cantileverEdge: 'right',
                            x1: maxX,
                            y1: yCoords[yi],
                            x2: maxX + maxCant,
                            y2: yCoords[yi],
                            span: maxCant,
                            startCol: col.id,
                            endCol: null,
                            tributaryWidth: 0,
                            tributaryArea: 0,
                            slices: [],
                            w: 0,
                            Rleft: 0,
                            Rright: 0
                        });
                    }
                }
            }

            // RIGHT EDGE BEAM
            for (let yi = 0; yi < state.ySpans.length; yi++) {
                const cantLen = state.cantilevers.right[yi] || 0;
                if (cantLen > 0) {
                    state.beams.push({
                        id: `BEY-R-${yi + 1}`,
                        direction: 'Y',
                        isEdgeBeam: true,
                        cantileverEdge: 'right',
                        x1: maxX + cantLen,
                        y1: yCoords[yi],
                        x2: maxX + cantLen,
                        y2: yCoords[yi + 1],
                        span: state.ySpans[yi],
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }
        }

        /**
         * Step 3 & 4: Generate beams and calculate tributary widths
         * v2.2: Now creates slices per slab with proper 45° math
         * Short span direction gets MORE load (stiffer)
         * v3.0: Added wallLoad parameter for line loads on beams
         */
        function generateBeams(pu, wallLoad = 0, targetFloor = null) {
            state.beams = [];

            // X-direction beams (horizontal, span in X)
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            // Letters for column IDs (must match generateGrid)
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';

            // Create beam objects with slices array
            for (let yi = 0; yi < yCoords.length; yi++) {
                for (let xi = 0; xi < state.xSpans.length; xi++) {
                    // v2.7: Skip beams where either endpoint column is inactive
                    const leftCol = getColumnAt(xi, yi);
                    const rightCol = getColumnAt(xi + 1, yi);
                    if (!leftCol || !rightCol || leftCol.active === false || rightCol.active === false) {
                        continue;
                    }

                    const beamSpan = state.xSpans[xi];
                    const beamId = `BX-${yi + 1}-${xi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'X',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi + 1],
                        y2: yCoords[yi],
                        span: beamSpan,
                        // Column connections for load distribution
                        startCol: `${letters[xi]}${yi + 1}`,
                        endCol: `${letters[xi + 1]}${yi + 1}`,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],  // v2.2: per-slab slices
                        w: 0,
                        Rleft: 0,
                        Rright: 0
                    });
                }
            }

            // Y-direction beams (along gridlines in X direction)
            for (let xi = 0; xi < xCoords.length; xi++) {
                for (let yi = 0; yi < state.ySpans.length; yi++) {
                    // v2.7: Skip beams where either endpoint column is inactive
                    const topCol = getColumnAt(xi, yi);
                    const bottomCol = getColumnAt(xi, yi + 1);
                    if (!topCol || !bottomCol || topCol.active === false || bottomCol.active === false) {
                        continue;
                    }

                    const beamSpan = state.ySpans[yi];
                    const beamId = `BY-${xi + 1}-${yi + 1}`;

                    state.beams.push({
                        id: beamId,
                        direction: 'Y',
                        xi, yi,
                        x1: xCoords[xi],
                        y1: yCoords[yi],
                        x2: xCoords[xi],
                        y2: yCoords[yi + 1],
                        span: beamSpan,
                        // Column connections for load distribution
                        startCol: `${letters[xi]}${yi + 1}`,
                        endCol: `${letters[xi]}${yi + 2}`,
                        tributaryWidth: 0,
                        tributaryArea: 0,
                        slices: [],  // v2.2: per-slab slices
                        w: 0,
                        Rleft: 0,
                    });
                }
            }

            // v3.0: Generate cantilever beams and edge beams
            generateCantileverBeams(xCoords, yCoords, letters);

            // v3.0: Add custom (intermediate framing) beams to state.beams
            const floor = targetFloor || state.floors[state.currentFloorIndex];
            const customBeams = floor?.customBeams || [];
            for (const cb of customBeams) {
                let x1, y1, x2, y2, span, direction;

                // v3.0 FIX: dir='X' means horizontal beam (constant Y), dir='Y' means vertical beam (constant X)
                if (cb.dir === 'X') {
                    // Horizontal beam: runs along X axis, Y is constant = cb.pos
                    x1 = cb.start;
                    x2 = cb.end;
                    y1 = cb.pos;
                    y2 = cb.pos;
                    span = cb.end - cb.start;
                    direction = 'X';  // Spans in X direction
                } else {
                    // Vertical beam: runs along Y axis, X is constant = cb.pos
                    x1 = cb.pos;
                    x2 = cb.pos;
                    y1 = cb.start;
                    y2 = cb.end;
                    span = cb.end - cb.start;
                    direction = 'Y';  // Spans in Y direction
                }

                state.beams.push({
                    id: cb.id,
                    direction: direction,
                    isCustom: true,  // Flag for custom beam
                    x1, y1, x2, y2,
                    span: span,
                    startCol: null,  // Custom beams may not connect to grid columns
                    endCol: null,
                    tributaryWidth: 0,
                    tributaryArea: 0,
                    slices: [],
                    w: 0,
                    Rleft: 0,
                    Rright: 0
                });
            }

            // Map for quick access (now includes cantilever beams + custom beams)
            const beamMap = Object.fromEntries(state.beams.map(beam => [beam.id, beam]));

            // v3.0: Helper to check if a custom beam crosses a slab
            function getCustomBeamsCrossingSlab(slab) {
                const crossing = [];
                for (const cb of customBeams) {
                    // v3.0 FIX: dir='X' means horizontal beam (constant Y), dir='Y' means vertical (constant X)
                    if (cb.dir === 'X') {
                        // Horizontal beam at Y = cb.pos
                        // Check if beam Y is within slab Y range AND beam X overlaps slab X
                        if (cb.pos > slab.y1 && cb.pos < slab.y2 &&
                            cb.start < slab.x2 && cb.end > slab.x1) {
                            crossing.push({
                                ...cb,
                                beamId: cb.id,
                                splitDir: 'Y',  // Splits slab horizontally (Y direction)
                                splitPos: cb.pos
                            });
                        }
                    } else {
                        // Vertical beam at X = cb.pos
                        if (cb.pos > slab.x1 && cb.pos < slab.x2 &&
                            cb.start < slab.y2 && cb.end > slab.y1) {
                            crossing.push({
                                ...cb,
                                beamId: cb.id,
                                splitDir: 'X',  // Splits slab vertically (X direction)
                                splitPos: cb.pos
                            });
                        }
                    }
                }
                return crossing;
            }

            // v2.2: Distribute slab areas with proper slices
            // v3.0: Skip void slabs - they don't contribute load to any beam
            for (let slab of state.slabs) {
                // v3.0: Skip void slabs - no load distribution
                if (slab.isVoid) {
                    console.log(`v3.0: Skipping void slab ${slab.id} in load distribution`);
                    continue;
                }
                // Skip cantilever slabs - handled separately below
                if (slab.isCantilever) continue;
                // Find beams on 4 edges geometrically
                const TOL = 0.05; // 5cm tolerance
                const topBeam = state.beams.find(b => b.direction === 'X' && Math.abs(b.y1 - slab.y1) < TOL && b.x1 <= slab.x1 + TOL && b.x2 >= slab.x2 - TOL);
                const bottomBeam = state.beams.find(b => b.direction === 'X' && Math.abs(b.y1 - slab.y2) < TOL && b.x1 <= slab.x1 + TOL && b.x2 >= slab.x2 - TOL);
                const leftBeam = state.beams.find(b => b.direction === 'Y' && Math.abs(b.x1 - slab.x1) < TOL && b.y1 <= slab.y1 + TOL && b.y2 >= slab.y2 - TOL);
                const rightBeam = state.beams.find(b => b.direction === 'Y' && Math.abs(b.x1 - slab.x2) < TOL && b.y1 <= slab.y1 + TOL && b.y2 >= slab.y2 - TOL);

                const topBeamId = topBeam?.id;
                const bottomBeamId = bottomBeam?.id;
                const leftBeamId = leftBeam?.id;
                const rightBeamId = rightBeam?.id;

                // Slab coordinates
                const x0 = slab.x1, x1 = slab.x2;
                const y0 = slab.y1, y1 = slab.y2;

                // Helper to create polygon and compute centroid
                function makeSlice(beamId, side, areaSide, poly) {
                    const beam = beamMap[beamId];
                    if (!beam) return;

                    const tribWidth = areaSide / beam.span;
                    const w = pu * tribWidth;

                    // Compute centroid for label placement
                    let cx = 0, cy = 0;
                    for (let pt of poly) { cx += pt.x; cy += pt.y; }
                    cx /= poly.length;
                    cy /= poly.length;

                    beam.tributaryArea += areaSide;
                    beam.slices.push({
                        slabId: slab.id,
                        side: side,
                        area: areaSide,
                        w: w,
                        poly: poly,
                        cx: cx,
                        cy: cy
                    });
                }

                if (slab.isTwoWay) {
                    const h = Math.min(slab.lx, slab.ly) / 2;  // 45° inset height

                    // Provisional areas based on 45° triangular/trapezoidal geometry
                    const xSideArea_raw = slab.lx * h / 2; // triangle for X-beams (top/bottom)
                    const trapBase = slab.ly;
                    const trapTop = slab.ly - 2 * h;
                    const ySideArea_raw = trapTop > 0
                        ? (trapBase + trapTop) * h / 2  // trapezoid for Y-beams
                        : slab.ly * h / 2;              // triangle when lines meet

                    // Normalize so total = slab.area
                    const rawTotal = 2 * xSideArea_raw + 2 * ySideArea_raw;
                    const scale = rawTotal > 0 ? slab.area / rawTotal : 0;

                    const A_top = xSideArea_raw * scale;
                    const A_bottom = xSideArea_raw * scale;
                    const A_left = ySideArea_raw * scale;
                    const A_right = ySideArea_raw * scale;

                    let topPoly, bottomPoly, leftPoly, rightPoly;

                    if (slab.lx <= slab.ly) {
                        // Short direction = X
                        // Top/Bottom = Triangles
                        topPoly = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: (x0 + x1) / 2, y: y0 + h }
                        ];
                        bottomPoly = [
                            { x: x0, y: y1 },
                            { x: x1, y: y1 },
                            { x: (x0 + x1) / 2, y: y1 - h }
                        ];
                        // Left/Right = Trapezoids
                        leftPoly = [
                            { x: x0, y: y0 },
                            { x: x0, y: y1 },
                            { x: x0 + h, y: y1 - h },
                            { x: x0 + h, y: y0 + h }
                        ];
                        rightPoly = [
                            { x: x1, y: y0 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: y1 - h },
                            { x: x1 - h, y: y0 + h }
                        ];
                    } else {
                        // Short direction = Y
                        // Left/Right = Triangles
                        leftPoly = [
                            { x: x0, y: y0 },
                            { x: x0, y: y1 },
                            { x: x0 + h, y: (y0 + y1) / 2 }
                        ];
                        rightPoly = [
                            { x: x1, y: y0 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: (y0 + y1) / 2 }
                        ];
                        // Top/Bottom = Trapezoids
                        topPoly = [
                            { x: x0, y: y0 },
                            { x: x1, y: y0 },
                            { x: x1 - h, y: y0 + h },
                            { x: x0 + h, y: y0 + h }
                        ];
                        bottomPoly = [
                            { x: x0, y: y1 },
                            { x: x1, y: y1 },
                            { x: x1 - h, y: y1 - h },
                            { x: x0 + h, y: y1 - h }
                        ];
                    }

                    makeSlice(topBeamId, 'top', A_top, topPoly);
                    makeSlice(bottomBeamId, 'bottom', A_bottom, bottomPoly);
                    makeSlice(leftBeamId, 'left', A_left, leftPoly);
                    makeSlice(rightBeamId, 'right', A_right, rightPoly);
                } else {
                    // One-way slab: split into 2 rectangles
                    const halfArea = slab.area / 2;

                    if (slab.lx < slab.ly) {
                        // Spanning in Y, supported by left/right beams
                        const midX = (x0 + x1) / 2;
                        const leftPoly = [{ x: x0, y: y0 }, { x: midX, y: y0 }, { x: midX, y: y1 }, { x: x0, y: y1 }];
                        const rightPoly = [{ x: midX, y: y0 }, { x: x1, y: y0 }, { x: x1, y: y1 }, { x: midX, y: y1 }];
                        makeSlice(leftBeamId, 'left', halfArea, leftPoly);
                        makeSlice(rightBeamId, 'right', halfArea, rightPoly);
                    } else {
                        // Spanning in X, supported by top/bottom beams
                        const midY = (y0 + y1) / 2;
                        const topPoly = [{ x: x0, y: y0 }, { x: x1, y: y0 }, { x: x1, y: midY }, { x: x0, y: midY }];
                        const bottomPoly = [{ x: x0, y: midY }, { x: x1, y: midY }, { x: x1, y: y1 }, { x: x0, y: y1 }];
                        makeSlice(topBeamId, 'top', halfArea, topPoly);
                        makeSlice(bottomBeamId, 'bottom', halfArea, bottomPoly);
                    }
                }
            }

            // v3.0: Distribute slab loads to CUSTOM BEAMS that cross them
            // Custom beams receive load from the portions of slabs they cross
            for (let slab of state.slabs) {
                if (slab.isCantilever || slab.isVoid) continue;

                const crossingBeams = getCustomBeamsCrossingSlab(slab);
                for (const cb of crossingBeams) {
                    const customBeam = beamMap[cb.beamId];
                    if (!customBeam) continue;

                    // Calculate the portion of slab area that loads this custom beam
                    // Simplified: the custom beam gets a strip of width = MIN(span_in_direction, half_slab_dimension)
                    let tributaryArea;
                    if (cb.splitDir === 'Y') {
                        // Beam runs horizontally through slab
                        // It receives load from both sides up to 45° line or slab edge
                        const distToTop = cb.splitPos - slab.y1;
                        const distToBottom = slab.y2 - cb.splitPos;
                        const tributaryWidthTop = Math.min(distToTop, slab.lx / 2);
                        const tributaryWidthBottom = Math.min(distToBottom, slab.lx / 2);
                        const beamLengthInSlab = Math.min(cb.end, slab.x2) - Math.max(cb.start, slab.x1);
                        tributaryArea = beamLengthInSlab * (tributaryWidthTop + tributaryWidthBottom);
                    } else {
                        // Beam runs vertically through slab
                        const distToLeft = cb.splitPos - slab.x1;
                        const distToRight = slab.x2 - cb.splitPos;
                        const tributaryWidthLeft = Math.min(distToLeft, slab.ly / 2);
                        const tributaryWidthRight = Math.min(distToRight, slab.ly / 2);
                        const beamLengthInSlab = Math.min(cb.end, slab.y2) - Math.max(cb.start, slab.y1);
                        tributaryArea = beamLengthInSlab * (tributaryWidthLeft + tributaryWidthRight);
                    }

                    customBeam.tributaryArea += tributaryArea;
                    customBeam.slices.push({
                        slabId: slab.id,
                        side: 'custom',
                        area: tributaryArea,
                        w: pu * (tributaryArea / customBeam.span),
                        isCustom: true,
                        poly: [
                            { x: slab.x1, y: slab.y1 },
                            { x: slab.x2, y: slab.y1 },
                            { x: slab.x2, y: slab.y2 },
                            { x: slab.x1, y: slab.y2 }
                        ],
                        cx: (slab.x1 + slab.x2) / 2,
                        cy: (slab.y1 + slab.y2) / 2
                    });

                    console.log(`v3.0: Custom beam ${cb.beamId} receives ${tributaryArea.toFixed(2)} m² from slab ${slab.id}`);
                }
            }

            // v3.0: Distribute cantilever slab loads to beams
            // Load goes to: (1) the main grid edge beam, and (2) the cantilever beams
            // v3.0 FIX: Skip voided cantilever slabs - they shouldn't contribute load
            for (let slab of state.slabs.filter(s => s.isCantilever && !s.isVoid)) {
                const edge = slab.cantileverEdge;
                const spanIndex = slab.spanIndex;
                const slabArea = slab.area;

                // ===== PART 1: Add load to the MAIN GRID EDGE BEAM =====
                // This is the beam along the grid edge that the cantilever extends from
                let mainEdgeBeamId;
                if (edge === 'top') {
                    // Top cantilever is supported by BX-1-* (first row X-beams)
                    mainEdgeBeamId = `BX-1-${spanIndex + 1}`;
                } else if (edge === 'bottom') {
                    // Bottom cantilever is supported by BX-(lastRow+1)-*
                    mainEdgeBeamId = `BX-${state.ySpans.length + 1}-${spanIndex + 1}`;
                } else if (edge === 'left') {
                    // Left cantilever is supported by BY-1-*
                    mainEdgeBeamId = `BY-1-${spanIndex + 1}`;
                } else if (edge === 'right') {
                    // Right cantilever is supported by BY-(lastCol+1)-*
                    mainEdgeBeamId = `BY-${state.xSpans.length + 1}-${spanIndex + 1}`;
                }

                const mainBeam = beamMap[mainEdgeBeamId];
                if (mainBeam) {
                    // Add FULL cantilever area to the supporting edge beam
                    mainBeam.tributaryArea += slabArea;
                    mainBeam.slices.push({
                        slabId: slab.id,
                        side: 'cantilever',
                        area: slabArea,
                        w: 0,
                        isCantilever: true,
                        poly: [
                            { x: slab.x1, y: slab.y1 },
                            { x: slab.x2, y: slab.y1 },
                            { x: slab.x2, y: slab.y2 },
                            { x: slab.x1, y: slab.y2 }
                        ],
                        cx: (slab.x1 + slab.x2) / 2,
                        cy: (slab.y1 + slab.y2) / 2
                    });
                }

                // ===== PART 2: Also add load to CANTILEVER BEAMS (perpendicular) =====
                let cantBeam1Id, cantBeam2Id;
                if (edge === 'top' || edge === 'bottom') {
                    const prefix = edge === 'top' ? 'BCY-T' : 'BCY-B';
                    cantBeam1Id = `${prefix}-${spanIndex + 1}`;
                    cantBeam2Id = `${prefix}-${spanIndex + 2}`;
                } else {
                    const prefix = edge === 'left' ? 'BCX-L' : 'BCX-R';
                    cantBeam1Id = `${prefix}-${spanIndex + 1}`;
                    cantBeam2Id = `${prefix}-${spanIndex + 2}`;
                }

                // Cantilever beams get half the area each (for their own load calc)
                const halfArea = slabArea / 2;
                const cantBeam1 = beamMap[cantBeam1Id];
                const cantBeam2 = beamMap[cantBeam2Id];

                if (cantBeam1) cantBeam1.tributaryArea += halfArea;
                if (cantBeam2) cantBeam2.tributaryArea += halfArea;
            }

            // Finalize tributary widths and loads
            for (let beam of state.beams) {
                // Ensure tributary area doesn't go negative
                beam.tributaryArea = Math.max(0, beam.tributaryArea);
                beam.tributaryWidth = beam.span > 0 ? beam.tributaryArea / beam.span : 0;

                // v3.0: Add wall load to beam load
                // Wall load is kN/m, added FACTORED (1.2 × DL)
                const slabLoad = pu * beam.tributaryWidth;
                const factoredWallLoad = beam.isCantilever || beam.isEdgeBeam ? 0 : 1.2 * wallLoad;
                beam.wallLoad = factoredWallLoad;
                beam.w = slabLoad + factoredWallLoad;
            }
        }

        /**
         * Step 5: Calculate beam reactions
         * For uniform load: R_left = R_right = w * L / 2
         * v3.0: Cantilever beams - all load goes to support column
         */
        function calculateBeamReactions() {
            for (let beam of state.beams) {
                if (beam.isCantilever) {
                    // Cantilever beam: all load goes to the support (connected) end
                    const totalLoad = beam.w * beam.span;
                    if (beam.startCol) {
                        beam.Rleft = totalLoad;
                        beam.Rright = 0;
                    } else {
                        beam.Rleft = 0;
                        beam.Rright = totalLoad;
                    }
                } else if (beam.isEdgeBeam) {
                    // Edge beam: load goes to adjacent cantilever beams (handled separately)
                    beam.Rleft = beam.w * beam.span / 2;
                    beam.Rright = beam.w * beam.span / 2;
                } else {
                    // Simply supported beam with uniform load: R = w * L / 2
                    beam.Rleft = beam.w * beam.span / 2;
                    beam.Rright = beam.w * beam.span / 2;
                }
            }
        }

        /**
         * Step 6: Calculate column loads
         * Column load = Sum of all beam reactions at that column
         * v3.0: Handles cantilever beams using startCol/endCol IDs
         */
        function calculateColumnLoads() {
            // Reset column loads
            for (let col of state.columns) {
                col.loadPerFloor = 0;
                col.connectedBeams = [];
            }

            // Sum beam reactions to columns
            for (let beam of state.beams) {
                // v3.0: Cantilever and edge beams use startCol/endCol IDs
                if (beam.isCantilever || beam.isEdgeBeam) {
                    if (beam.startCol) {
                        const col = state.columns.find(c => c.id === beam.startCol);
                        if (col) {
                            col.loadPerFloor += beam.Rleft;
                            col.connectedBeams.push(beam.id);
                        }
                    }
                    if (beam.endCol) {
                        const col = state.columns.find(c => c.id === beam.endCol);
                        if (col) {
                            col.loadPerFloor += beam.Rright;
                            col.connectedBeams.push(beam.id);
                        }
                    }
                } else {
                    // Normal beams: find columns by xi/yi indices
                    let colLeft, colRight;

                    if (beam.direction === 'X') {
                        // X beam: connects columns at same yi, adjacent xi
                        colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                        colRight = state.columns.find(c => c.xi === beam.xi + 1 && c.yi === beam.yi);
                    } else {
                        // Y beam: connects columns at same xi, adjacent yi
                        colLeft = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi);
                        colRight = state.columns.find(c => c.xi === beam.xi && c.yi === beam.yi + 1);
                    }

                    if (colLeft) {
                        colLeft.loadPerFloor += beam.Rleft;
                        colLeft.connectedBeams.push(beam.id);
                    }
                    if (colRight) {
                        colRight.loadPerFloor += beam.Rright;
                        colRight.connectedBeams.push(beam.id);
                    }
                }
            }

            // Calculate total load (sum across floors, not multiply!)
            for (let col of state.columns) {
                // Each floor has same load pattern
                col.totalLoad = col.loadPerFloor * state.numFloors;
            }
        }

        // ========== v3.0: MEMBER SIZING (NSCP 2015) ==========

        /**
         * Size a column based on axial load (simplified - axial only, no moment)
         * Formula: Pu ≤ φPn = φ × 0.80 × [0.85 × f'c × (Ag - Ast) + fy × Ast]
         * Simplified: Ag_required = Pu / (φ × 0.80 × (0.85 × f'c × (1 - ρ) + fy × ρ))
         * v3.0: Supports rectangular columns (b × h)
         * @param {number} Pu_kN - Ultimate axial load in kN
         * @param {number} height_m - Column height in meters (for self-weight)
         * @returns {object} { b, h, Ast, selfWeight_kN, isOverride }
         */
        function sizeColumn(Pu_kN, height_m = 3.0) {
            const phi = 0.65;  // NSCP reduction factor for tied columns
            const rho = 0.01;  // 1% minimum steel ratio
            const fc = state.fc;  // MPa
            const fy = state.fy;  // MPa
            const Pu = Pu_kN * 1000;  // Convert kN to N

            let b, h;
            let isOverride = false;

            // v3.0: Check for user override (rectangular columns)
            if (state.defaultColumnB > 0) {
                b = state.defaultColumnB;
                h = state.defaultColumnH > 0 ? state.defaultColumnH : b;  // h=0 means square
                isOverride = true;
            } else {
                // Required gross area (mm²)
                const Ag_required = Pu / (phi * 0.80 * (0.85 * fc * (1 - rho) + fy * rho));

                // Size as square column, round up to nearest 50mm
                let side = Math.ceil(Math.sqrt(Ag_required) / 50) * 50;
                side = Math.max(side, 200);  // Minimum 200mm per NSCP
                b = side;
                h = side;
            }

            // Actual gross area and required steel
            const Ag_actual = b * h;
            const Ast = Math.ceil(rho * Ag_actual);

            // v3.0: Calculate column self-weight
            const volume_m3 = (b / 1000) * (h / 1000) * height_m;
            const selfWeight_kN = volume_m3 * state.concreteDensity;

            return { b, h, Ast, selfWeight_kN, isOverride };
        }

        /**
         * Size a beam based on span-to-depth ratio (NSCP Table 409.3.1.1)
         * v3.0: Respects user-provided dimensions when defaultBeamH > 0
         * @param {number} span_m - Beam span in meters
         * @param {boolean} isCantilever - Is this a cantilever beam?
         * @returns {object} { b: width in mm, h: depth in mm }
         */
        function sizeBeam(span_m, isCantilever = false) {
            let b, h;

            // v3.0: If user specified beam depth, use it
            if (state.defaultBeamH > 0) {
                h = state.defaultBeamH;
                b = state.defaultBeamB || 250;
            } else {
                // Auto-size using NSCP span-to-depth ratio
                const L = span_m * 1000;  // Convert to mm

                // Minimum depth per NSCP based on span
                // Simply supported: L/16, Cantilever: L/8
                const minDepthRatio = isCantilever ? 8 : 16;
                h = Math.ceil((L / minDepthRatio) / 50) * 50;  // Round to 50mm
                h = Math.max(h, 300);  // Minimum 300mm depth

                // Use user-provided width or calculate from depth
                b = state.defaultBeamB > 0
                    ? state.defaultBeamB
                    : Math.max(200, Math.ceil((h * 0.5) / 50) * 50);
            }

            return { b: b, h: h };
        }

        /**
         * Apply sizing to all columns and beams
         * v3.0: Also calculates self-weight dead load
         */
        function sizeMembers() {
            // Size all columns based on their total load
            let totalColumnSelfWeight = 0;
            for (let col of state.columns) {
                if (col.active === false) continue;
                const height = state.floors[0]?.height || 3.0;  // Use first floor height
                const sizing = sizeColumn(col.totalLoad, height);
                col.suggestedB = sizing.b;
                col.suggestedH = sizing.h;
                col.suggestedAst = sizing.Ast;
                col.selfWeight = sizing.selfWeight_kN;
                col.isOverride = sizing.isOverride;
                totalColumnSelfWeight += col.selfWeight;
            }
            state.totalColumnSelfWeight = totalColumnSelfWeight;

            // Size all beams based on their span
            let totalBeamSelfWeight = 0;
            for (let beam of state.beams) {
                const sizing = sizeBeam(beam.span, beam.isCantilever || false);
                beam.suggestedB = sizing.b;
                beam.suggestedH = sizing.h;

                // v3.0: Calculate beam self-weight
                // Volume = b × h × span, Weight = γc × Volume
                const bM = sizing.b / 1000;  // Convert mm to m
                const hM = sizing.h / 1000;  // Convert mm to m
                beam.selfWeight = state.concreteDensity * bM * hM * beam.span;  // kN total
                beam.selfWeightPerM = state.concreteDensity * bM * hM;  // kN/m
                totalBeamSelfWeight += beam.selfWeight;
            }

            // Store total self-weight for display
            state.totalBeamSelfWeight = totalBeamSelfWeight;
        }

        // ========== UI UPDATES ==========
        function updateResults(pu) {
            // v3.0: Total area - use net area (after opening deductions)
            const grossArea = state.slabs.reduce((sum, s) => sum + s.area, 0);
            const netArea = state.slabs.reduce((sum, s) => sum + (s.netArea || s.area), 0);
            const openingArea = state.totalOpeningArea || 0;

            // Show net area (what actually carries load)
            document.getElementById('totalArea').textContent = netArea.toFixed(1);

            // If there are openings, add a note
            if (openingArea > 0) {
                document.getElementById('totalArea').title =
                    `Gross: ${grossArea.toFixed(1)}m² - Openings: ${openingArea.toFixed(1)}m² = Net: ${netArea.toFixed(1)}m²`;
            }

            // Beam tributary area check (compare to net area)
            const totalBeamArea = state.beams.reduce((sum, b) => sum + b.tributaryArea, 0);
            const areaBalance = netArea > 0 ? (totalBeamArea / netArea) * 100 : 0;
            const areaDelta = totalBeamArea - netArea;
            const balanceEl = document.getElementById('areaBalance');
            const balanceDetailEl = document.getElementById('areaBalanceDetail');
            balanceEl.textContent = `${areaBalance.toFixed(1)}%`;
            balanceEl.style.color = Math.abs(areaDelta) < 0.01 ? 'var(--success)' : 'var(--warning)';
            balanceDetailEl.textContent = `${areaDelta.toFixed(2)} m² diff`;

            // Factored load
            document.getElementById('factoredLoad').textContent = pu.toFixed(2);

            // Total per floor (use current selected floor)
            const currentFloor = state.floors[state.currentFloorIndex];
            const totalPerFloor = state.columns.reduce((sum, c) => {
                const floorLoad = c.floorLoads.find(f => f.floorId === currentFloor.id);
                return sum + (floorLoad ? floorLoad.load : 0);
            }, 0);
            document.getElementById('totalPerFloor').textContent = totalPerFloor.toFixed(0);

            // Max column (total across all floors)
            const maxCol = state.columns.length
                ? Math.max(...state.columns.map(c => c.totalLoad))
                : 0;
            document.getElementById('maxColumn').textContent = maxCol.toFixed(0);

            // v3.0: Use updateColumnTable for full column display with b×h and footings
            updateColumnTable();

            // v3.2: Update footing schedule table
            updateFootingSchedule();

            // v2.7: Beam table - clickable rows for 3D highlighting
            // v3.0: Show support reaction for cantilever beams + editable size
            // v3.1: Use grid-based beam naming convention (B-2F-A1B1)
            const beamBody = document.getElementById('beamResultsBody');

            // v3.1: Helper to get grid-based beam label
            const GRID_LETTERS = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            function getBeamGridCol(x) {
                let cumX = 0;
                for (let i = 0; i < state.xSpans.length; i++) {
                    if (Math.abs(x - cumX) < 0.1) return GRID_LETTERS[i];
                    cumX += state.xSpans[i];
                }
                if (Math.abs(x - cumX) < 0.1) return GRID_LETTERS[state.xSpans.length];
                return '?';
            }
            function getBeamGridRow(y) {
                let cumY = 0;
                for (let i = 0; i < state.ySpans.length; i++) {
                    if (Math.abs(y - cumY) < 0.1) return (i + 1).toString();
                    cumY += state.ySpans[i];
                }
                if (Math.abs(y - cumY) < 0.1) return (state.ySpans.length + 1).toString();
                return '?';
            }
            function getBeamLabel(beam) {
                const floorId = state.floors[state.currentFloorIndex]?.id || '2F';
                if (beam.direction === 'X') {
                    const row = getBeamGridRow(beam.y1);
                    const startCol = getBeamGridCol(beam.x1);
                    const endCol = getBeamGridCol(beam.x2);
                    return `B-${floorId}-${startCol}${row}${endCol}${row}`;
                } else {
                    const col = getBeamGridCol(beam.x1);
                    const startRow = getBeamGridRow(beam.y1);
                    const endRow = getBeamGridRow(beam.y2);
                    return `B-${floorId}-${col}${startRow}${col}${endRow}`;
                }
            }

            beamBody.innerHTML = state.beams.slice(0, 30).map(beam => {
                const isSelected = state.selectedMemberId === beam.id;
                // v3.0: For cantilevers, show the support reaction (non-zero one)
                const displayR = beam.isCantilever
                    ? Math.max(beam.Rleft, beam.Rright)
                    : beam.Rleft;
                // v3.0: Different styling for cantilever/edge beams
                const beamStyle = beam.isCantilever
                    ? 'color:#f59e0b;'
                    : (beam.isEdgeBeam ? 'color:#ec4899;' : '');
                // v3.0: Editable beam size with override indicator
                const hasOverride = beam.overrideB || beam.overrideH;
                // v3.1: Use grid-based beam label
                const beamLabel = getBeamLabel(beam);
                return `
                <tr onclick="selectMember('${beam.id}')" style="cursor:pointer;${isSelected ? 'background:rgba(239,68,68,0.3);' : ''}" title="Click to highlight in 3D">
                    <td style="${beamStyle}">${beamLabel}</td>
                    <td>${beam.w.toFixed(1)}</td>
                    <td>${displayR.toFixed(1)}</td>
                    <td style="color:#10b981;" onclick="event.stopPropagation()">
                        <input type="number" value="${beam.overrideB || beam.suggestedB || ''}" min="200" max="500" step="50"
                               style="width:32px;padding:1px;font-size:0.6rem;background:#1a1f2e;color:#10b981;border:1px solid ${beam.overrideB ? '#10b981' : '#444'};border-radius:3px;"
                               onchange="setBeamSize('${beam.id}', 'b', this.value)" title="Beam width (mm)">×
                        <input type="number" value="${beam.overrideH || beam.suggestedH || ''}" min="300" max="800" step="50"
                               style="width:32px;padding:1px;font-size:0.6rem;background:#1a1f2e;color:#10b981;border:1px solid ${beam.overrideH ? '#10b981' : '#444'};border-radius:3px;"
                               onchange="setBeamSize('${beam.id}', 'h', this.value)" title="Beam depth (mm)">
                    </td>
                </tr>
            `;
            }).join('');

            // v3.0: Update slab openings table
            updateSlabOpeningsTable();
        }

        // ========== DRAWING ==========

        // v3.0: Toggle opening placement mode
        function toggleOpeningMode() {
            state.addingOpening = !state.addingOpening;
            const btn = document.getElementById('addOpeningBtn');
            if (state.addingOpening) {
                btn.style.background = 'var(--warning)';
                btn.style.color = 'black';
                canvas.style.cursor = 'crosshair';
            } else {
                btn.style.background = '';
                btn.style.color = '';
                canvas.style.cursor = 'default';
            }
        }

        // v3.0: Place an opening at canvas coordinates
        function placeOpening(worldX, worldY) {
            const type = document.getElementById('openingType').value;

            // Default sizes based on type
            const sizes = {
                stair: { width: 2.5, depth: 3.0 },
                elevator: { width: 2.0, depth: 2.0 },
                duct: { width: 0.6, depth: 0.6 }
            };
            const size = sizes[type] || sizes.stair;

            const opening = {
                id: `O${state.nextOpeningId++}`,
                x: worldX,           // Center X position (m)
                y: worldY,           // Center Y position (m)
                width: size.width,   // Width in X direction (m)
                depth: size.depth,   // Depth in Y direction (m)
                type: type
            };

            state.openings.push(opening);
            console.log(`v3.0: Added ${type} opening at (${worldX.toFixed(1)}, ${worldY.toFixed(1)})`);

            // Exit opening mode after placing
            toggleOpeningMode();

            // Recalculate to update areas
            calculate();
        }

        // v3.0: Delete opening by ID
        function deleteOpening(id) {
            state.openings = state.openings.filter(o => o.id !== id);
            calculate();
        }

        // v2.7/v3.0: Handle canvas click - beam mode, beam deletion, slab void, column toggle, context menu, click-to-place
        function handleCanvasClick(event) {
            if (!canvas) return;

            const rect = canvas.getBoundingClientRect();
            const clickX = event.clientX - rect.left;
            const clickY = event.clientY - rect.top;

            // Convert to world coordinates
            const worldX = (clickX - state.offsetX) / state.scale;
            const worldY = (clickY - state.offsetY) / state.scale;

            // v3.0: Shift+Click to place planted column at custom location (check first)
            if (event.shiftKey && !state.addingBeam) {
                const totalX = state.xSpans.reduce((a, b) => a + b, 0);
                const totalY = state.ySpans.reduce((a, b) => a + b, 0);

                if (worldX >= 0 && worldX <= totalX && worldY >= 0 && worldY <= totalY) {
                    console.log(`v3.0: Click-to-place at (${worldX.toFixed(2)}, ${worldY.toFixed(2)})`);
                    showPlantedColumnDialog(worldX, worldY);
                    return;
                } else {
                    console.log('v3.0: Click-to-place ignored - outside grid bounds');
                }
            }

            // v3.0: If in beam adding mode, this click starts drawing
            if (state.addingBeam) {
                // Start drawing beam - snap to grid for precise placement
                const snappedX = snapToGrid(worldX);
                const snappedY = snapToGrid(worldY);
                state.beamDrawStart = { x: snappedX, y: snappedY };
                console.log(`v3.0: Beam draw started at (${snappedX.toFixed(2)}, ${snappedY.toFixed(2)}) [snapped]`);
                return;
            }

            // v3.0: Only handle beam deletion and slab void when NOT in Add Beam mode
            if (!state.addingBeam) {
                // v3.0: Check if clicked on a custom beam (for deletion)
                const customBeams = getFloorCustomBeams();
                const beamHitTolerance = 30 / state.scale; // 30px tolerance in world units (increased from 15)
                console.log(`v3.0 BEAM DEBUG: Floor=${state.floors[state.currentFloorIndex]?.id}, customBeams.length=${customBeams.length}, click=(${worldX.toFixed(2)}, ${worldY.toFixed(2)}), tol=${beamHitTolerance.toFixed(2)}`);
                console.log(`v3.0 BEAM DEBUG: customBeams=`, JSON.stringify(customBeams));

                const beamHit = customBeams.find(beam => {
                    if (beam.dir === 'Y') {
                        // Horizontal beam at Y = beam.pos, X from start to end
                        const hit = Math.abs(worldY - beam.pos) < beamHitTolerance &&
                            worldX >= beam.start - beamHitTolerance &&
                            worldX <= beam.end + beamHitTolerance;
                        console.log(`v3.0: Beam ${beam.id} (Y=${beam.pos.toFixed(2)}, X:${beam.start.toFixed(2)}-${beam.end.toFixed(2)}) hit=${hit}`);
                        return hit;
                    } else {
                        // Vertical beam at X = beam.pos, Y from start to end
                        const hit = Math.abs(worldX - beam.pos) < beamHitTolerance &&
                            worldY >= beam.start - beamHitTolerance &&
                            worldY <= beam.end + beamHitTolerance;
                        console.log(`v3.0: Beam ${beam.id} (X=${beam.pos.toFixed(2)}, Y:${beam.start.toFixed(2)}-${beam.end.toFixed(2)}) hit=${hit}`);
                        return hit;
                    }
                });

                if (beamHit) {
                    if (confirm(`Delete beam ${beamHit.id}?`)) {
                        deleteCustomBeam(beamHit.id);
                        console.log(`v3.0: Deleted beam ${beamHit.id} by click`);
                    }
                    return;
                }

                // v3.0: Check if clicked on a slab panel (for void toggle)
                const slabHit = state.slabs.find(slab => {
                    if (slab.isCantilever) return false; // Can't void cantilever slabs
                    return worldX >= slab.x1 && worldX <= slab.x2 &&
                        worldY >= slab.y1 && worldY <= slab.y2;
                });

                if (slabHit) {
                    toggleSlabVoid(slabHit.id);
                    return;
                }
            }

            // v3.0: Check if clicked on column - show context menu instead of direct toggle
            const hitRadius = 15 / state.scale;
            for (const col of state.columns) {
                const dx = worldX - (col.gridX || col.x);
                const dy = worldY - (col.gridY || col.y);
                const dist = Math.sqrt(dx * dx + dy * dy);

                if (dist < hitRadius) {
                    // Column hit! Show context menu
                    showColumnMenu(col.id, event.clientX, event.clientY);
                    event.preventDefault();
                    return;
                }
            }

            // Close any open menu if clicking elsewhere
            hideColumnMenu();
        }

        // v3.0: Toggle slab as void (for U-shape/L-shape layouts) - per floor
        function toggleSlabVoid(slabId) {
            const voidSlabs = getFloorVoidSlabs();
            const idx = voidSlabs.indexOf(slabId);
            if (idx >= 0) {
                voidSlabs.splice(idx, 1); // Remove from void
                console.log(`v3.0: Slab ${slabId} restored on floor`);
            } else {
                voidSlabs.push(slabId); // Mark as void
                console.log(`v3.0: Slab ${slabId} marked as void on floor`);
            }
            calculate(); // Recalculate loads
        }

        // v3.0: Toggle beam adding mode
        function toggleBeamMode() {
            state.addingBeam = !state.addingBeam;
            state.beamDrawStart = null;
            const btn = document.getElementById('addBeamBtn');
            if (state.addingBeam) {
                btn.style.background = 'var(--primary)';
                btn.style.color = 'white';
                canvas.style.cursor = 'crosshair';
                console.log('v3.0: Beam drawing mode ON');
            } else {
                btn.style.background = '';
                btn.style.color = '';
                canvas.style.cursor = 'default';
                console.log('v3.0: Beam drawing mode OFF');
            }
        }

        // v3.0: Get custom beams for current floor
        function getFloorCustomBeams() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor.customBeams) floor.customBeams = [];
            return floor.customBeams;
        }

        // v3.0: Get floor void slabs (per floor)
        function getFloorVoidSlabs() {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor.voidSlabs) floor.voidSlabs = [];
            return floor.voidSlabs;
        }

        // v3.0: Finish drawing beam on mouseup
        function finishBeamDraw(event) {
            if (!state.addingBeam || !state.beamDrawStart) return;

            const rect = canvas.getBoundingClientRect();
            const mouseX = event.clientX - rect.left;
            const mouseY = event.clientY - rect.top;

            // v3.0: Use configurable snap-to-grid (respects state.snapSize when enabled)
            const endX = snapToGrid((mouseX - state.offsetX) / state.scale);
            const endY = snapToGrid((mouseY - state.offsetY) / state.scale);
            const startX = snapToGrid(state.beamDrawStart.x);
            const startY = snapToGrid(state.beamDrawStart.y);

            // Determine if horizontal or vertical based on drag direction
            const dx = Math.abs(endX - startX);
            const dy = Math.abs(endY - startY);

            // Minimum beam length check (0.5m)
            if (Math.max(dx, dy) < 0.5) {
                state.beamDrawStart = null;
                console.log('v3.0: Beam too short, cancelled');
                return;
            }

            // Create custom beam
            const customBeams = getFloorCustomBeams();
            const beamId = `CB${state.nextCustomBeamId++}`;

            if (dx > dy) {
                // Horizontal beam (Y direction in plan)
                const y = (startY + endY) / 2; // Average Y position
                customBeams.push({
                    id: beamId,
                    dir: 'Y',  // Beam runs along Y axis
                    pos: y,    // Y coordinate
                    start: Math.min(startX, endX),
                    end: Math.max(startX, endX)
                });
                console.log(`v3.0: Added horizontal beam ${beamId} at Y=${y.toFixed(2)}`);
            } else {
                // Vertical beam (X direction in plan)
                const x = (startX + endX) / 2; // Average X position
                customBeams.push({
                    id: beamId,
                    dir: 'X',  // Beam runs along X axis
                    pos: x,    // X coordinate
                    start: Math.min(startY, endY),
                    end: Math.max(startY, endY)
                });
                console.log(`v3.0: Added vertical beam ${beamId} at X=${x.toFixed(2)}`);
            }

            state.beamDrawStart = null;
            toggleBeamMode(); // Exit beam mode
            calculate(); // Recalculate with new beam
        }

        // v3.0: Delete custom beam by ID
        function deleteCustomBeam(beamId) {
            const customBeams = getFloorCustomBeams();
            const idx = customBeams.findIndex(b => b.id === beamId);
            if (idx >= 0) {
                const deletedBeam = customBeams[idx];
                const floorId = state.floors[state.currentFloorIndex]?.id;

                // v3.0: Push to undo stack before deleting
                state.undoStack.push({
                    type: 'beam',
                    data: { ...deletedBeam },
                    floorId: floorId,
                    timestamp: Date.now()
                });

                customBeams.splice(idx, 1);
                console.log(`v3.0: Deleted custom beam ${beamId} (saved to undo stack)`);
                updateUndoButton();
                calculate();
            }
        }

        // v3.0: Toggle slab void state (PER-FLOOR - only affects current floor)
        function toggleSlabVoid(slabId) {
            const currentFloor = state.floors[state.currentFloorIndex];
            if (!currentFloor) return;

            // Initialize per-floor void slabs array if needed
            if (!currentFloor.voidSlabs) currentFloor.voidSlabs = [];

            // Check current state
            const idx = currentFloor.voidSlabs.indexOf(slabId);
            const wasVoid = idx >= 0;

            // v3.0: Push to undo stack before toggling
            state.undoStack.push({
                type: 'voidSlab',
                data: { slabId, wasVoid },
                floorId: currentFloor.id,
                timestamp: Date.now()
            });

            // Toggle in floor's void list
            if (wasVoid) {
                currentFloor.voidSlabs.splice(idx, 1); // Remove - no longer void
                console.log(`v3.0: Slab ${slabId} restored on floor ${currentFloor.id} (saved to undo)`);
            } else {
                currentFloor.voidSlabs.push(slabId); // Add as void
                console.log(`v3.0: Slab ${slabId} set as VOID on floor ${currentFloor.id} (saved to undo)`);
            }

            // Also update the slab object directly
            const slab = state.slabs.find(s => s.id === slabId);
            if (slab) {
                slab.isVoid = !slab.isVoid;
            }

            updateUndoButton();
            calculate(); // Recalc loads
        }

        // v3.0: Toggle structural beam deleted state (PER-FLOOR)
        function toggleBeamDeleted(beamId) {
            const currentFloor = state.floors[state.currentFloorIndex];
            if (!currentFloor) return;

            // Initialize per-floor deleted beams array if needed
            if (!currentFloor.deletedBeams) currentFloor.deletedBeams = [];

            // Toggle in floor's deleted list
            const idx = currentFloor.deletedBeams.indexOf(beamId);
            if (idx >= 0) {
                currentFloor.deletedBeams.splice(idx, 1); // Restore
                console.log(`v3.0: Beam ${beamId} restored on floor ${currentFloor.id}`);
            } else {
                currentFloor.deletedBeams.push(beamId); // Delete
                console.log(`v3.0: Beam ${beamId} DELETED on floor ${currentFloor.id}`);
            }

            calculate();
        }

        function draw() {

            if (!ctx) return;

            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // v3.0: Check if structural plan tab is active - draw actual member sizes
            if (currentPlanTab === 'structural') {
                drawStructuralPlan();
                return; // Skip wireframe mode
            }

            // v3.2: Check if foundation plan tab is active - draw footings and tie beams
            if (currentPlanTab === 'foundation') {
                drawFoundationPlan();
                return; // Skip wireframe mode
            }

            // v3.0: Draw gridlines when in beam adding mode OR grid toggle is ON (and layer is visible)
            if ((state.addingBeam || state.showSubGrid) && layerVisibility.grid) {
                const gridSpacing = 1.0; // 1m spacing
                const totalWidth = state.xSpans.reduce((a, b) => a + b, 0);
                const totalHeight = state.ySpans.reduce((a, b) => a + b, 0);

                // Extend grid 5m beyond building in all directions
                const gridExtend = 5;
                const gridStartX = -gridExtend;
                const gridEndX = totalWidth + gridExtend;
                const gridStartY = -gridExtend;
                const gridEndY = totalHeight + gridExtend;

                // Draw fine grid (configurable snap size when snap enabled)
                const fineSpacing = state.snapEnabled ? state.snapSize : 0.5;

                // Fine grid (subtle)
                ctx.strokeStyle = 'rgba(99, 102, 241, 0.08)';
                ctx.lineWidth = 0.5;
                ctx.setLineDash([]);

                for (let x = gridStartX; x <= gridEndX; x += fineSpacing) {
                    const px = x * state.scale + state.offsetX;
                    ctx.beginPath();
                    ctx.moveTo(px, gridStartY * state.scale + state.offsetY);
                    ctx.lineTo(px, gridEndY * state.scale + state.offsetY);
                    ctx.stroke();
                }
                for (let y = gridStartY; y <= gridEndY; y += fineSpacing) {
                    const py = y * state.scale + state.offsetY;
                    ctx.beginPath();
                    ctx.moveTo(gridStartX * state.scale + state.offsetX, py);
                    ctx.lineTo(gridEndX * state.scale + state.offsetX, py);
                    ctx.stroke();
                }

                // Major grid (1m spacing - more visible)
                ctx.strokeStyle = 'rgba(99, 102, 241, 0.25)';
                ctx.lineWidth = 1;

                for (let x = Math.floor(gridStartX); x <= gridEndX; x += gridSpacing) {
                    const px = x * state.scale + state.offsetX;
                    ctx.beginPath();
                    ctx.moveTo(px, gridStartY * state.scale + state.offsetY);
                    ctx.lineTo(px, gridEndY * state.scale + state.offsetY);
                    ctx.stroke();
                }
                for (let y = Math.floor(gridStartY); y <= gridEndY; y += gridSpacing) {
                    const py = y * state.scale + state.offsetY;
                    ctx.beginPath();
                    ctx.moveTo(gridStartX * state.scale + state.offsetX, py);
                    ctx.lineTo(gridEndX * state.scale + state.offsetX, py);
                    ctx.stroke();
                }
            }

            // v3.0: Draw gridline bubbles (A, B, C... for X-axis and 1, 2, 3... for Y-axis)
            const totalWidth = state.xSpans.reduce((a, b) => a + b, 0);
            const totalHeight = state.ySpans.reduce((a, b) => a + b, 0);
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            const bubbleRadius = 14;

            // Calculate X coordinates
            let xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);

            // Calculate Y coordinates
            let yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            // Draw X-axis gridlines (vertical lines) with letter bubbles at TOP
            ctx.strokeStyle = 'rgba(99, 102, 241, 0.3)';
            ctx.lineWidth = 1;
            ctx.setLineDash([5, 5]);
            for (let i = 0; i < xCoords.length; i++) {
                const px = xCoords[i] * state.scale + state.offsetX;
                // Draw gridline
                ctx.beginPath();
                ctx.moveTo(px, state.offsetY - 30);
                ctx.lineTo(px, totalHeight * state.scale + state.offsetY + 30);
                ctx.stroke();

                // Draw bubble at top - OUTER edge (further from grid)
                const by = state.offsetY - 70;  // v3.1: Moved to outer edge
                ctx.fillStyle = '#6366f1';
                ctx.beginPath();
                ctx.arc(px, by, bubbleRadius, 0, Math.PI * 2);
                ctx.fill();
                // Letter label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(letters[i], px, by);
            }

            // Draw Y-axis gridlines (horizontal lines) with number bubbles at LEFT
            for (let i = 0; i < yCoords.length; i++) {
                const py = yCoords[i] * state.scale + state.offsetY;
                // Draw gridline
                ctx.beginPath();
                ctx.moveTo(state.offsetX - 30, py);
                ctx.lineTo(totalWidth * state.scale + state.offsetX + 30, py);
                ctx.stroke();

                // Draw bubble at left - OUTER edge (further from grid)
                const bx = state.offsetX - 80;  // v3.1: Moved to outer edge
                ctx.fillStyle = '#6366f1';
                ctx.beginPath();
                ctx.arc(bx, py, bubbleRadius, 0, Math.PI * 2);
                ctx.fill();
                // Number label
                ctx.fillStyle = 'white';
                ctx.font = 'bold 12px sans-serif';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText((i + 1).toString(), bx, py);
            }
            ctx.setLineDash([]);

            // ========== v3.1: DIMENSION LABELS ==========
            // Draw X-span dimensions (between X gridlines, at top)
            ctx.font = 'bold 11px sans-serif';
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';

            for (let i = 0; i < state.xSpans.length; i++) {
                const x1 = xCoords[i] * state.scale + state.offsetX;
                const x2 = xCoords[i + 1] * state.scale + state.offsetX;
                const midX = (x1 + x2) / 2;
                const topY = state.offsetY - 45; // v3.1: Between bubbles and grid

                // Dimension line
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(x1, topY);
                ctx.lineTo(x2, topY);
                ctx.stroke();

                // End ticks
                ctx.beginPath();
                ctx.moveTo(x1, topY - 4);
                ctx.lineTo(x1, topY + 4);
                ctx.moveTo(x2, topY - 4);
                ctx.lineTo(x2, topY + 4);
                ctx.stroke();

                // Dimension text background
                const dimText = state.xSpans[i].toFixed(1) + 'm';
                const textWidth = ctx.measureText(dimText).width + 8;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(midX - textWidth / 2, topY - 8, textWidth, 16);

                // Dimension text
                ctx.fillStyle = '#00d4ff';
                ctx.fillText(dimText, midX, topY);
            }

            // Draw Y-span dimensions (between Y gridlines, at left)
            for (let i = 0; i < state.ySpans.length; i++) {
                const y1 = yCoords[i] * state.scale + state.offsetY;
                const y2 = yCoords[i + 1] * state.scale + state.offsetY;
                const midY = (y1 + y2) / 2;
                const leftX = state.offsetX - 50; // v3.1: Between bubbles and grid

                // Dimension line
                ctx.strokeStyle = 'rgba(0, 212, 255, 0.8)';
                ctx.lineWidth = 1;
                ctx.beginPath();
                ctx.moveTo(leftX, y1);
                ctx.lineTo(leftX, y2);
                ctx.stroke();

                // End ticks
                ctx.beginPath();
                ctx.moveTo(leftX - 4, y1);
                ctx.lineTo(leftX + 4, y1);
                ctx.moveTo(leftX - 4, y2);
                ctx.lineTo(leftX + 4, y2);
                ctx.stroke();

                // Dimension text background
                const dimText = state.ySpans[i].toFixed(1) + 'm';
                const textWidth = ctx.measureText(dimText).width + 8;
                ctx.fillStyle = 'rgba(0, 0, 0, 0.7)';
                ctx.fillRect(leftX - textWidth / 2, midY - 8, textWidth, 16);

                // Dimension text
                ctx.fillStyle = '#00d4ff';
                ctx.fillText(dimText, leftX, midY);
            }

            // Draw slabs (filled)
            for (let slab of state.slabs) {
                const x1 = slab.x1 * state.scale + state.offsetX;
                const y1 = slab.y1 * state.scale + state.offsetY;
                const w = slab.lx * state.scale;
                const h = slab.ly * state.scale;

                // v3.0: Void slabs - show red X pattern
                if (slab.isVoid) {
                    ctx.fillStyle = 'rgba(239, 68, 68, 0.35)';  // Red tint (increased opacity)
                    ctx.fillRect(x1, y1, w, h);
                    // Dashed border
                    ctx.strokeStyle = '#ef4444';  // Red
                    ctx.lineWidth = 2;
                    ctx.setLineDash([5, 5]);
                    ctx.strokeRect(x1, y1, w, h);
                    ctx.setLineDash([]);
                    // Draw solid X (more visible)
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x1, y1);
                    ctx.lineTo(x1 + w, y1 + h);
                    ctx.moveTo(x1 + w, y1);
                    ctx.lineTo(x1, y1 + h);
                    ctx.stroke();
                    // Label
                    if (state.showLabels) {
                        const cx = x1 + w / 2;
                        const cy = y1 + h / 2;
                        ctx.fillStyle = 'rgba(0,0,0,0.8)';
                        ctx.fillRect(cx - 20, cy - 8, 40, 16);
                        ctx.fillStyle = '#ef4444';
                        ctx.font = '9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('VOID', cx, cy + 3);
                    }
                    continue;  // Skip normal rendering
                }

                // v3.0: Special styling for cantilever slabs
                if (slab.isCantilever) {
                    ctx.fillStyle = 'rgba(245, 158, 11, 0.25)';  // Orange tint
                    ctx.fillRect(x1, y1, w, h);
                    ctx.setLineDash([5, 5]);  // Dashed border
                    ctx.strokeStyle = '#f59e0b';  // Orange border
                    ctx.lineWidth = 2;
                    ctx.strokeRect(x1, y1, w, h);
                    ctx.setLineDash([]);  // Reset

                    // Cantilever label
                    if (state.showLabels) {
                        const cx = x1 + w / 2;
                        const cy = y1 + h / 2;
                        ctx.fillStyle = 'rgba(0,0,0,0.7)';
                        ctx.fillRect(cx - 25, cy - 8, 50, 16);
                        ctx.fillStyle = '#f59e0b';
                        ctx.font = '9px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(`C:${slab.area.toFixed(1)}m²`, cx, cy + 3);
                    }
                } else {
                    // v2.7: Normal slab - visible with thick border
                    ctx.fillStyle = 'rgba(20, 40, 60, 0.7)';  // Dark blue-gray fill
                    ctx.fillRect(x1, y1, w, h);

                    // v3.2: Check if slab is locked
                    const floorNow = state.floors[state.currentFloorIndex];
                    const isSlabLocked = floorNow?.lockedSlabs?.includes(slab.id);

                    if (isSlabLocked) {
                        // Locked slab: blue border
                        ctx.strokeStyle = '#3b82f6';  // Blue for locked
                        ctx.lineWidth = 5;
                    } else {
                        ctx.strokeStyle = '#0ea5e9';  // Bright cyan border
                        ctx.lineWidth = 3;
                    }
                    ctx.strokeRect(x1, y1, w, h);

                    // v3.2: Draw lock icon for locked slabs
                    if (isSlabLocked && state.showLabels) {
                        const cx = x1 + w / 2;
                        const cy = y1 + h / 2;
                        ctx.fillStyle = '#3b82f6';
                        ctx.font = '12px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText('🔒', cx, cy);
                    }
                }
            }

            // v2.2: Draw slice polygons when Areas is ON
            if (state.showAreas) {
                for (let beam of state.beams) {
                    for (let slice of beam.slices) {
                        // v3.0: Skip slices for voided slabs - don't cover void pattern
                        const parentSlab = state.slabs.find(s => s.id === slice.slabId);
                        if (parentSlab && parentSlab.isVoid) continue;

                        // Draw polygon
                        ctx.beginPath();
                        const firstPt = slice.poly[0];
                        ctx.moveTo(
                            firstPt.x * state.scale + state.offsetX,
                            firstPt.y * state.scale + state.offsetY
                        );
                        for (let i = 1; i < slice.poly.length; i++) {
                            const pt = slice.poly[i];
                            ctx.lineTo(
                                pt.x * state.scale + state.offsetX,
                                pt.y * state.scale + state.offsetY
                            );
                        }
                        ctx.closePath();

                        // Color by beam direction
                        const isXBeam = beam.direction === 'X';
                        ctx.fillStyle = isXBeam ? 'rgba(124, 58, 237, 0.25)' : 'rgba(16, 185, 129, 0.25)';
                        ctx.fill();
                        ctx.strokeStyle = isXBeam ? 'rgba(124, 58, 237, 0.6)' : 'rgba(16, 185, 129, 0.6)';
                        ctx.lineWidth = 1;
                        ctx.stroke();

                        // Centroid marker and label
                        const cx = slice.cx * state.scale + state.offsetX;
                        const cy = slice.cy * state.scale + state.offsetY;

                        // White dot at centroid
                        ctx.beginPath();
                        ctx.arc(cx, cy, 3, 0, Math.PI * 2);
                        ctx.fillStyle = '#fff';
                        ctx.fill();

                        // Label at centroid
                        if (state.showLabels) {
                            ctx.fillStyle = 'rgba(0,0,0,0.75)';
                            ctx.fillRect(cx - 32, cy - 18, 64, 22);
                            ctx.fillStyle = '#00d4ff';
                            ctx.font = '9px sans-serif';
                            ctx.textAlign = 'center';
                            ctx.fillText(`A=${slice.area.toFixed(1)}m²`, cx, cy - 6);
                            ctx.fillStyle = '#f59e0b';
                            ctx.fillText(`w=${slice.w.toFixed(1)}kN/m`, cx, cy + 6);
                        }
                    }
                }
            }

            // Draw beams (with per-floor deleted check)
            const currentFloor = state.floors[state.currentFloorIndex];
            const deletedBeams = currentFloor?.deletedBeams || [];
            const lockedBeams = currentFloor?.lockedBeams || [];  // v3.2: Get locked beams

            ctx.lineWidth = 3;
            for (let beam of state.beams) {
                // v3.0 FIX: Skip custom beams - they are drawn separately below
                if (beam.isCustom) continue;

                const x1 = beam.x1 * state.scale + state.offsetX;
                const y1 = beam.y1 * state.scale + state.offsetY;
                const x2 = beam.x2 * state.scale + state.offsetX;
                const y2 = beam.y2 * state.scale + state.offsetY;

                // v3.0: Check if beam is deleted on THIS floor
                const isDeleted = deletedBeams.includes(beam.id);
                // v3.2: Check if beam is locked on THIS floor
                const isLocked = lockedBeams.includes(beam.id);

                if (isDeleted) {
                    // Draw deleted beam as red dashed
                    ctx.strokeStyle = '#ef4444';  // Red
                    ctx.setLineDash([6, 4]);
                    ctx.lineWidth = 2;
                } else if (isLocked) {
                    // v3.2: Draw locked beam with blue glow effect
                    ctx.strokeStyle = '#3b82f6';  // Blue for locked
                    ctx.setLineDash([]);
                    ctx.lineWidth = 5;  // Thicker line for locked
                } else {
                    ctx.strokeStyle = beam.direction === 'X' ? '#7c3aed' : '#10b981';
                    ctx.setLineDash([]);
                    ctx.lineWidth = 3;
                }

                ctx.beginPath();
                ctx.moveTo(x1, y1);
                ctx.lineTo(x2, y2);
                ctx.stroke();

                // v3.2: Draw lock icon for locked beams
                if (isLocked && state.showLabels) {
                    const midX = (x1 + x2) / 2;
                    const midY = (y1 + y2) / 2;
                    ctx.fillStyle = '#3b82f6';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText('🔒', midX, midY - 8);
                }
            }
            ctx.setLineDash([]);  // Reset

            // v3.0: Draw custom beams (intermediate framing beams)
            const customBeams = getFloorCustomBeams();
            ctx.lineWidth = 4;
            ctx.setLineDash([8, 4]);
            for (let cb of customBeams) {
                ctx.strokeStyle = '#f97316'; // Orange for custom beams
                // v3.0 FIX: dir=X means horizontal beam (runs along X), dir=Y means vertical
                if (cb.dir === 'X') {
                    // Horizontal beam at Y = cb.pos, running from x1 to x2
                    const y = cb.pos * state.scale + state.offsetY;
                    const x1 = cb.start * state.scale + state.offsetX;
                    const x2 = cb.end * state.scale + state.offsetX;
                    ctx.beginPath();
                    ctx.moveTo(x1, y);
                    ctx.lineTo(x2, y);
                    ctx.stroke();
                } else {
                    // Vertical beam at X = cb.pos, running from y1 to y2
                    const x = cb.pos * state.scale + state.offsetX;
                    const y1 = cb.start * state.scale + state.offsetY;
                    const y2 = cb.end * state.scale + state.offsetY;
                    ctx.beginPath();
                    ctx.moveTo(x, y1);
                    ctx.lineTo(x, y2);
                    ctx.stroke();
                }
                // Label
                if (state.showLabels) {
                    const lx = cb.dir === 'X' ? ((cb.start + cb.end) / 2) * state.scale + state.offsetX : cb.pos * state.scale + state.offsetX;
                    const ly = cb.dir === 'X' ? cb.pos * state.scale + state.offsetY : ((cb.start + cb.end) / 2) * state.scale + state.offsetY;
                    ctx.fillStyle = '#f97316';
                    ctx.font = 'bold 10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(cb.id, lx, ly - 5);
                }
            }
            ctx.setLineDash([]);

            // v3.0: Draw slab voids (any slab or sub-slab marked as void)
            for (let slab of state.slabs) {
                if (!slab.isVoid) continue;

                const px1 = slab.x1 * state.scale + state.offsetX;
                const py1 = slab.y1 * state.scale + state.offsetY;
                const pw = (slab.x2 - slab.x1) * state.scale;
                const ph = (slab.y2 - slab.y1) * state.scale;

                // Red fill with transparency
                ctx.fillStyle = 'rgba(239, 68, 68, 0.35)';
                ctx.fillRect(px1, py1, pw, ph);

                // Dashed red border
                ctx.strokeStyle = '#ef4444';
                ctx.lineWidth = 1;
                ctx.setLineDash([5, 5]);
                ctx.strokeRect(px1, py1, pw, ph);
                ctx.setLineDash([]);

                // Draw X pattern
                ctx.lineWidth = 2;
                ctx.beginPath();
                ctx.moveTo(px1, py1);
                ctx.lineTo(px1 + pw, py1 + ph);
                ctx.moveTo(px1 + pw, py1);
                ctx.lineTo(px1, py1 + ph);
                ctx.stroke();

                // Label
                if (state.showLabels) {
                    const cx = px1 + pw / 2;
                    const cy = py1 + ph / 2;
                    ctx.fillStyle = '#ef4444';
                    ctx.font = 'bold 8px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.textBaseline = 'middle';
                    ctx.fillText(`VOID`, cx, cy);
                }
            }

            // Draw columns
            for (let col of state.columns) {
                const x = col.x * state.scale + state.offsetX;
                const y = col.y * state.scale + state.offsetY;
                const size = 12;

                // v3.0: Use per-floor active state for current floor
                const currentFloorId = state.floors[state.currentFloorIndex]?.id;
                const isActiveOnThisFloor = isColumnActiveOnFloor(col, currentFloorId);

                // v3.0: Draw red X for columns inactive on THIS floor
                if (!isActiveOnThisFloor) {
                    ctx.strokeStyle = '#ef4444'; // Red
                    ctx.lineWidth = 3;
                    ctx.beginPath();
                    ctx.moveTo(x - size, y - size);
                    ctx.lineTo(x + size, y + size);
                    ctx.moveTo(x - size, y + size);
                    ctx.lineTo(x + size, y - size);
                    ctx.stroke();

                    // Show ID label even for inactive
                    if (state.showLabels) {
                        ctx.fillStyle = '#ef4444';
                        ctx.font = '10px sans-serif';
                        ctx.textAlign = 'center';
                        ctx.fillText(col.id, x, y - 16);
                    }
                    continue; // Skip normal drawing
                }

                // v3.0: Get column type for THIS floor
                const colType = getColumnTypeForFloor(col, currentFloorId);

                // Color by type (active columns)
                let color = '#10b981'; // Interior
                if (colType === 'corner') color = '#f59e0b';
                else if (colType === 'edge') color = '#00d4ff';

                ctx.fillStyle = color;
                ctx.fillRect(x - size / 2, y - size / 2, size, size);

                // Label
                if (state.showLabels) {
                    ctx.fillStyle = '#fff';
                    ctx.font = '10px sans-serif';
                    ctx.textAlign = 'center';
                    ctx.fillText(col.id, x, y);
                }
            }

            // Draw slab hatching (layer: areas)
            if (layerVisibility.areas) {
                for (let slab of state.slabs) {
                    if (slab.isVoid) continue;

                    const x1 = slab.x1 * state.scale + state.offsetX;
                    const y1 = slab.y1 * state.scale + state.offsetY;
                    const w = slab.width * state.scale;
                    const h = slab.height * state.scale;

                    // Light slab fill
                    ctx.fillStyle = 'rgba(200, 220, 240, 0.3)';
                    ctx.fillRect(x1, y1, w, h);

                    // Diagonal hatching
                    ctx.strokeStyle = 'rgba(100, 150, 200, 0.2)';
                    ctx.lineWidth = 0.5;
                    const spacing = 15;
                    ctx.beginPath();
                    for (let d = 0; d < w + h; d += spacing) {
                        const startX = Math.max(0, d - h);
                        const startY = Math.min(d, h);
                        const endX = Math.min(d, w);
                        const endY = Math.max(0, d - w);
                        ctx.moveTo(x1 + startX, y1 + startY);
                        ctx.lineTo(x1 + endX, y1 + endY);
                    }
                    ctx.stroke();
                }
            }
        }

        // ========== v3.0: STRUCTURAL PLAN RENDERING (AutoCAD STYLE) ==========
        // Clean wireframe like real AutoCAD drawings
        function drawStructuralPlan() {
            if (!ctx) return;

            const currentFloor = state.floors[state.currentFloorIndex];
            const deletedBeams = currentFloor?.deletedBeams || [];
            const currentFloorId = currentFloor?.id;

            // Member sizes in meters
            const beamWidthM = (state.defaultBeamB || 250) / 1000;
            const colBM = (state.defaultColB || 300) / 1000;
            const colHM = (state.defaultColH || colBM * 1000) / 1000;

            // Calculate grid coordinates
            let xCoords = [0];
            state.xSpans.forEach(s => xCoords.push(xCoords[xCoords.length - 1] + s));
            let yCoords = [0];
            state.ySpans.forEach(s => yCoords.push(yCoords[yCoords.length - 1] + s));
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            const maxX = xCoords[xCoords.length - 1];
            const maxY = yCoords[yCoords.length - 1];

            // v3.1: CLASSIC BLUEPRINT STYLE (White background, Black ink)
            // v3.3: Modern "Digital Blueprint" - Transparent canvas for CSS animation
            ctx.clearRect(0, 0, canvas.width, canvas.height);

            // ===== INFINITE MESH GRID (AutoCAD F7 Style) =====
            // Grid size: 50cm (0.5m)
            const gridSpacingM = 0.5;
            const gridSpacingPx = gridSpacingM * state.scale;
            // Glowing Grid Lines
            const gridColor = 'rgba(100, 116, 139, 0.6)'; // Darker Slate-500

            if (gridSpacingPx > 2) { // Lower threshold
                ctx.save(); // Save state for shadow effect
                ctx.beginPath();
                ctx.strokeStyle = gridColor;
                ctx.lineWidth = 0.8;

                // Glow effect for "umiilaw ilaw" look
                ctx.shadowBlur = 6;
                ctx.shadowColor = 'rgba(255, 255, 255, 0.8)';

                // Vertical Grid Lines
                const startX = ((state.offsetX % gridSpacingPx) + gridSpacingPx) % gridSpacingPx;
                for (let x = startX; x <= canvas.width; x += gridSpacingPx) {
                    ctx.moveTo(x, 0);
                    ctx.lineTo(x, canvas.height);
                }

                // Horizontal Grid Lines
                const startY = ((state.offsetY % gridSpacingPx) + gridSpacingPx) % gridSpacingPx;
                for (let y = startY; y <= canvas.height; y += gridSpacingPx) {
                    ctx.moveTo(0, y);
                    ctx.lineTo(canvas.width, y);
                }
                ctx.stroke();
                ctx.restore(); // Remove glow for other elements
            }

            // Classic engineering drawing colors (black ink on white paper)
            const COLOR_GRID = '#888888';     // Gray for centerlines
            const COLOR_BEAM = '#000000';     // Black for beams
            const COLOR_COL = '#000000';      // Black for columns (filled)
            const COLOR_SLAB = '#999999';     // Light gray for slab outlines
            const COLOR_TEXT = '#000000';     // Black for text
            const COLOR_BUBBLE = '#000000';   // Black for grid bubbles

            // ===== GRIDLINES (thin solid lines - structural centerlines) =====
            if (layerVisibility.grid) {
                ctx.setLineDash([]);  // v3.1: Solid lines, no centerline pattern
                ctx.strokeStyle = COLOR_GRID;
                ctx.lineWidth = 0.5;

                // Vertical gridlines (extend beyond building)
                xCoords.forEach(x => {
                    const px = x * state.scale + state.offsetX;
                    ctx.beginPath();
                    ctx.moveTo(px, state.offsetY - 60);
                    ctx.lineTo(px, maxY * state.scale + state.offsetY + 60);
                    ctx.stroke();
                });

                // Horizontal gridlines
                yCoords.forEach(y => {
                    const py = y * state.scale + state.offsetY;
                    ctx.beginPath();
                    ctx.moveTo(state.offsetX - 60, py);
                    ctx.lineTo(maxX * state.scale + state.offsetX + 60, py);
                    ctx.stroke();
                });
                ctx.setLineDash([]);

                // v3.1: Scale-relative sizing for text and bubbles
                const baseScale = 50;  // Reference scale
                const scaleFactor = Math.max(state.scale / baseScale, 0.5);  // Min 50% size
                const bubbleR = 12 * scaleFactor;
                const fontSize = Math.round(11 * scaleFactor);
                const bubbleOffset = 70 * scaleFactor;  // Distance from grid to bubbles
                const dimOffset = 45 * scaleFactor;     // Distance from grid to dimensions

                // Grid bubbles (CAD style circles with text)
                ctx.font = `bold ${fontSize}px Arial`;
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';

                // X-axis bubbles (top, letters) - OUTER edge
                xCoords.forEach((x, i) => {
                    const px = x * state.scale + state.offsetX;
                    const py = state.offsetY - bubbleOffset;  // v3.1: Scale-relative
                    // Circle outline (no fill)
                    ctx.strokeStyle = COLOR_BUBBLE;
                    ctx.lineWidth = 1.5 * scaleFactor;
                    ctx.beginPath();
                    ctx.arc(px, py, bubbleR, 0, Math.PI * 2);
                    ctx.stroke();
                    // Letter
                    ctx.fillStyle = COLOR_BUBBLE;
                    ctx.fillText(letters[i], px, py);
                });

                // Y-axis bubbles (left, numbers) - OUTER edge
                yCoords.forEach((y, i) => {
                    const px = state.offsetX - bubbleOffset - 10 * scaleFactor;  // v3.1: Scale-relative
                    const py = y * state.scale + state.offsetY;
                    ctx.strokeStyle = COLOR_BUBBLE;
                    ctx.lineWidth = 1.5;
                    ctx.beginPath();
                    ctx.arc(px, py, bubbleR, 0, Math.PI * 2);
                    ctx.stroke();
                    ctx.fillStyle = COLOR_BUBBLE;
                    ctx.fillText((i + 1).toString(), px, py);
                });

                // v3.1: DIMENSION LABELS (between bubbles and grid) - scale-relative
                const dimFontSize = Math.round(10 * scaleFactor);
                ctx.font = `bold ${dimFontSize}px Arial`;

                // X-span dimensions
                for (let i = 0; i < state.xSpans.length; i++) {
                    const x1 = xCoords[i] * state.scale + state.offsetX;
                    const x2 = xCoords[i + 1] * state.scale + state.offsetX;
                    const midX = (x1 + x2) / 2;
                    const topY = state.offsetY - dimOffset;  // Scale-relative

                    // Dimension line
                    ctx.strokeStyle = COLOR_TEXT;
                    ctx.lineWidth = 0.5 * scaleFactor;
                    ctx.beginPath();
                    ctx.moveTo(x1, topY);
                    ctx.lineTo(x2, topY);
                    ctx.stroke();

                    // End ticks
                    const tickSize = 3 * scaleFactor;
                    ctx.beginPath();
                    ctx.moveTo(x1, topY - tickSize);
                    ctx.lineTo(x1, topY + tickSize);
                    ctx.moveTo(x2, topY - tickSize);
                    ctx.lineTo(x2, topY + tickSize);
                    ctx.stroke();

                    // Dimension text (offset half text height above line)
                    const dimText = (state.xSpans[i] * 1000).toFixed(0);  // mm
                    const textOffsetX = 7 * scaleFactor;  // Half text height offset
                    ctx.fillStyle = COLOR_TEXT;
                    ctx.fillText(dimText, midX, topY - textOffsetX);
                }

                // Y-span dimensions (rotated text like CAD)
                const leftDimX = state.offsetX - dimOffset - 5 * scaleFactor;
                const textOffsetY = 7 * scaleFactor;  // Half text height offset
                for (let i = 0; i < state.ySpans.length; i++) {
                    const y1 = yCoords[i] * state.scale + state.offsetY;
                    const y2 = yCoords[i + 1] * state.scale + state.offsetY;
                    const midY = (y1 + y2) / 2;

                    // Dimension line
                    ctx.strokeStyle = COLOR_TEXT;
                    ctx.lineWidth = 0.5 * scaleFactor;
                    ctx.beginPath();
                    ctx.moveTo(leftDimX, y1);
                    ctx.lineTo(leftDimX, y2);
                    ctx.stroke();

                    // End ticks
                    const tickSize = 3 * scaleFactor;
                    ctx.beginPath();
                    ctx.moveTo(leftDimX - tickSize, y1);
                    ctx.lineTo(leftDimX + tickSize, y1);
                    ctx.moveTo(leftDimX - tickSize, y2);
                    ctx.lineTo(leftDimX + tickSize, y2);
                    ctx.stroke();

                    // Dimension text (rotated horizontal like CAD, no mask)
                    const dimText = (state.ySpans[i] * 1000).toFixed(0);  // mm

                    ctx.save();
                    ctx.translate(leftDimX - textOffsetY, midY);
                    ctx.rotate(-Math.PI / 2);  // Rotate text 90° counter-clockwise

                    // Text (no white background)
                    ctx.fillStyle = COLOR_TEXT;
                    ctx.fillText(dimText, 0, 0);
                    ctx.restore();
                }
            }

            // ===== SLAB OUTLINES (tributary areas) =====
            ctx.strokeStyle = COLOR_SLAB;
            ctx.lineWidth = 0.5;
            ctx.setLineDash([2, 2]); // Dashed for slab boundary
            for (let slab of state.slabs) {
                if (slab.isVoid) continue;
                const x1 = slab.x1 * state.scale + state.offsetX;
                const y1 = slab.y1 * state.scale + state.offsetY;
                const w = slab.width * state.scale;
                const h = slab.height * state.scale;
                ctx.strokeRect(x1, y1, w, h);
            }
            ctx.setLineDash([]);

            // ===== BEAMS (wireframe outlines - terminate at column faces) =====
            if (layerVisibility.beams) {
                const beamWidthPx = beamWidthM * state.scale;
                const colHalfPx = (colBM / 2) * state.scale;  // Half column width for termination

                // v3.1: Scale-relative sizing for beam labels
                const baseScale = 50;
                const beamScaleFactor = Math.max(state.scale / baseScale, 0.5);
                const beamLabelFontSize = Math.round(8 * beamScaleFactor);
                const beamLabelOffset = 6 * beamScaleFactor;

                // v3.1: Calculate grid boundaries for edge beam detection
                const totalX = state.xSpans.reduce((a, b) => a + b, 0);
                const totalY = state.ySpans.reduce((a, b) => a + b, 0);

                // v3.1: Helper to get beam alignment offset for edge beams
                function getBeamAlignmentOffset(beam) {
                    let offsetY = 0;
                    let offsetX = 0;

                    // Only apply alignment if edge alignment is enabled
                    if (state.columnAlignment !== 'outer') {
                        return { offsetX: 0, offsetY: 0 };
                    }

                    if (beam.direction === 'X') {
                        // Horizontal beam - check Y position
                        if (Math.abs(beam.y1) < 0.01) {
                            offsetY = beamWidthM / 2;  // Top edge - shift down
                        } else if (Math.abs(beam.y1 - totalY) < 0.01) {
                            offsetY = -beamWidthM / 2;  // Bottom edge - shift up
                        }
                    } else {
                        // Vertical beam - check X position
                        if (Math.abs(beam.x1) < 0.01) {
                            offsetX = beamWidthM / 2;  // Left edge - shift right
                        } else if (Math.abs(beam.x1 - totalX) < 0.01) {
                            offsetX = -beamWidthM / 2;  // Right edge - shift left
                        }
                    }

                    return { offsetX, offsetY };
                }

                ctx.strokeStyle = COLOR_BEAM;
                ctx.lineWidth = 1 * beamScaleFactor;

                for (let beam of state.beams) {
                    if (beam.isCustom) continue;
                    if (deletedBeams.includes(beam.id)) continue;

                    // v3.1: Apply alignment offset for edge beams
                    const beamAlignOffset = getBeamAlignmentOffset(beam);

                    // v3.2: Dash pattern scales with zoom
                    const dashLength = 6 * beamScaleFactor;
                    const gapLength = 3 * beamScaleFactor;

                    // v3.2: Get floor ID for beam naming
                    const floorId = currentFloor?.id || '2F';

                    // v3.2: Determine if beam is on edge and which edge
                    let isTopEdge = false, isBottomEdge = false, isLeftEdge = false, isRightEdge = false;
                    if (beam.direction === 'X') {
                        isTopEdge = Math.abs(beam.y1) < 0.01;
                        isBottomEdge = Math.abs(beam.y1 - totalY) < 0.01;
                    } else {
                        isLeftEdge = Math.abs(beam.x1) < 0.01;
                        isRightEdge = Math.abs(beam.x1 - totalX) < 0.01;
                    }

                    // v3.1: Terminate beams at column faces (offset by half column)
                    // v3.2: Account for column alignment offset when in Flush mode
                    if (beam.direction === 'X') {
                        // Horizontal beam
                        let y1 = (beam.y1 + beamAlignOffset.offsetY) * state.scale + state.offsetY;
                        let x1 = beam.x1 * state.scale + state.offsetX;
                        let x2 = beam.x2 * state.scale + state.offsetX;

                        // v3.2: Adjust termination for column alignment in Flush mode
                        let leftColOffset = 0, rightColOffset = 0;
                        if (state.columnAlignment === 'outer') {
                            // Left column is at x=0, shifted right
                            if (Math.abs(beam.x1) < 0.01) leftColOffset = colBM / 2;
                            // Right column at end, shifted left
                            if (Math.abs(beam.x2 - totalX) < 0.01) rightColOffset = colBM / 2;
                        }

                        x1 += colHalfPx + leftColOffset * state.scale;
                        x2 -= colHalfPx + rightColOffset * state.scale;

                        const beamTop = y1 - beamWidthPx / 2;
                        const beamBottom = y1 + beamWidthPx / 2;

                        // v3.2: Draw beam with proper line styles
                        // Edge beams: SOLID outside, DASHED inside
                        ctx.beginPath();

                        if (isTopEdge) {
                            // Top edge beam: TOP line = SOLID, BOTTOM line = DASHED
                            ctx.setLineDash([]);  // Solid for outer edge
                            ctx.moveTo(x1, beamTop); ctx.lineTo(x2, beamTop);  // Top (outer)
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([dashLength, gapLength]);  // Dashed for inner
                            ctx.moveTo(x1, beamBottom); ctx.lineTo(x2, beamBottom);  // Bottom (inner/slab side)
                            ctx.moveTo(x1, beamTop); ctx.lineTo(x1, beamBottom);  // Left end
                            ctx.moveTo(x2, beamTop); ctx.lineTo(x2, beamBottom);  // Right end
                            ctx.stroke();
                        } else if (isBottomEdge) {
                            // Bottom edge beam: BOTTOM line = SOLID, TOP line = DASHED
                            ctx.setLineDash([]);  // Solid for outer edge
                            ctx.moveTo(x1, beamBottom); ctx.lineTo(x2, beamBottom);  // Bottom (outer)
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([dashLength, gapLength]);  // Dashed for inner
                            ctx.moveTo(x1, beamTop); ctx.lineTo(x2, beamTop);  // Top (inner/slab side)
                            ctx.moveTo(x1, beamTop); ctx.lineTo(x1, beamBottom);  // Left end
                            ctx.moveTo(x2, beamTop); ctx.lineTo(x2, beamBottom);  // Right end
                            ctx.stroke();
                        } else {
                            // Interior beam: ALL dashed
                            ctx.setLineDash([dashLength, gapLength]);
                            ctx.strokeRect(x1, beamTop, x2 - x1, beamWidthPx);
                        }

                        // v3.1: Beam label ABOVE horizontal beam
                        const row = getGridRow(beam.y1);
                        const startCol = getGridCol(beam.x1);
                        const endCol = getGridCol(beam.x2);
                        const beamLabel = `B-${floorId}-${startCol}${row}${endCol}${row}`;
                        ctx.font = `${beamLabelFontSize}px Arial`;
                        ctx.fillStyle = COLOR_TEXT;
                        ctx.textAlign = 'center';
                        const labelY = beamTop - beamLabelOffset;
                        ctx.setLineDash([]);
                        ctx.fillText(beamLabel, (x1 + x2) / 2, labelY);
                    } else {
                        // Vertical beam
                        let x1 = (beam.x1 + beamAlignOffset.offsetX) * state.scale + state.offsetX;
                        let y1 = beam.y1 * state.scale + state.offsetY;
                        let y2 = beam.y2 * state.scale + state.offsetY;

                        // v3.2: Adjust termination for column alignment in Flush mode
                        let topColOffset = 0, bottomColOffset = 0;
                        if (state.columnAlignment === 'outer') {
                            // Top column at y=0, shifted down
                            if (Math.abs(beam.y1) < 0.01) topColOffset = colHM / 2;
                            // Bottom column at end, shifted up
                            if (Math.abs(beam.y2 - totalY) < 0.01) bottomColOffset = colHM / 2;
                        }

                        y1 += colHalfPx + topColOffset * state.scale;
                        y2 -= colHalfPx + bottomColOffset * state.scale;

                        const beamLeft = x1 - beamWidthPx / 2;
                        const beamRight = x1 + beamWidthPx / 2;

                        // v3.2: Draw beam with proper line styles
                        ctx.beginPath();

                        if (isLeftEdge) {
                            // Left edge beam: LEFT line = SOLID, RIGHT line = DASHED
                            ctx.setLineDash([]);  // Solid for outer edge
                            ctx.moveTo(beamLeft, y1); ctx.lineTo(beamLeft, y2);  // Left (outer)
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([dashLength, gapLength]);  // Dashed for inner
                            ctx.moveTo(beamRight, y1); ctx.lineTo(beamRight, y2);  // Right (inner/slab side)
                            ctx.moveTo(beamLeft, y1); ctx.lineTo(beamRight, y1);  // Top end
                            ctx.moveTo(beamLeft, y2); ctx.lineTo(beamRight, y2);  // Bottom end
                            ctx.stroke();
                        } else if (isRightEdge) {
                            // Right edge beam: RIGHT line = SOLID, LEFT line = DASHED
                            ctx.setLineDash([]);  // Solid for outer edge
                            ctx.moveTo(beamRight, y1); ctx.lineTo(beamRight, y2);  // Right (outer)
                            ctx.stroke();
                            ctx.beginPath();
                            ctx.setLineDash([dashLength, gapLength]);  // Dashed for inner
                            ctx.moveTo(beamLeft, y1); ctx.lineTo(beamLeft, y2);  // Left (inner/slab side)
                            ctx.moveTo(beamLeft, y1); ctx.lineTo(beamRight, y1);  // Top end
                            ctx.moveTo(beamLeft, y2); ctx.lineTo(beamRight, y2);  // Bottom end
                            ctx.stroke();
                        } else {
                            // Interior beam: ALL dashed
                            ctx.setLineDash([dashLength, gapLength]);
                            ctx.strokeRect(beamLeft, y1, beamWidthPx, y2 - y1);
                        }

                        // v3.2: Beam label LEFT of vertical beam (for all edge cases)
                        const col = getGridCol(beam.x1);
                        const startRow = getGridRow(beam.y1);
                        const endRow = getGridRow(beam.y2);
                        const beamLabel = `B-${floorId}-${col}${startRow}${col}${endRow}`;
                        ctx.font = `${beamLabelFontSize}px Arial`;
                        ctx.fillStyle = COLOR_TEXT;
                        ctx.save();
                        ctx.translate(beamLeft - beamLabelOffset, (y1 + y2) / 2);
                        ctx.rotate(-Math.PI / 2);
                        ctx.textAlign = 'center';
                        ctx.setLineDash([]);
                        ctx.fillText(beamLabel, 0, 0);
                        ctx.restore();
                    }
                }
                ctx.setLineDash([]);  // Reset line dash after beams
            }

            // v3.1: Helper functions to get grid labels from coordinates
            function getGridCol(x) {
                const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
                let cumX = 0;
                for (let i = 0; i < state.xSpans.length; i++) {
                    if (Math.abs(x - cumX) < 0.1) return letters[i];
                    cumX += state.xSpans[i];
                }
                if (Math.abs(x - cumX) < 0.1) return letters[state.xSpans.length];
                return '?';
            }

            function getGridRow(y) {
                let cumY = 0;
                for (let i = 0; i < state.ySpans.length; i++) {
                    if (Math.abs(y - cumY) < 0.1) return (i + 1).toString();
                    cumY += state.ySpans[i];
                }
                if (Math.abs(y - cumY) < 0.1) return (state.ySpans.length + 1).toString();
                return '?';
            }

            // ===== COLUMNS (with ANSI31 hatch for regular, different for planted/terminated) =====
            if (layerVisibility.cols) {
                const colWPx = colBM * state.scale;
                const colHPx = colHM * state.scale;

                // v3.1: Calculate grid boundaries for edge column detection
                const totalX = state.xSpans.reduce((a, b) => a + b, 0);
                const totalY = state.ySpans.reduce((a, b) => a + b, 0);

                // v3.1: Helper to get column alignment offset for edge columns
                function getColumnAlignmentOffset(col) {
                    let offsetX = 0;
                    let offsetY = 0;

                    // Only apply alignment if edge alignment is enabled
                    if (state.columnAlignment !== 'outer') {
                        return { offsetX: 0, offsetY: 0 };
                    }

                    // Check if on left edge (x = 0)
                    if (Math.abs(col.x) < 0.01) {
                        offsetX = colBM / 2;  // Shift right (inner face on gridline)
                    }
                    // Check if on right edge (x = totalX)
                    else if (Math.abs(col.x - totalX) < 0.01) {
                        offsetX = -colBM / 2;  // Shift left (inner face on gridline)
                    }

                    // Check if on top edge (y = 0)
                    if (Math.abs(col.y) < 0.01) {
                        offsetY = colHM / 2;  // Shift down (inner face on gridline)
                    }
                    // Check if on bottom edge (y = totalY)
                    else if (Math.abs(col.y - totalY) < 0.01) {
                        offsetY = -colHM / 2;  // Shift up (inner face on gridline)
                    }

                    return { offsetX, offsetY };
                }

                for (let col of state.columns) {
                    // v3.1: Apply alignment offset for edge columns
                    const alignOffset = getColumnAlignmentOffset(col);
                    const x = (col.x + alignOffset.offsetX) * state.scale + state.offsetX;
                    const y = (col.y + alignOffset.offsetY) * state.scale + state.offsetY;
                    const isActive = isColumnActiveOnFloor(col, currentFloorId);
                    const isPlanted = col.isPlanted || false;

                    const left = x - colWPx / 2;
                    const top = y - colHPx / 2;

                    if (!isActive) {
                        // v3.1: TERMINATED COLUMN - Hidden line (dashed), no hatch
                        ctx.strokeStyle = '#aaa';
                        ctx.lineWidth = 1;
                        ctx.setLineDash([4, 4]);
                        ctx.strokeRect(left, top, colWPx, colHPx);
                        ctx.setLineDash([]);
                    } else if (isPlanted) {
                        // v3.1: PLANTED COLUMN - Cross-hatch pattern (X pattern)
                        // Scale-relative hatch spacing
                        const baseScale = 50;
                        const hatchScaleFactor = Math.max(state.scale / baseScale, 0.5);

                        ctx.strokeStyle = COLOR_COL;
                        ctx.lineWidth = 1.5 * hatchScaleFactor;
                        ctx.strokeRect(left, top, colWPx, colHPx);

                        // Cross-hatch (both diagonals)
                        ctx.lineWidth = 0.5 * hatchScaleFactor;
                        const hatchSpacing = 4 * hatchScaleFactor;
                        ctx.beginPath();
                        for (let d = -colWPx - colHPx; d < colWPx + colHPx; d += hatchSpacing) {
                            // 45° lines
                            ctx.moveTo(left + d, top);
                            ctx.lineTo(left + d + colHPx, top + colHPx);
                            // -45° lines
                            ctx.moveTo(left + d + colHPx, top);
                            ctx.lineTo(left + d, top + colHPx);
                        }
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(left, top, colWPx, colHPx);
                        ctx.clip();
                        ctx.stroke();
                        ctx.restore();
                    } else {
                        // v3.1: REGULAR COLUMN - ANSI31 hatch (45° diagonal lines)
                        // Scale-relative hatch spacing
                        const baseScale = 50;
                        const hatchScaleFactor = Math.max(state.scale / baseScale, 0.5);

                        ctx.strokeStyle = COLOR_COL;
                        ctx.lineWidth = 1.5 * hatchScaleFactor;
                        ctx.strokeRect(left, top, colWPx, colHPx);

                        // ANSI31 diagonal hatch pattern (45° lines)
                        ctx.lineWidth = 0.5 * hatchScaleFactor;
                        const hatchSpacing = 3 * hatchScaleFactor;
                        ctx.save();
                        ctx.beginPath();
                        ctx.rect(left, top, colWPx, colHPx);
                        ctx.clip();

                        ctx.beginPath();
                        for (let d = -colWPx; d < colWPx + colHPx; d += hatchSpacing) {
                            ctx.moveTo(left + d, top);
                            ctx.lineTo(left + d + colHPx, top + colHPx);
                        }
                        ctx.stroke();
                        ctx.restore();
                    }

                    // Column ID label (only for active columns) - scale-relative
                    if (isActive) {
                        const baseScale = 50;
                        const colScaleFactor = Math.max(state.scale / baseScale, 0.5);
                        const colLabelFontSize = Math.round(8 * colScaleFactor);
                        const colLabelOffset = 10 * colScaleFactor;

                        ctx.fillStyle = COLOR_TEXT;
                        ctx.font = `${colLabelFontSize}px Arial`;
                        ctx.textAlign = 'center';
                        ctx.fillText(col.id, x, y + colHPx / 2 + colLabelOffset);
                    }
                }
            }
        }

        // ========== v3.2: FOUNDATION PLAN DRAWING ==========
        // Draws footings, tie beams, and column stubs - CAD style (white on black)
        function drawFoundationPlan() {
            // CAD Colors - match Structural Plan style
            const COLOR_BG = '#ffffff';       // White paper background
            const COLOR_OUTLINE = '#1a1a1a';  // Black ink for outlines
            const COLOR_GRID = '#6b7280';     // Gray for gridlines
            const COLOR_TEXT = '#1a1a1a';     // Black text
            const COLOR_DIM = '#374151';      // Dimension text
            const COLOR_HATCH = '#374151';    // Hatch pattern

            // Calculate total dimensions
            const totalX = state.xSpans.reduce((a, b) => a + b, 0);
            const totalY = state.ySpans.reduce((a, b) => a + b, 0);

            // Get footing and tie beam dimensions from state
            const tieBeamWidthM = (state.tieBeamWidth || 200) / 1000;
            const tieBeamDepthM = (state.tieBeamDepth || 350) / 1000;

            // Scale factor for relative sizing
            const baseScale = 50;
            const scaleFactor = Math.max(state.scale / baseScale, 0.5);
            const dashLength = 6 * scaleFactor;
            const gapLength = 3 * scaleFactor;
            const tieBeamWidthPx = tieBeamWidthM * state.scale;

            // Column dimensions
            const colBM = (state.defaultColB || 300) / 1000;
            const colHM = (state.defaultColH || colBM * 1000) / 1000;
            const colWPx = colBM * state.scale;
            const colHPx = colHM * state.scale;

            // v3.2: Column alignment offset support (same as Structural Plan)
            // When Flush mode is on, edge columns/footings align inner face to grid
            // NOTE: Positive offset = kick INWARD (toward building center)
            function getColumnAlignmentOffset(col) {
                if (state.columnAlignment !== 'outer') return { dx: 0, dy: 0 };

                const isLeftEdge = Math.abs(col.x) < 0.01;
                const isRightEdge = Math.abs(col.x - totalX) < 0.01;
                const isTopEdge = Math.abs(col.y) < 0.01;
                const isBottomEdge = Math.abs(col.y - totalY) < 0.01;

                let dx = 0, dy = 0;
                // Invert signs: kick INWARD (toward building center)
                if (isLeftEdge) dx = colBM / 2;    // Left edge → kick RIGHT
                if (isRightEdge) dx = -colBM / 2;  // Right edge → kick LEFT
                if (isTopEdge) dy = colHM / 2;     // Top edge → kick DOWN
                if (isBottomEdge) dy = -colHM / 2; // Bottom edge → kick UP

                return { dx, dy };
            }

            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            function getGridCol(x) {
                let cumX = 0;
                for (let i = 0; i < state.xSpans.length; i++) {
                    if (Math.abs(x - cumX) < 0.1) return letters[i];
                    cumX += state.xSpans[i];
                }
                if (Math.abs(x - cumX) < 0.1) return letters[state.xSpans.length];
                return '?';
            }
            function getGridRow(y) {
                let cumY = 0;
                for (let i = 0; i < state.ySpans.length; i++) {
                    if (Math.abs(y - cumY) < 0.1) return (i + 1).toString();
                    cumY += state.ySpans[i];
                }
                if (Math.abs(y - cumY) < 0.1) return (state.ySpans.length + 1).toString();
                return '?';
            }

            // v3.2: Get active columns (non-planted or ground-floor planted)
            const activeColumns = state.columns.filter(col => {
                if (col.active === false) return false;
                if (col.startFloor && col.startFloor !== 'GND' && col.startFloor !== '1F') return false;
                return true;
            });

            // v3.2: Group footings by size for type naming (F1, F2, etc.)
            const footingTypes = {};
            activeColumns.forEach(col => {
                const size = col.footingSize || 1.0;
                const sizeKey = (size * 1000).toFixed(0);  // Round to mm
                if (!footingTypes[sizeKey]) {
                    footingTypes[sizeKey] = {
                        size: size,
                        typeId: `F${Object.keys(footingTypes).length + 1}`,
                        columns: []
                    };
                }
                footingTypes[sizeKey].columns.push(col);
            });

            // Assign footing type to each column
            activeColumns.forEach(col => {
                const size = col.footingSize || 1.0;
                const sizeKey = (size * 1000).toFixed(0);
                col.footingTypeId = footingTypes[sizeKey]?.typeId || 'F1';
            });

            // ========== DRAW WHITE PAPER BACKGROUND (infinite like Structural Plan) ==========
            ctx.fillStyle = COLOR_BG;
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // ========== DRAW GRIDLINES (CENTER linetype - long-short-long dash) ==========
            if (layerVisibility.grid) {
                ctx.strokeStyle = COLOR_GRID;
                // CENTER linetype: long dash - short dash - long dash
                const centerDash = [12 * scaleFactor, 3 * scaleFactor, 3 * scaleFactor, 3 * scaleFactor];
                ctx.setLineDash(centerDash);
                ctx.lineWidth = 0.3 * scaleFactor;

                // X-axis grid lines (vertical)
                let cumX = 0;
                for (let i = 0; i <= state.xSpans.length; i++) {
                    const x = cumX * state.scale + state.offsetX;
                    ctx.beginPath();
                    ctx.moveTo(x, state.offsetY - 50 * scaleFactor);
                    ctx.lineTo(x, totalY * state.scale + state.offsetY + 50 * scaleFactor);
                    ctx.stroke();
                    if (i < state.xSpans.length) cumX += state.xSpans[i];
                }

                // Y-axis grid lines (horizontal)
                let cumY = 0;
                for (let i = 0; i <= state.ySpans.length; i++) {
                    const y = cumY * state.scale + state.offsetY;
                    ctx.beginPath();
                    ctx.moveTo(state.offsetX - 50 * scaleFactor, y);
                    ctx.lineTo(totalX * state.scale + state.offsetX + 50 * scaleFactor, y);
                    ctx.stroke();
                    if (i < state.ySpans.length) cumY += state.ySpans[i];
                }
            }

            // ========== DRAW FOOTINGS (dashed rectangles) ==========
            ctx.strokeStyle = COLOR_OUTLINE;
            ctx.lineWidth = 1 * scaleFactor;
            ctx.setLineDash([dashLength, gapLength]);

            activeColumns.forEach(col => {
                const footingSize = col.footingSize || 1.0;
                const footingSizePx = footingSize * state.scale;

                // v3.2: Apply alignment offset (Flush mode support)
                const offset = getColumnAlignmentOffset(col);
                const x = (col.x + offset.dx) * state.scale + state.offsetX;
                const y = (col.y + offset.dy) * state.scale + state.offsetY;

                // Draw footing (centered on column)
                const footingLeft = x - footingSizePx / 2;
                const footingTop = y - footingSizePx / 2;

                ctx.strokeRect(footingLeft, footingTop, footingSizePx, footingSizePx);
            });

            // ========== DRAW TIE BEAMS (dashed, connecting COLUMNS - continuous through footings) ==========
            ctx.strokeStyle = COLOR_OUTLINE;
            ctx.lineWidth = 0.8 * scaleFactor;
            ctx.setLineDash([dashLength, gapLength]);

            // Get unique grid positions
            const gridXPositions = [0];
            state.xSpans.forEach(span => gridXPositions.push(gridXPositions[gridXPositions.length - 1] + span));
            const gridYPositions = [0];
            state.ySpans.forEach(span => gridYPositions.push(gridYPositions[gridYPositions.length - 1] + span));

            // v3.2 FIX: In Flush mode, tie beams should have outer edge aligned to grid
            // Tie beam width in meters
            // (Using existing tieBeamWidthM from above)

            // Draw horizontal tie beams (along Y gridlines)
            gridYPositions.forEach((gridY, rowIdx) => {
                const colsOnRow = activeColumns.filter(c => Math.abs(c.y - gridY) < 0.01);
                colsOnRow.sort((a, b) => a.x - b.x);

                for (let i = 0; i < colsOnRow.length - 1; i++) {
                    const col1 = colsOnRow[i];
                    const col2 = colsOnRow[i + 1];

                    // Determine edge position for this row in Flush mode
                    const isTopEdge = Math.abs(gridY) < 0.01;
                    const isBottomEdge = Math.abs(gridY - totalY) < 0.01;

                    // In Flush mode, tie beam Y position adjusts so outer edge aligns with grid
                    let tieY = gridY;  // Default: centered on grid
                    if (state.columnAlignment === 'outer') {
                        if (isTopEdge) {
                            // Top edge: tie beam outer edge at Y=0, so center at tieBeamWidthM/2
                            tieY = tieBeamWidthM / 2;
                        } else if (isBottomEdge) {
                            // Bottom edge: tie beam outer edge at Y=totalY, so center at totalY - tieBeamWidthM/2
                            tieY = totalY - tieBeamWidthM / 2;
                        }
                    }

                    // X positions: from column edge to column edge (avoid overlapping column stubs)
                    const offset1 = getColumnAlignmentOffset(col1);
                    const offset2 = getColumnAlignmentOffset(col2);
                    const x1 = (col1.x + offset1.dx + colBM / 2) * state.scale + state.offsetX;  // Right edge of col1
                    const x2 = (col2.x + offset2.dx - colBM / 2) * state.scale + state.offsetX;  // Left edge of col2
                    const yPx = tieY * state.scale + state.offsetY;

                    ctx.strokeRect(x1, yPx - tieBeamWidthPx / 2, x2 - x1, tieBeamWidthPx);
                }
            });

            // Draw vertical tie beams (along X gridlines)
            gridXPositions.forEach((gridX, colIdx) => {
                const colsOnCol = activeColumns.filter(c => Math.abs(c.x - gridX) < 0.01);
                colsOnCol.sort((a, b) => a.y - b.y);

                for (let i = 0; i < colsOnCol.length - 1; i++) {
                    const col1 = colsOnCol[i];
                    const col2 = colsOnCol[i + 1];

                    // Determine edge position for this column in Flush mode
                    const isLeftEdge = Math.abs(gridX) < 0.01;
                    const isRightEdge = Math.abs(gridX - totalX) < 0.01;

                    // In Flush mode, tie beam X position adjusts so outer edge aligns with grid
                    let tieX = gridX;  // Default: centered on grid
                    if (state.columnAlignment === 'outer') {
                        if (isLeftEdge) {
                            // Left edge: tie beam outer edge at X=0, so center at tieBeamWidthM/2
                            tieX = tieBeamWidthM / 2;
                        } else if (isRightEdge) {
                            // Right edge: tie beam outer edge at X=totalX, so center at totalX - tieBeamWidthM/2
                            tieX = totalX - tieBeamWidthM / 2;
                        }
                    }

                    // Y positions: from column edge to column edge (avoid overlapping column stubs)
                    const offset1 = getColumnAlignmentOffset(col1);
                    const offset2 = getColumnAlignmentOffset(col2);
                    const y1 = (col1.y + offset1.dy + colHM / 2) * state.scale + state.offsetY;  // Bottom edge of col1
                    const y2 = (col2.y + offset2.dy - colHM / 2) * state.scale + state.offsetY;  // Top edge of col2
                    const xPx = tieX * state.scale + state.offsetX;

                    ctx.strokeRect(xPx - tieBeamWidthPx / 2, y1, tieBeamWidthPx, y2 - y1);
                }
            });

            // ========== DRAW COLUMN STUBS (hatched squares) ==========
            ctx.setLineDash([]);
            ctx.strokeStyle = COLOR_OUTLINE;
            ctx.lineWidth = 1.2 * scaleFactor;

            activeColumns.forEach(col => {
                // v3.2: Apply alignment offset (Flush mode support)
                const offset = getColumnAlignmentOffset(col);
                const x = (col.x + offset.dx) * state.scale + state.offsetX;
                const y = (col.y + offset.dy) * state.scale + state.offsetY;

                const left = x - colWPx / 2;
                const top = y - colHPx / 2;

                // Draw column stub outline
                ctx.strokeRect(left, top, colWPx, colHPx);

                // Add ANSI31 hatch
                const hatchSpacing = 3 * scaleFactor;
                ctx.save();
                ctx.beginPath();
                ctx.rect(left, top, colWPx, colHPx);
                ctx.clip();

                ctx.strokeStyle = COLOR_HATCH;
                ctx.lineWidth = 0.4 * scaleFactor;
                ctx.beginPath();
                for (let d = -colWPx; d < colWPx + colHPx; d += hatchSpacing) {
                    ctx.moveTo(left + d, top);
                    ctx.lineTo(left + d + colHPx, top + colHPx);
                }
                ctx.stroke();
                ctx.restore();
            });

            // ========== DRAW FOOTING LABELS (F1-A1 format) ==========
            ctx.setLineDash([]);
            ctx.fillStyle = COLOR_TEXT;
            const labelFontSize = Math.round(7 * scaleFactor);
            ctx.font = `bold ${labelFontSize}px Arial`;

            activeColumns.forEach(col => {
                // v3.2: Apply alignment offset (Flush mode support)
                const offset = getColumnAlignmentOffset(col);
                const x = (col.x + offset.dx) * state.scale + state.offsetX;
                const y = (col.y + offset.dy) * state.scale + state.offsetY;
                const footingSize = col.footingSize || 1.0;
                const footingSizePx = footingSize * state.scale;

                // F1-A1 format (Type + Grid)
                const gridLabel = getGridCol(col.x) + getGridRow(col.y);
                const footingLabel = `${col.footingTypeId}-${gridLabel}`;

                ctx.textAlign = 'center';
                ctx.fillText(footingLabel, x, y - footingSizePx / 2 - 5 * scaleFactor);

                // Footing dimension below
                ctx.font = `${Math.round(6 * scaleFactor)}px Arial`;
                ctx.fillStyle = COLOR_DIM;
                const dimText = `${(footingSize * 1000).toFixed(0)}×${(footingSize * 1000).toFixed(0)}`;
                ctx.fillText(dimText, x, y + footingSizePx / 2 + 10 * scaleFactor);

                ctx.font = `bold ${labelFontSize}px Arial`;
                ctx.fillStyle = COLOR_TEXT;
            });

            // ========== DRAW GRID LABELS WITH BUBBLES ==========
            ctx.setLineDash([]);
            ctx.fillStyle = COLOR_TEXT;
            const gridLabelSize = Math.round(9 * scaleFactor);
            ctx.font = `bold ${gridLabelSize}px Arial`;
            const labelOffset = 60 * scaleFactor;

            // Column letters (A, B, C...)
            cumX = 0;
            for (let i = 0; i <= state.xSpans.length; i++) {
                const x = cumX * state.scale + state.offsetX;
                const label = letters[i] || '?';
                const bubbleY = state.offsetY - labelOffset;

                // Draw bubble
                ctx.strokeStyle = COLOR_OUTLINE;
                ctx.lineWidth = 1 * scaleFactor;
                ctx.beginPath();
                ctx.arc(x, bubbleY, gridLabelSize * 0.9, 0, Math.PI * 2);
                ctx.stroke();

                // Draw label
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(label, x, bubbleY);

                if (i < state.xSpans.length) cumX += state.xSpans[i];
            }

            // Row numbers (1, 2, 3...)
            cumY = 0;
            for (let i = 0; i <= state.ySpans.length; i++) {
                const y = cumY * state.scale + state.offsetY;
                const label = (i + 1).toString();
                const bubbleX = state.offsetX - labelOffset;

                // Draw bubble
                ctx.beginPath();
                ctx.arc(bubbleX, y, gridLabelSize * 0.9, 0, Math.PI * 2);
                ctx.stroke();

                // Draw label
                ctx.fillText(label, bubbleX, y);

                if (i < state.ySpans.length) cumY += state.ySpans[i];
            }
            ctx.textBaseline = 'alphabetic';

            // ========== v3.2: DRAW SPAN DIMENSION LINES (like Structural Plan) ==========
            const dimOffset = labelOffset * 0.5;  // Closer to grid than bubbles
            const dimFontSize = Math.round(8 * scaleFactor);
            ctx.font = `bold ${dimFontSize}px Arial`;

            // X-span dimensions (between X gridlines, at top)
            const xCoords = [0];
            state.xSpans.forEach(span => xCoords.push(xCoords[xCoords.length - 1] + span));

            for (let i = 0; i < state.xSpans.length; i++) {
                const x1 = xCoords[i] * state.scale + state.offsetX;
                const x2 = xCoords[i + 1] * state.scale + state.offsetX;
                const midX = (x1 + x2) / 2;
                const topY = state.offsetY - dimOffset;

                // Dimension line
                ctx.strokeStyle = COLOR_DIM;
                ctx.lineWidth = 0.5 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(x1, topY);
                ctx.lineTo(x2, topY);
                ctx.stroke();

                // End ticks
                const tickSize = 3 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(x1, topY - tickSize);
                ctx.lineTo(x1, topY + tickSize);
                ctx.moveTo(x2, topY - tickSize);
                ctx.lineTo(x2, topY + tickSize);
                ctx.stroke();

                // Dimension text
                const dimText = (state.xSpans[i] * 1000).toFixed(0);  // mm
                ctx.fillStyle = COLOR_DIM;
                ctx.textAlign = 'center';
                ctx.fillText(dimText, midX, topY - 5 * scaleFactor);
            }

            // Y-span dimensions (at left, rotated text like CAD)
            const yCoords = [0];
            state.ySpans.forEach(span => yCoords.push(yCoords[yCoords.length - 1] + span));
            const leftDimX = state.offsetX - dimOffset - 5 * scaleFactor;

            for (let i = 0; i < state.ySpans.length; i++) {
                const y1 = yCoords[i] * state.scale + state.offsetY;
                const y2 = yCoords[i + 1] * state.scale + state.offsetY;
                const midY = (y1 + y2) / 2;

                // Dimension line
                ctx.strokeStyle = COLOR_DIM;
                ctx.lineWidth = 0.5 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(leftDimX, y1);
                ctx.lineTo(leftDimX, y2);
                ctx.stroke();

                // End ticks
                const tickSize = 3 * scaleFactor;
                ctx.beginPath();
                ctx.moveTo(leftDimX - tickSize, y1);
                ctx.lineTo(leftDimX + tickSize, y1);
                ctx.moveTo(leftDimX - tickSize, y2);
                ctx.lineTo(leftDimX + tickSize, y2);
                ctx.stroke();

                // Dimension text (rotated like CAD)
                const dimText = (state.ySpans[i] * 1000).toFixed(0);  // mm
                ctx.save();
                ctx.translate(leftDimX - 5 * scaleFactor, midY);
                ctx.rotate(-Math.PI / 2);
                ctx.fillStyle = COLOR_DIM;
                ctx.textAlign = 'center';
                ctx.fillText(dimText, 0, 0);
                ctx.restore();
            }

            // ========== DRAW FOOTING SCHEDULE TABLE (on plan) ==========
            const scheduleX = totalX * state.scale + state.offsetX + 80 * scaleFactor;
            const scheduleY = state.offsetY;
            const rowHeight = 14 * scaleFactor;
            const colWidths = [40 * scaleFactor, 60 * scaleFactor, 40 * scaleFactor];

            // Table header
            ctx.fillStyle = COLOR_TEXT;
            ctx.font = `bold ${Math.round(8 * scaleFactor)}px Arial`;
            ctx.textAlign = 'left';
            ctx.fillText('FOOTING SCHEDULE', scheduleX, scheduleY - 15 * scaleFactor);

            // Header row
            ctx.font = `bold ${Math.round(6 * scaleFactor)}px Arial`;
            let tableRow = 0;
            ctx.fillText('TYPE', scheduleX, scheduleY + rowHeight * tableRow);
            ctx.fillText('SIZE (mm)', scheduleX + colWidths[0], scheduleY + rowHeight * tableRow);
            ctx.fillText('THK', scheduleX + colWidths[0] + colWidths[1], scheduleY + rowHeight * tableRow);

            // Draw header underline
            ctx.strokeStyle = COLOR_OUTLINE;
            ctx.lineWidth = 0.5 * scaleFactor;
            ctx.beginPath();
            ctx.moveTo(scheduleX, scheduleY + rowHeight * tableRow + 3 * scaleFactor);
            ctx.lineTo(scheduleX + colWidths[0] + colWidths[1] + colWidths[2], scheduleY + rowHeight * tableRow + 3 * scaleFactor);
            ctx.stroke();

            // Data rows
            ctx.font = `${Math.round(6 * scaleFactor)}px Arial`;
            tableRow = 1;
            Object.values(footingTypes).forEach(ft => {
                const thicknessMm = 300;  // v3.2: Fixed 300mm for all (NSCP/NBC minimum)
                const sizeMm = Math.round(ft.size * 1000);

                ctx.fillText(ft.typeId, scheduleX, scheduleY + rowHeight * tableRow);
                ctx.fillText(`${sizeMm}×${sizeMm}`, scheduleX + colWidths[0], scheduleY + rowHeight * tableRow);
                ctx.fillText(`${thicknessMm}`, scheduleX + colWidths[0] + colWidths[1], scheduleY + rowHeight * tableRow);
                tableRow++;
            });

            // ========== DRAW TITLE ==========
            ctx.fillStyle = COLOR_TEXT;
            ctx.font = `bold ${Math.round(10 * scaleFactor)}px Arial`;
            ctx.textAlign = 'center';
            ctx.fillText('FOUNDATION PLAN', state.offsetX + totalX * state.scale / 2, state.offsetY - 85 * scaleFactor);

            ctx.font = `${Math.round(7 * scaleFactor)}px Arial`;
            ctx.fillStyle = COLOR_DIM;
            ctx.fillText(`Tie Beam: ${state.tieBeamWidth || 200}×${state.tieBeamDepth || 350}mm`,
                state.offsetX + totalX * state.scale / 2, state.offsetY - 72 * scaleFactor);
        }

        // ========== CONTROLS ==========
        function zoomIn() {
            state.scale *= 1.2;
            draw();
        }

        function zoomOut() {
            state.scale /= 1.2;
            draw();
        }

        function fitView() {
            if (state.columns.length === 0) return;

            const maxX = Math.max(...state.columns.map(c => c.x));
            const maxY = Math.max(...state.columns.map(c => c.y));

            const margin = 150;
            const scaleX = (canvas.width - margin * 2) / maxX;
            const scaleY = (canvas.height - margin * 2) / maxY;
            state.scale = Math.min(scaleX, scaleY, 80);

            state.offsetX = (canvas.width - maxX * state.scale) / 2;
            state.offsetY = (canvas.height - maxY * state.scale) / 2;

            draw();
        }

        function toggleLabels() {
            state.showLabels = !state.showLabels;
            document.getElementById('toggleLabels').classList.toggle('active', state.showLabels);
            draw();
        }

        // v2.2: Toggle Areas visualization
        function toggleAreas() {
            state.showAreas = !state.showAreas;
            const btn = document.getElementById('toggleAreas');
            if (btn) btn.classList.toggle('active', state.showAreas);
            draw();
        }

        // v2.4: Pan tool
        function togglePan() {
            state.isPanning = !state.isPanning;
            const btn = document.getElementById('panTool');
            if (btn) btn.classList.toggle('active', state.isPanning);
            canvas.style.cursor = state.isPanning ? 'grab' : 'default';
        }

        // v3.0 FIX: Update GF elevation height when dropdown changes
        // This fixes the bug where 2F beam levels weren't auto-adjusting
        function updateGFElevation(newHeight) {
            if (!state.gfSuspended) return;  // Only applies when GF Suspended is checked

            // Find the GF floor in state.floors
            const gfFloor = state.floors.find(f => f.id === 'GF');
            if (gfFloor) {
                gfFloor.height = newHeight;
                console.log(`v3.0: GF elevation updated to ${newHeight}m`);
            }

            // Also update all subsequent floor heights to stack properly
            let cumulativeHeight = newHeight;
            for (let i = 1; i < state.floors.length; i++) {
                const floor = state.floors[i];
                // Get base floor height (default 3m for normal floors)
                const baseHeight = floor.baseHeight || state.defaultFloorHeight || 3.0;
                cumulativeHeight += baseHeight;
                floor.elevation = cumulativeHeight;  // Store cumulative elevation
            }
        }

        // v3.0: Toggle sub-gridlines overlay
        function toggleSubGrid() {
            state.showSubGrid = !state.showSubGrid;
            const btn = document.getElementById('gridToggleBtn');
            if (btn) btn.classList.toggle('active', state.showSubGrid);
            draw();
        }

        // v3.0: Undo last action (restore deleted beam or slab)
        function undoLastAction() {
            if (state.undoStack.length === 0) {
                console.log('v3.0: Nothing to undo');
                return;
            }

            const action = state.undoStack.pop();
            console.log(`v3.0: Undoing ${action.type} on floor ${action.floorId}`, action.data);

            if (action.type === 'beam') {
                // Find the floor and restore the beam (undo deletion)
                const floor = state.floors.find(f => f.id === action.floorId);
                if (floor) {
                    if (!floor.customBeams) floor.customBeams = [];
                    floor.customBeams.push(action.data);
                    console.log(`v3.0: Restored beam ${action.data.id} on floor ${action.floorId}`);
                }
            } else if (action.type === 'beamAdd') {
                // v3.0 FIX: Remove a beam that was added (undo addition)
                const floor = state.floors.find(f => f.id === action.floorId);
                if (floor && floor.customBeams) {
                    const idx = floor.customBeams.findIndex(b => b.id === action.data.id);
                    if (idx >= 0) {
                        floor.customBeams.splice(idx, 1);
                        console.log(`v3.0: Removed beam ${action.data.id} from floor ${action.floorId}`);
                    }
                }
            } else if (action.type === 'voidSlab') {
                // Restore slab void state
                const floor = state.floors.find(f => f.id === action.floorId);
                if (floor) {
                    if (!floor.voidSlabs) floor.voidSlabs = [];
                    if (action.data.wasVoid) {
                        floor.voidSlabs.push(action.data.slabId);
                    } else {
                        const idx = floor.voidSlabs.indexOf(action.data.slabId);
                        if (idx >= 0) floor.voidSlabs.splice(idx, 1);
                    }
                }
            }


            updateUndoButton();
            calculate();
        }

        // v3.0: Update undo button state
        function updateUndoButton() {
            const btn = document.getElementById('undoBtn');
            if (btn) {
                const count = state.undoStack.length;
                btn.textContent = count > 0 ? `↩️ Undo (${count})` : '↩️ Undo';
                btn.classList.toggle('active', count > 0);
            }
        }

        // v3.0: Keyboard shortcut for undo (Ctrl+Z)
        document.addEventListener('keydown', (e) => {
            if (e.ctrlKey && e.key === 'z') {
                e.preventDefault();
                undoLastAction();
            }
        });

        // v3.0: Toggle snap-to-grid
        function toggleSnap() {
            state.snapEnabled = !state.snapEnabled;
            const btn = document.getElementById('snapToggleBtn');
            if (btn) {
                btn.textContent = state.snapEnabled ? '🧲 Snap: ON' : '🧲 Snap: OFF';
                btn.classList.toggle('active', state.snapEnabled);
            }
        }

        // v3.0: Theme switcher with localStorage persistence
        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('tributaryTheme', theme);

            // Update theme buttons active state
            document.querySelectorAll('.theme-option').forEach(btn => btn.classList.remove('active'));
            if (theme === 'dark') {
                document.getElementById('themeBtn-midnight')?.classList.add('active');
            } else if (theme === 'blueprint') {
                document.getElementById('themeBtn-papermatte')?.classList.add('active');
            }

            // Update canvas background for 3D view
            if (typeof draw === 'function') draw();

            // v3.0 FIX: Update 3D renderer background color based on theme
            if (typeof renderer3D !== 'undefined' && renderer3D) {
                if (theme === 'blueprint') {
                    renderer3D.setClearColor(0xf5f5f0); // Off-white for Blueprint
                } else {
                    renderer3D.setClearColor(0x0a0d10); // Dark for Midnight
                }
            }

            console.log(`v3.0: Theme changed to ${theme}`);
        }

        // v3.0: Load saved theme on startup
        function initTheme() {
            const savedTheme = localStorage.getItem('tributaryTheme') || 'dark'; // Default to Midnight
            setTheme(savedTheme);
        }

        // Toggle Settings Panel visibility
        function toggleSettingsPanel() {
            const panel = document.getElementById('settingsPanel');
            if (panel) panel.classList.toggle('hidden');
        }

        // Initialize theme on load
        document.addEventListener('DOMContentLoaded', initTheme);

        // v3.0: Update snap size from dropdown
        function updateSnapSize(value) {
            state.snapSize = parseFloat(value);
        }

        // v3.0: Snap a value to the grid
        function snapToGrid(value) {
            if (!state.snapEnabled) return value;
            return Math.round(value / state.snapSize) * state.snapSize;
        }

        function initPan() {
            canvas.addEventListener('mousedown', (e) => {
                if (state.isPanning) {
                    state.isDragging = true;
                    state.lastMouseX = e.clientX;
                    state.lastMouseY = e.clientY;
                    canvas.style.cursor = 'grabbing';
                }
            });

            canvas.addEventListener('mousemove', (e) => {
                if (state.isDragging && state.isPanning) {
                    const dx = e.clientX - state.lastMouseX;
                    const dy = e.clientY - state.lastMouseY;
                    state.offsetX += dx;
                    state.offsetY += dy;
                    state.lastMouseX = e.clientX;
                    state.lastMouseY = e.clientY;
                    draw();
                }
            });

            canvas.addEventListener('mouseup', () => {
                if (state.isDragging) {
                    state.isDragging = false;
                    canvas.style.cursor = state.isPanning ? 'grab' : 'default';
                }
            });

            canvas.addEventListener('mouseleave', () => {
                state.isDragging = false;
            });

            // v3.0 ADDITION: Click handler for deleting elements
            canvas.addEventListener('click', (e) => {
                // Skip if panning, adding beam, or dragging
                if (state.isPanning || state.addingBeam || state.isDragging) return;

                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Convert to world coordinates
                const worldX = (clickX - state.offsetX) / state.scale;
                const worldY = (clickY - state.offsetY) / state.scale;

                const currentFloorId = state.floors[state.currentFloorIndex]?.id;

                // 1. Check columns (highest priority - small targets) - v3.0: Show context menu
                for (let col of state.columns) {
                    const dx = Math.abs(worldX - col.x);
                    const dy = Math.abs(worldY - col.y);
                    const hitRadius = 0.5; // 0.5m hit area

                    if (dx < hitRadius && dy < hitRadius) {
                        console.log(`v3.0: Clicked column ${col.id} - showing menu`);
                        showColumnMenu(col.id, e.clientX, e.clientY);
                        return;
                    }
                }

                // 2. Check custom beams (next priority)
                const customBeams = getFloorCustomBeams();
                for (let cb of customBeams) {
                    let hit = false;
                    const tolerance = 0.3;

                    if (cb.dir === 'Y') {
                        // Horizontal beam at Y = cb.pos
                        if (Math.abs(worldY - cb.pos) < tolerance &&
                            worldX >= cb.start - tolerance &&
                            worldX <= cb.end + tolerance) {
                            hit = true;
                        }
                    } else {
                        // Vertical beam at X = cb.pos
                        if (Math.abs(worldX - cb.pos) < tolerance &&
                            worldY >= cb.start - tolerance &&
                            worldY <= cb.end + tolerance) {
                            hit = true;
                        }
                    }

                    if (hit) {
                        console.log(`v3.0: Clicked custom beam ${cb.id} - DELETING`);
                        deleteCustomBeam(cb.id);
                        return;
                    }
                }

                // 3. Check structural beams
                for (let beam of state.beams) {
                    const tolerance = 0.3;
                    const minX = Math.min(beam.x1, beam.x2) - tolerance;
                    const maxX = Math.max(beam.x1, beam.x2) + tolerance;
                    const minY = Math.min(beam.y1, beam.y2) - tolerance;
                    const maxY = Math.max(beam.y1, beam.y2) + tolerance;

                    // Check if click is within beam bounds and near the line
                    if (worldX >= minX && worldX <= maxX && worldY >= minY && worldY <= maxY) {
                        // Additional check: distance from beam line
                        let distToBeam;
                        if (beam.direction === 'X') {
                            // Horizontal beam - check Y distance
                            const beamY = (beam.y1 + beam.y2) / 2;
                            distToBeam = Math.abs(worldY - beamY);
                        } else {
                            // Vertical beam - check X distance
                            const beamX = (beam.x1 + beam.x2) / 2;
                            distToBeam = Math.abs(worldX - beamX);
                        }

                        if (distToBeam < tolerance * 2) {
                            // v3.0: If in planted column placement mode, show offset dialog
                            if (placingPlantedColumn) {
                                console.log(`v3.0: Clicked beam ${beam.id} for planted column placement`);
                                showBeamOffsetDialog(beam);
                                return;
                            }

                            // v3.2: Block deletion if beam is locked
                            const floor = state.floors[state.currentFloorIndex];
                            if (floor?.lockedBeams?.includes(beam.id)) {
                                console.log(`v3.2: Beam ${beam.id} is LOCKED - cannot delete via left-click`);
                                return;
                            }

                            // Normal mode: toggle beam deletion
                            console.log(`v3.0: Clicked structural beam ${beam.id} - toggling (per-floor)`);
                            toggleBeamDeleted(beam.id);
                            return;
                        }

                    }
                }

                // 4. Check slabs (lowest priority - largest areas)
                // v3.2: Only toggle to VOID if not already void (no accidental restore)
                for (let slab of state.slabs) {
                    if (worldX >= slab.x1 && worldX <= slab.x2 &&
                        worldY >= slab.y1 && worldY <= slab.y2) {
                        const floor = state.floors[state.currentFloorIndex];
                        const isVoid = floor?.voidSlabs?.includes(slab.id);
                        const isLocked = floor?.lockedSlabs?.includes(slab.id);

                        // v3.2: Block deletion if slab is locked
                        if (isLocked) {
                            console.log(`v3.2: Slab ${slab.id} is LOCKED - cannot delete via left-click`);
                            return;
                        }

                        if (isVoid) {
                            console.log(`v3.2: Clicked void slab ${slab.id} - already deleted, use right-click to restore`);
                        } else {
                            console.log(`v3.0: Clicked slab ${slab.id} - marking as VOID`);
                            toggleSlabVoid(slab.id);
                        }
                        return;
                    }
                }
            });

            // v3.2: RIGHT-CLICK context menu handler for easier deletion
            canvas.addEventListener('contextmenu', (e) => {
                e.preventDefault();  // Prevent default browser menu

                // Skip if panning or adding beam
                if (state.isPanning || state.addingBeam) return;

                const rect = canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Convert to world coordinates
                const worldX = (clickX - state.offsetX) / state.scale;
                const worldY = (clickY - state.offsetY) / state.scale;

                // 1. Check columns first
                for (let col of state.columns) {
                    const dx = Math.abs(worldX - col.x);
                    const dy = Math.abs(worldY - col.y);
                    const hitRadius = 0.5;

                    if (dx < hitRadius && dy < hitRadius) {
                        showColumnMenu(col.id, e.clientX, e.clientY);
                        return;
                    }
                }

                // 2. Check beams
                for (let beam of state.beams) {
                    const tolerance = 0.4;
                    const minX = Math.min(beam.x1, beam.x2) - tolerance;
                    const maxX = Math.max(beam.x1, beam.x2) + tolerance;
                    const minY = Math.min(beam.y1, beam.y2) - tolerance;
                    const maxY = Math.max(beam.y1, beam.y2) + tolerance;

                    if (worldX >= minX && worldX <= maxX && worldY >= minY && worldY <= maxY) {
                        let distToBeam;
                        if (beam.direction === 'X') {
                            distToBeam = Math.abs(worldY - (beam.y1 + beam.y2) / 2);
                        } else {
                            distToBeam = Math.abs(worldX - (beam.x1 + beam.x2) / 2);
                        }

                        if (distToBeam < tolerance * 2) {
                            showMemberMenu('beam', beam.id, e.clientX, e.clientY);
                            return;
                        }
                    }
                }

                // 3. Check slabs
                for (let slab of state.slabs) {
                    if (worldX >= slab.x1 && worldX <= slab.x2 &&
                        worldY >= slab.y1 && worldY <= slab.y2) {
                        showMemberMenu('slab', slab.id, e.clientX, e.clientY);
                        return;
                    }
                }
            });
        }


        function exportResults() {
            const data = {
                parameters: {
                    xSpans: state.xSpans,
                    ySpans: state.ySpans,
                    dlSuper: state.dlSuper,
                    liveLoad: state.liveLoad,
                    slabThickness: state.slabThickness,
                    numFloors: state.numFloors
                },
                columns: state.columns.map(c => ({
                    id: c.id,
                    type: c.type,
                    loadPerFloor: c.loadPerFloor,
                    totalLoad: c.totalLoad
                })),
                beams: state.beams.map(b => ({
                    id: b.id,
                    w: b.w,
                    R: b.Rleft
                }))
            };

            const blob = new Blob([JSON.stringify(data, null, 2)], { type: 'application/json' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'tributary_pro_v2_results.json';
            a.click();
        }

        // ========== v2.4: THREE.JS 3D VIEW ==========
        let scene3D, camera3D, renderer3D, controls3D;
        let meshes3D = [];
        let view3DInitialized = false;

        function init3D() {
            if (view3DInitialized) return;

            const container = document.getElementById('container3D');

            // Scene
            scene3D = new THREE.Scene();
            scene3D.background = new THREE.Color(0x0f1419);

            // Camera
            camera3D = new THREE.PerspectiveCamera(60, container.clientWidth / container.clientHeight, 0.1, 1000);
            camera3D.position.set(25, 30, 25);
            camera3D.lookAt(0, 5, 0);

            // Renderer
            renderer3D = new THREE.WebGLRenderer({ antialias: true });
            renderer3D.setSize(container.clientWidth, container.clientHeight);

            // v3.0 FIX: Set initial background color based on current theme
            const currentTheme = document.documentElement.getAttribute('data-theme') || 'dark';
            if (currentTheme === 'light') {
                renderer3D.setClearColor(0xf8fafc);
            } else if (currentTheme === 'blueprint') {
                renderer3D.setClearColor(0x0a1929);
            } else {
                renderer3D.setClearColor(0x0a0d10);
            }

            container.appendChild(renderer3D.domElement);

            // Orbit Controls - v3.0: Restored to default (LEFT = rotate, like v2.8)
            controls3D = new THREE.OrbitControls(camera3D, renderer3D.domElement);
            controls3D.enableDamping = true;
            controls3D.dampingFactor = 0.05;
            controls3D.target.set(0, 5, 0);

            // Lights
            scene3D.add(new THREE.AmbientLight(0xffffff, 0.5));
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(20, 30, 20);
            scene3D.add(dirLight);

            // Grid helper
            const grid = new THREE.GridHelper(50, 20, 0x00d4ff, 0x333333);
            scene3D.add(grid);

            // v3.0: Raycaster for 3D click detection
            const raycaster3D = new THREE.Raycaster();
            const mouse3D = new THREE.Vector2();

            // ========== v3.0: AutoCAD-Style Box Selection ==========
            // Create selection overlay canvas
            const selectionOverlay = document.createElement('canvas');
            selectionOverlay.id = 'selectionOverlay3D';
            selectionOverlay.style.cssText = 'position:absolute;top:0;left:0;width:100%;height:100%;pointer-events:none;z-index:10;';
            container.appendChild(selectionOverlay);
            const selCtx = selectionOverlay.getContext('2d');

            // Box selection state
            let boxSelecting = false;
            let boxStart = { x: 0, y: 0 };
            let boxEnd = { x: 0, y: 0 };
            let isWindowSelection = true; // Left-to-right = window, Right-to-left = crossing

            // Resize overlay with container
            function resizeSelectionOverlay() {
                selectionOverlay.width = container.clientWidth;
                selectionOverlay.height = container.clientHeight;
            }
            resizeSelectionOverlay();
            window.addEventListener('resize', resizeSelectionOverlay);

            // Draw selection box
            function drawSelectionBox() {
                selCtx.clearRect(0, 0, selectionOverlay.width, selectionOverlay.height);
                if (!boxSelecting) return;

                const x = Math.min(boxStart.x, boxEnd.x);
                const y = Math.min(boxStart.y, boxEnd.y);
                const w = Math.abs(boxEnd.x - boxStart.x);
                const h = Math.abs(boxEnd.y - boxStart.y);

                if (w < 5 && h < 5) return; // Too small to draw

                // v3.0: AutoCAD-style colors
                // Window (left-to-right): Blue with dashed border
                // Crossing (right-to-left): Green with solid border
                if (isWindowSelection) {
                    selCtx.fillStyle = 'rgba(0, 120, 255, 0.15)';
                    selCtx.strokeStyle = '#0078ff';
                    selCtx.setLineDash([8, 4]);
                } else {
                    selCtx.fillStyle = 'rgba(0, 255, 100, 0.15)';
                    selCtx.strokeStyle = '#00ff64';
                    selCtx.setLineDash([]);
                }
                selCtx.lineWidth = 2;
                selCtx.fillRect(x, y, w, h);
                selCtx.strokeRect(x, y, w, h);

                // Label
                selCtx.font = 'bold 12px Inter, system-ui, sans-serif';
                selCtx.fillStyle = isWindowSelection ? '#0078ff' : '#00ff64';
                selCtx.fillText(isWindowSelection ? '⬜ WINDOW' : '🔲 CROSSING', x + 5, y - 5);
            }

            // Project 3D mesh to 2D screen coordinates
            function getMeshScreenBounds(mesh) {
                if (!mesh.geometry) return null;

                mesh.geometry.computeBoundingBox();
                const box = mesh.geometry.boundingBox;
                if (!box) return null;

                // Get 8 corners of bounding box
                const corners = [
                    new THREE.Vector3(box.min.x, box.min.y, box.min.z),
                    new THREE.Vector3(box.min.x, box.min.y, box.max.z),
                    new THREE.Vector3(box.min.x, box.max.y, box.min.z),
                    new THREE.Vector3(box.min.x, box.max.y, box.max.z),
                    new THREE.Vector3(box.max.x, box.min.y, box.min.z),
                    new THREE.Vector3(box.max.x, box.min.y, box.max.z),
                    new THREE.Vector3(box.max.x, box.max.y, box.min.z),
                    new THREE.Vector3(box.max.x, box.max.y, box.max.z),
                ];

                let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;

                mesh.updateMatrixWorld(true);
                for (const corner of corners) {
                    const worldPos = corner.clone().applyMatrix4(mesh.matrixWorld);
                    worldPos.project(camera3D);

                    const screenX = (worldPos.x * 0.5 + 0.5) * selectionOverlay.width;
                    const screenY = (-worldPos.y * 0.5 + 0.5) * selectionOverlay.height;

                    minX = Math.min(minX, screenX);
                    minY = Math.min(minY, screenY);
                    maxX = Math.max(maxX, screenX);
                    maxY = Math.max(maxY, screenY);
                }

                return { minX, minY, maxX, maxY };
            }

            // Check if mesh is inside selection box
            function isMeshInSelection(mesh, selBox, windowMode) {
                const meshBounds = getMeshScreenBounds(mesh);
                if (!meshBounds) return false;

                if (windowMode) {
                    // Window: mesh must be fully enclosed
                    return meshBounds.minX >= selBox.minX && meshBounds.maxX <= selBox.maxX &&
                        meshBounds.minY >= selBox.minY && meshBounds.maxY <= selBox.maxY;
                } else {
                    // Crossing: mesh just needs to intersect
                    return !(meshBounds.maxX < selBox.minX || meshBounds.minX > selBox.maxX ||
                        meshBounds.maxY < selBox.minY || meshBounds.minY > selBox.maxY);
                }
            }

            // Handle box selection completion
            function completeBoxSelection() {
                const selBox = {
                    minX: Math.min(boxStart.x, boxEnd.x),
                    minY: Math.min(boxStart.y, boxEnd.y),
                    maxX: Math.max(boxStart.x, boxEnd.x),
                    maxY: Math.max(boxStart.y, boxEnd.y)
                };

                // Only process if box is large enough
                if (selBox.maxX - selBox.minX < 10 || selBox.maxY - selBox.minY < 10) {
                    return;
                }

                // Find all selected meshes with valid userData.type
                const selectedItems = [];
                for (const mesh of meshes3D) {
                    if (mesh.userData && mesh.userData.type && isMeshInSelection(mesh, selBox, isWindowSelection)) {
                        selectedItems.push({
                            mesh: mesh,
                            type: mesh.userData.type,
                            id: mesh.userData.id,
                            floorId: mesh.userData.floorId
                        });
                    }
                }

                if (selectedItems.length === 0) {
                    console.log('v3.0: No items selected');
                    return;
                }

                // Group by type for display
                const columns = selectedItems.filter(i => i.type === 'column');
                const beams = selectedItems.filter(i => i.type === 'beam');
                const customBeams = selectedItems.filter(i => i.type === 'customBeam');

                // Build confirmation message
                let msg = `🗑️ Delete ${selectedItems.length} item(s)?\n\n`;
                if (columns.length > 0) {
                    msg += `📍 Columns (${columns.length}): ${columns.map(c => c.id).join(', ')}\n`;
                }
                if (beams.length > 0) {
                    msg += `📏 Beams (${beams.length}): ${beams.slice(0, 10).map(b => b.id).join(', ')}${beams.length > 10 ? '...' : ''}\n`;
                }
                if (customBeams.length > 0) {
                    msg += `🪜 Custom Beams (${customBeams.length}): ${customBeams.map(b => b.id).join(', ')}\n`;
                }

                if (confirm(msg)) {
                    // Delete columns
                    for (const item of columns) {
                        toggleColumn(item.id);
                        console.log(`v3.0: Column ${item.id} deleted via box selection`);
                    }

                    // Delete beams
                    for (const item of beams) {
                        const floor = state.floors.find(f => f.id === item.floorId);
                        if (floor) {
                            if (!floor.deletedBeams) floor.deletedBeams = [];
                            if (!floor.deletedBeams.includes(item.id)) {
                                floor.deletedBeams.push(item.id);
                            }
                        }
                    }

                    // Delete custom beams
                    for (const item of customBeams) {
                        const floor = state.floors.find(f => f.id === item.floorId);
                        if (floor && floor.customBeams) {
                            floor.customBeams = floor.customBeams.filter(b => b.id !== item.id);
                        }
                    }

                    // Refresh
                    calculate();
                    render3DFrame();
                    console.log(`v3.0: Deleted ${selectedItems.length} items via ${isWindowSelection ? 'window' : 'crossing'} selection`);
                }
            }

            // Mouse event handlers for box selection
            renderer3D.domElement.addEventListener('mousedown', (event) => {
                // Only left mouse button
                if (event.button !== 0) return;

                const rect = renderer3D.domElement.getBoundingClientRect();
                boxStart = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };
                boxEnd = { ...boxStart };
                boxSelecting = true;

                // v3.0 FIX: Do NOT disable OrbitControls here - let orbit work by default
                // Only disable after significant drag in mousemove (see below)
                isWindowSelection = true;
            });

            renderer3D.domElement.addEventListener('mousemove', (event) => {
                if (!boxSelecting) return;

                const rect = renderer3D.domElement.getBoundingClientRect();
                boxEnd = {
                    x: event.clientX - rect.left,
                    y: event.clientY - rect.top
                };

                // AutoCAD-style: left-to-right = window, right-to-left = crossing
                isWindowSelection = boxEnd.x >= boxStart.x;

                // Disable orbit controls while box selecting (if box is large enough)
                if (Math.abs(boxEnd.x - boxStart.x) > 5 || Math.abs(boxEnd.y - boxStart.y) > 5) {
                    controls3D.enabled = false;
                }

                drawSelectionBox();
            });

            renderer3D.domElement.addEventListener('mouseup', (event) => {
                if (!boxSelecting) return;

                const wasBoxSelection = Math.abs(boxEnd.x - boxStart.x) > 10 || Math.abs(boxEnd.y - boxStart.y) > 10;

                boxSelecting = false;
                controls3D.enabled = true;
                selCtx.clearRect(0, 0, selectionOverlay.width, selectionOverlay.height);

                if (wasBoxSelection) {
                    completeBoxSelection();
                }
            });

            // v3.0: Double-click to delete individual 3D members
            renderer3D.domElement.addEventListener('dblclick', (event) => {
                const rect = renderer3D.domElement.getBoundingClientRect();

                // Calculate normalized device coordinates (-1 to +1)
                mouse3D.x = ((event.clientX - rect.left) / rect.width) * 2 - 1;
                mouse3D.y = -((event.clientY - rect.top) / rect.height) * 2 + 1;

                // Update raycaster
                raycaster3D.setFromCamera(mouse3D, camera3D);

                // Check intersections with all meshes
                const intersects = raycaster3D.intersectObjects(meshes3D, false);

                if (intersects.length === 0) {
                    console.log('v3.0: No object detected at click position');
                    return;
                }

                // v3.0 FIX: Find first intersected object with valid userData.type
                // Skip slabs and tributary surfaces that have empty userData
                const hit = intersects.find(i => i.object.userData && i.object.userData.type);

                if (!hit) {
                    console.log('v3.0: No structural member at click position (only slabs/surfaces)');
                    return;
                }

                const userData = hit.object.userData;

                console.log(`v3.0: Double-clicked ${userData.type}: ${userData.id}`);

                // Confirm and delete
                if (userData.type === 'column') {
                    if (confirm(`🗑️ Delete column ${userData.id}?`)) {
                        toggleColumn(userData.id);
                        calculate();
                        render3DFrame();
                        console.log(`v3.0: Column ${userData.id} deleted`);
                    }
                } else if (userData.type === 'beam') {
                    if (confirm(`🗑️ Delete beam ${userData.id}?`)) {
                        const floor = state.floors.find(f => f.id === userData.floorId);
                        if (floor) {
                            if (!floor.deletedBeams) floor.deletedBeams = [];
                            if (!floor.deletedBeams.includes(userData.id)) {
                                floor.deletedBeams.push(userData.id);
                            }
                            calculate();
                            render3DFrame();
                            console.log(`v3.0: Beam ${userData.id} deleted`);
                        }
                    }
                } else if (userData.type === 'customBeam') {
                    if (confirm(`🗑️ Delete custom beam ${userData.id}?`)) {
                        const floor = state.floors.find(f => f.id === userData.floorId);
                        if (floor && floor.customBeams) {
                            floor.customBeams = floor.customBeams.filter(b => b.id !== userData.id);
                            calculate();
                            render3DFrame();
                            console.log(`v3.0: Custom beam ${userData.id} deleted`);
                        }
                    }
                }
            });

            // ESC to cancel selection
            document.addEventListener('keydown', (event) => {
                if (event.key === 'Escape' && boxSelecting) {
                    boxSelecting = false;
                    controls3D.enabled = true;
                    selCtx.clearRect(0, 0, selectionOverlay.width, selectionOverlay.height);
                    console.log('v3.0: Box selection cancelled');
                }
            });

            view3DInitialized = true;
            animate3D();
        }

        function animate3D() {
            requestAnimationFrame(animate3D);
            if (controls3D) controls3D.update();
            if (renderer3D && scene3D && camera3D) {
                renderer3D.render(scene3D, camera3D);
            }
        }

        function render3DFrame() {
            if (!scene3D) return;

            // Clear previous meshes
            meshes3D.forEach(m => scene3D.remove(m));
            meshes3D = [];

            const colSize = 0.3;  // 300mm column
            const beamW = 0.25;   // 250mm beam width
            const beamH = 0.5;    // 500mm beam depth

            // Calculate grid bounds for centering
            const totalX = state.xSpans.reduce((a, b) => a + b, 0);
            const totalY = state.ySpans.reduce((a, b) => a + b, 0);
            const offsetX = -totalX / 2;
            const offsetZ = -totalY / 2;

            // Track cumulative height for proper floor stacking
            let cumulativeY = 0;

            // For each floor
            state.floors.forEach((floor, fi) => {
                const baseY = cumulativeY;  // Use cumulative height, not fi * height

                // COLUMNS - vertical boxes (skip inactive on THIS floor)
                for (let col of state.columns) {
                    // v3.0: Skip columns inactive on THIS floor (not global col.active)
                    if (!isColumnActiveOnFloor(col, floor.id)) continue;

                    // v3.0: Skip planted columns on floors BELOW their startFloor
                    if (col.startFloor && !isFloorAtOrAbove(floor.id, col.startFloor)) {
                        continue; // Don't render this column segment on floors below startFloor
                    }

                    // v3.0: Custom planted columns (placed on beams) - check isPlanted and startFloor
                    if (col.isPlanted && col.startFloor && !isFloorAtOrAbove(floor.id, col.startFloor)) {
                        continue; // Don't render beam-placed planted columns below their start floor
                    }

                    const geo = new THREE.BoxGeometry(colSize, floor.height, colSize);

                    // Column color by type - planted columns get purple color
                    let colColor = col.type === 'corner' ? 0xf59e0b :
                        col.type === 'edge' ? 0x00d4ff : 0x10b981;

                    // v3.0: Planted columns (beam-placed) get purple to distinguish
                    if (col.isPlanted) colColor = 0x8b5cf6;

                    const mat = new THREE.MeshStandardMaterial({ color: colColor });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(col.x + offsetX, baseY + floor.height / 2, col.y + offsetZ);

                    // v3.0: Store data for click detection
                    mesh.userData = { type: 'column', id: col.id, floorId: floor.id, isPlanted: col.isPlanted };

                    scene3D.add(mesh);
                    meshes3D.push(mesh);
                }

                // Note: cumulativeY updated at end of forEach iteration

                // BEAMS - at top of each floor (skip if connected to inactive columns OR deleted on this floor)
                const floorDeletedBeams = floor.deletedBeams || [];  // v3.0: Per-floor deleted beams

                for (let beam of state.beams) {
                    // v3.0 FIX: Skip custom beams - they are drawn separately below
                    if (beam.isCustom) continue;

                    // v3.0: Skip beams deleted on THIS floor
                    if (floorDeletedBeams.includes(beam.id)) continue;

                    // v2.7: Skip beams connected to inactive columns
                    const startCol = state.columns.find(c => c.id === beam.startCol);
                    const endCol = state.columns.find(c => c.id === beam.endCol);
                    if ((startCol && startCol.active === false) || (endCol && endCol.active === false)) {
                        continue;
                    }


                    // v3.0: Get actual column sizes at beam ends
                    const startColSize = startCol ? (startCol.suggestedB || 300) / 1000 : 0.3;
                    const endColSize = endCol ? (endCol.suggestedB || 300) / 1000 : 0.3;

                    // v3.0 FIX: Subtract half column width from each end for non-overlapping BOQ
                    const rawLength = Math.sqrt(
                        Math.pow(beam.x2 - beam.x1, 2) +
                        Math.pow(beam.y2 - beam.y1, 2)
                    );
                    const clearLength = rawLength - (startColSize / 2) - (endColSize / 2);
                    const length = Math.max(0.1, clearLength);  // Ensure positive length

                    // Create beam geometry with correct length
                    const geo = beam.direction === 'X'
                        ? new THREE.BoxGeometry(length, beamH, beamW)
                        : new THREE.BoxGeometry(beamW, beamH, length);

                    // Beam color by direction
                    const mat = new THREE.MeshStandardMaterial({
                        color: beam.direction === 'X' ? 0x7c3aed : 0x10b981
                    });
                    const mesh = new THREE.Mesh(geo, mat);

                    // Position at midpoint
                    const mx = (beam.x1 + beam.x2) / 2 + offsetX;
                    const mz = (beam.y1 + beam.y2) / 2 + offsetZ;
                    mesh.position.set(mx, baseY + floor.height - beamH / 2, mz);

                    // v3.0: Store data for click detection
                    mesh.userData = { type: 'beam', id: beam.id, floorId: floor.id };

                    scene3D.add(mesh);
                    meshes3D.push(mesh);
                }

                // v3.0: CUSTOM BEAMS - orange intermediate framing beams
                const customBeams = floor.customBeams || [];
                for (let cb of customBeams) {
                    let length, cbX, cbZ;
                    // v3.0 FIX: dir='X' means beam runs horizontally (along X axis), constant Y
                    // dir='Y' means beam runs vertically (along Y axis), constant X
                    if (cb.dir === 'X') {
                        // Horizontal beam at Y = cb.pos, runs from cb.start to cb.end in X
                        length = cb.end - cb.start;
                        cbX = (cb.start + cb.end) / 2 + offsetX;
                        cbZ = cb.pos + offsetZ;
                    } else {
                        // Vertical beam at X = cb.pos, runs from cb.start to cb.end in Y
                        length = cb.end - cb.start;
                        cbX = cb.pos + offsetX;
                        cbZ = (cb.start + cb.end) / 2 + offsetZ;
                    }

                    // Geometry: X beams are wide in X, Y beams are wide in Z
                    const geo = cb.dir === 'X'
                        ? new THREE.BoxGeometry(length, beamH, beamW)
                        : new THREE.BoxGeometry(beamW, beamH, length);

                    const mat = new THREE.MeshStandardMaterial({
                        color: 0xf97316  // Orange for custom beams
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.position.set(cbX, baseY + floor.height - beamH / 2, cbZ);
                    mesh.userData = { type: 'customBeam', id: cb.id, floorId: floor.id };

                    scene3D.add(mesh);
                    meshes3D.push(mesh);
                }

                // SLABS - transparent horizontal planes (skip void slabs on THIS floor)
                const floorVoidSlabs = floor.voidSlabs || [];  // v3.0: Per-floor void slabs

                for (let slab of state.slabs) {
                    // v3.0: Skip void slabs on THIS floor (not slab.isVoid which is current floor only)
                    if (floorVoidSlabs.includes(slab.id)) continue;

                    const geo = new THREE.PlaneGeometry(slab.lx * 0.95, slab.ly * 0.95);
                    const mat = new THREE.MeshStandardMaterial({
                        color: slab.isTwoWay ? 0x00d4ff : 0x7c3aed,
                        transparent: true,
                        opacity: 0.4,

                        side: THREE.DoubleSide
                    });
                    const mesh = new THREE.Mesh(geo, mat);
                    mesh.rotation.x = -Math.PI / 2;
                    mesh.position.set(
                        slab.x1 + slab.lx / 2 + offsetX,
                        baseY + floor.height + 0.01,
                        slab.y1 + slab.ly / 2 + offsetZ
                    );
                    scene3D.add(mesh);
                    meshes3D.push(mesh);
                }

                // Update cumulative height for next floor
                cumulativeY += floor.height;
            });

            // v2.6: ELEVATED GF BEAMS - when gfSuspended is checked
            const elevationHeight = state.gfSuspended
                ? (parseFloat(document.getElementById('elevationHeight')?.value) || 1.2)
                : 0;

            if (state.gfSuspended && elevationHeight > 0) {
                for (let beam of state.beams) {
                    // v3.0 FIX: Skip custom beams - they belong to specific floors only
                    if (beam.isCustom) continue;

                    const length = Math.sqrt(
                        Math.pow(beam.x2 - beam.x1, 2) +
                        Math.pow(beam.y2 - beam.y1, 2)
                    );

                    const geo = beam.direction === 'X'
                        ? new THREE.BoxGeometry(length, beamH, beamW)
                        : new THREE.BoxGeometry(beamW, beamH, length);

                    const mat = new THREE.MeshStandardMaterial({
                        color: 0x22d3ee  // Cyan for elevated GF beams
                    });
                    const mesh = new THREE.Mesh(geo, mat);

                    const mx = (beam.x1 + beam.x2) / 2 + offsetX;
                    const mz = (beam.y1 + beam.y2) / 2 + offsetZ;
                    // Position at elevation height (below GF floor)
                    mesh.position.set(mx, elevationHeight - beamH / 2, mz);

                    scene3D.add(mesh);
                    meshes3D.push(mesh);
                }
            }

            // v2.6: FOOTINGS - all leveled at top (same top level, varying thickness)
            const footingDepth = state.footingDepth;
            const maxThick = Math.max(...state.columns.map(c => c.footingThick || 0.3));

            for (let col of state.columns) {
                // v2.7: Skip footings for inactive columns
                if (col.active === false) continue;

                // v3.0 FIX: Skip footings for planted columns (they sit on beams, not ground)
                if (col.startFloor || col.isPlanted) continue;

                const size = col.footingSize || 0.8;
                // Increase thickness for smaller footings so all tops are level
                const baseThick = col.footingThick || 0.3;
                const adjustedThick = maxThick;  // All same thickness for level top

                // Footing geometry
                const geo = new THREE.BoxGeometry(size, adjustedThick, size);
                const mat = new THREE.MeshStandardMaterial({
                    color: 0x8b5cf6,  // Purple for footings
                    transparent: true,
                    opacity: 0.8
                });
                const mesh = new THREE.Mesh(geo, mat);

                // Position below ground - all tops at same level
                const footingTopY = -footingDepth + adjustedThick;
                mesh.position.set(
                    col.x + offsetX,
                    footingTopY - adjustedThick / 2,
                    col.y + offsetZ
                );
                scene3D.add(mesh);
                meshes3D.push(mesh);

                // Footing pedestal (connecting column to footing)
                const pedestalGeo = new THREE.BoxGeometry(colSize * 1.2, footingDepth - adjustedThick, colSize * 1.2);
                const pedestalMat = new THREE.MeshStandardMaterial({ color: 0x666666 });
                const pedestal = new THREE.Mesh(pedestalGeo, pedestalMat);
                pedestal.position.set(
                    col.x + offsetX,
                    -(footingDepth - adjustedThick) / 2,
                    col.y + offsetZ
                );
                scene3D.add(pedestal);
                meshes3D.push(pedestal);
            }

            // v2.8: TIE BEAMS - using calculated sizing from longest span
            const tieBeamH = state.tieBeamH;  // Calculated: max(longestSpan/10, 0.3m)
            const tieBeamW = state.tieBeamW;  // Calculated: max(largestFooting, 0.25m)
            const tieBeamTopY = -footingDepth + maxThick + tieBeamH / 2;  // On top of footings

            for (let beam of state.beams) {
                // v3.0 FIX: Skip custom beams - they belong to specific floors only
                if (beam.isCustom) continue;
                // v3.0 FIX: Skip cantilever and edge beams - tie beams only connect main grid columns
                if (beam.isCantilever || beam.isEdgeBeam) continue;

                const length = Math.sqrt(
                    Math.pow(beam.x2 - beam.x1, 2) +
                    Math.pow(beam.y2 - beam.y1, 2)
                );

                const geo = beam.direction === 'X'
                    ? new THREE.BoxGeometry(length, tieBeamH, tieBeamW)
                    : new THREE.BoxGeometry(tieBeamW, tieBeamH, length);

                const mat = new THREE.MeshStandardMaterial({
                    color: 0x666666  // Gray for tie beams
                });
                const mesh = new THREE.Mesh(geo, mat);

                const mx = (beam.x1 + beam.x2) / 2 + offsetX;
                const mz = (beam.y1 + beam.y2) / 2 + offsetZ;
                mesh.position.set(mx, tieBeamTopY, mz);

                scene3D.add(mesh);
                meshes3D.push(mesh);
            }

            // Update camera target to center (including footings)
            const centerY = (state.floors.length * 3) / 2 - footingDepth / 2;
            controls3D.target.set(0, centerY, 0);
            camera3D.position.set(totalX * 1.5, centerY + 15, totalY * 1.5);
        }

        function setView(mode) {
            const canvas2D = document.getElementById('mainCanvas');
            const container3D = document.getElementById('container3D');
            const btn2D = document.getElementById('view2D');
            const btn3D = document.getElementById('view3D');

            if (mode === '2d') {
                canvas2D.style.display = 'block';
                container3D.classList.remove('active');
                btn2D.classList.add('active');
                btn3D.classList.remove('active');
            } else {
                canvas2D.style.display = 'none';
                container3D.classList.add('active');
                btn2D.classList.remove('active');
                btn3D.classList.add('active');

                if (!view3DInitialized) {
                    init3D();
                }
                render3DFrame();

                // Resize renderer
                const rect = container3D.getBoundingClientRect();
                if (renderer3D && rect.width > 0 && rect.height > 0) {
                    renderer3D.setSize(rect.width, rect.height);
                    camera3D.aspect = rect.width / rect.height;
                    camera3D.updateProjectionMatrix();
                }
            }
        }

        // ========== v3.0: CONCRETE VOLUME CALCULATION ==========

        /**
         * Calculate and display concrete volumes for all structural elements
         */
        function updateConcreteVolume() {
            const volBody = document.getElementById('concreteVolumeBody');
            const totalEl = document.getElementById('totalConcreteVolume');
            if (!volBody) return;

            // Calculate total building height (sum of all floor heights)
            const totalHeight = state.floors.reduce((sum, f) => sum + (f.height || 3.0), 0);

            // COLUMNS: b × h × height × count (active columns only)
            const activeColumns = state.columns.filter(c => c.active !== false);
            let columnVol = 0;
            for (let col of activeColumns) {
                const b = (col.suggestedB || 300) / 1000;  // Convert to meters
                const h = (col.suggestedH || 300) / 1000;
                // Column height depends on startFloor (planted columns are shorter)
                let colHeight = totalHeight;
                if (col.startFloor) {
                    const startIdx = state.floors.findIndex(f => f.id === col.startFloor);
                    if (startIdx > 0) {
                        colHeight = state.floors.slice(startIdx).reduce((sum, f) => sum + (f.height || 3.0), 0);
                    }
                }
                columnVol += b * h * colHeight;
            }

            // BEAMS: b × h × span × count (one floor only, multiply by floors for total)
            // v3.0 FIX: Deduct column intersection volume to avoid overlap
            let beamVol = 0;
            const numFloors = state.floors.length;
            const avgColWidth = 0.3;  // Average column width in meters (300mm)
            for (let beam of state.beams) {
                const b = (beam.suggestedB || 300) / 1000;
                const h = (beam.suggestedH || 400) / 1000;
                // Deduct column width from beam length (assumes beam sits on columns at each end)
                let effectiveSpan = beam.span;
                if (!beam.isCantilever) {
                    effectiveSpan -= avgColWidth;  // Full column width for continuous beam
                } else {
                    effectiveSpan -= avgColWidth / 2;  // Half for cantilever anchor
                }
                beamVol += b * h * Math.max(effectiveSpan, 0);
            }
            beamVol *= numFloors;  // Beams on each floor


            // SLABS: area × thickness (net area, accounts for openings)
            let slabVol = 0;
            const currentFloor = state.floors[state.currentFloorIndex] || state.floors[0];
            const slabThickness = (currentFloor?.slabThickness || 150) / 1000;
            for (let slab of state.slabs) {
                if (!slab.isCantilever) {
                    slabVol += (slab.netArea || slab.area) * slabThickness;
                } else {
                    slabVol += slab.area * slabThickness;  // Cantilever slabs
                }
            }
            slabVol *= numFloors;  // Slabs on each floor

            // FOOTINGS: size × size × depth (300mm min)
            let footingVol = 0;
            const footingDepth = 0.3;  // Standard 300mm
            for (let col of activeColumns) {
                if (col.footingSize && !col.startFloor) {  // Only non-planted columns have footings
                    footingVol += col.footingSize * col.footingSize * footingDepth;
                }
            }

            // TIE BEAMS: simplified - longest span / 10 for size, perimeter for length
            const maxSpanX = Math.max(...state.xSpans);
            const maxSpanY = Math.max(...state.ySpans);
            const tieBeamSize = Math.max(maxSpanX, maxSpanY) / 10;
            const totalX = state.xSpans.reduce((a, b) => a + b, 0);
            const totalY = state.ySpans.reduce((a, b) => a + b, 0);
            const tieBeamLength = (totalX * (state.ySpans.length + 1)) + (totalY * (state.xSpans.length + 1));
            const tieBeamVol = tieBeamSize * tieBeamSize * tieBeamLength;

            // Total
            const total = columnVol + beamVol + slabVol + footingVol + tieBeamVol;

            // Update table
            volBody.innerHTML = `
                <tr><td>Columns</td><td>${activeColumns.length}</td><td>${columnVol.toFixed(2)}</td></tr>
                <tr><td>Beams</td><td>${state.beams.length * numFloors}</td><td>${beamVol.toFixed(2)}</td></tr>
                <tr><td>Slabs</td><td>${state.slabs.length * numFloors}</td><td>${slabVol.toFixed(2)}</td></tr>
                <tr><td>Footings</td><td>${activeColumns.filter(c => !c.startFloor).length}</td><td>${footingVol.toFixed(2)}</td></tr>
                <tr><td>Tie Beams</td><td>-</td><td>${tieBeamVol.toFixed(2)}</td></tr>
            `;

            totalEl.textContent = total.toFixed(2) + ' m³';

            console.log('v3.0: Concrete volume calculated:', {
                columns: columnVol.toFixed(2),
                beams: beamVol.toFixed(2),
                slabs: slabVol.toFixed(2),
                footings: footingVol.toFixed(2),
                tieBeams: tieBeamVol.toFixed(2),
                total: total.toFixed(2)
            });
        }

        // ========== v3.0: SAVE/LOAD PROJECT ==========


        /**
         * Save current project to JSON file
         */
        function saveProject() {
            try {
                // Collect saveable state
                const projectData = {
                    version: '2.8',
                    savedAt: new Date().toISOString(),
                    xSpans: state.xSpans || [4.0, 4.0],
                    ySpans: state.ySpans || [5.0, 5.0],
                    cantilevers: state.cantilevers || { top: [], bottom: [], left: [], right: [] },
                    floors: (state.floors || []).map(f => ({
                        id: f.id,
                        name: f.name,
                        dlSuper: f.dlSuper,
                        liveLoad: f.liveLoad,
                        slabThickness: f.slabThickness,
                        height: f.height,
                        wallLoad: f.wallLoad,
                        isRoof: f.isRoof
                    })),
                    currentFloorIndex: state.currentFloorIndex || 0,
                    // Column customizations
                    columnOverrides: (state.columns || []).map(c => ({
                        id: c.id,
                        active: c.active,
                        activePerFloor: c.activePerFloor || {},
                        startFloor: c.startFloor,
                        overrideB: c.overrideB,
                        overrideH: c.overrideH
                    })),
                    // Slab openings
                    slabOpenings: (state.slabs || []).map(s => ({
                        id: s.id,
                        openingW: s.openingW,
                        openingH: s.openingH
                    })).filter(s => s.openingW || s.openingH),
                    // Beam overrides
                    beamOverrides: (state.beams || []).map(b => ({
                        id: b.id,
                        overrideB: b.overrideB,
                        overrideH: b.overrideH
                    })).filter(b => b.overrideB || b.overrideH),
                    // Settings
                    soilBearing: state.soilBearing,
                    concreteDensity: state.concreteDensity,
                    defaultColumnB: state.defaultColumnB,
                    defaultColumnH: state.defaultColumnH,
                    defaultBeamB: state.defaultBeamB,
                    defaultBeamH: state.defaultBeamH
                };

                // Create and download file
                const json = JSON.stringify(projectData, null, 2);
                const blob = new Blob([json], { type: 'application/json' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `TributaryPro_${new Date().toISOString().split('T')[0]}.json`;
                a.style.display = 'none';
                document.body.appendChild(a);  // Required for Firefox
                a.click();
                document.body.removeChild(a);
                URL.revokeObjectURL(url);

                console.log('v3.0: Project saved!', projectData);
                alert('Project saved successfully!');
            } catch (err) {
                console.error('Save failed:', err);
                alert('Failed to save project: ' + err.message);
            }
        }

        /**
         * Load project from JSON file
         */
        function loadProject(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function (e) {
                try {
                    const projectData = JSON.parse(e.target.result);

                    // Restore spans
                    state.xSpans = projectData.xSpans || state.xSpans;
                    state.ySpans = projectData.ySpans || state.ySpans;
                    state.cantilevers = projectData.cantilevers || state.cantilevers;

                    // Restore floors
                    if (projectData.floors) {
                        state.floors = projectData.floors;
                    }
                    state.currentFloorIndex = projectData.currentFloorIndex || 0;

                    // Restore settings
                    if (projectData.soilBearing) state.soilBearing = projectData.soilBearing;
                    if (projectData.concreteDensity) state.concreteDensity = projectData.concreteDensity;
                    if (projectData.defaultColumnB) state.defaultColumnB = projectData.defaultColumnB;
                    if (projectData.defaultColumnH) state.defaultColumnH = projectData.defaultColumnH;

                    // Regenerate grid
                    renderSpans();
                    renderCantileverInputs();
                    renderFloorTabs();
                    calculate();

                    // Apply column overrides after calculation
                    if (projectData.columnOverrides) {
                        for (let override of projectData.columnOverrides) {
                            const col = state.columns.find(c => c.id === override.id);
                            if (col) {
                                col.active = override.active;
                                col.activePerFloor = override.activePerFloor;
                                col.startFloor = override.startFloor;
                                if (override.overrideB) col.overrideB = override.overrideB;
                                if (override.overrideH) col.overrideH = override.overrideH;
                                if (override.overrideB) col.suggestedB = override.overrideB;
                                if (override.overrideH) col.suggestedH = override.overrideH;
                            }
                        }
                    }

                    // Apply slab openings
                    if (projectData.slabOpenings) {
                        for (let opening of projectData.slabOpenings) {
                            const slab = state.slabs.find(s => s.id === opening.id);
                            if (slab) {
                                slab.openingW = opening.openingW;
                                slab.openingH = opening.openingH;
                                slab.netArea = slab.area - (slab.openingW || 0) * (slab.openingH || 0);
                            }
                        }
                    }

                    // Apply beam overrides
                    if (projectData.beamOverrides) {
                        for (let override of projectData.beamOverrides) {
                            const beam = state.beams.find(b => b.id === override.id);
                            if (beam) {
                                if (override.overrideB) beam.overrideB = override.overrideB;
                                if (override.overrideH) beam.overrideH = override.overrideH;
                                if (override.overrideB) beam.suggestedB = override.overrideB;
                                if (override.overrideH) beam.suggestedH = override.overrideH;
                            }
                        }
                    }

                    // Recalculate and render
                    calculate();
                    render();
                    render3DFrame();
                    fitView();

                    console.log('v3.0: Project loaded!', projectData);
                    alert('Project loaded successfully!');

                } catch (err) {
                    console.error('Failed to load project:', err);
                    alert('Failed to load project: ' + err.message);
                }
            };
            reader.readAsText(file);

            // Reset file input
            event.target.value = '';
        }

        // ========== v3.0: RESET & REFRESH ==========

        /**
         * Reset project to default values
         */
        function resetProject() {
            if (!confirm('🔄 Reset all values to defaults?\n\nThis will clear your current project and cannot be undone.')) {
                return;
            }

            // Reset state to defaults
            state.xSpans = [4.0, 4.0];
            state.ySpans = [5.0, 5.0];
            state.cantilevers = { top: [0, 0], bottom: [0, 0], left: [0, 0], right: [0, 0] };
            state.floors = [
                { id: '2F', name: '2nd Floor', dlSuper: 2.0, liveLoad: 2.0, slabThickness: 150, height: 3.0, wallLoad: 6.0, isRoof: false },
                { id: 'RF', name: 'Roof', dlSuper: 1.5, liveLoad: 1.0, slabThickness: 120, height: 3.0, wallLoad: 0, isRoof: true }
            ];
            state.currentFloorIndex = 0;
            state.gfSuspended = false;
            state.columns = [];
            state.beams = [];
            state.slabs = [];
            state.nextCustomBeamId = 1;

            // Reset UI inputs
            document.getElementById('gfSuspended').checked = false;
            document.getElementById('elevationSection').style.display = 'none';
            document.getElementById('buildingType').value = 'residential';
            document.getElementById('fcInput').value = '21';
            document.getElementById('fyInput').value = '415';
            document.getElementById('columnWidthInput').value = '0';
            document.getElementById('columnDepthInput').value = '0';
            document.getElementById('beamWidthInput').value = '250';
            document.getElementById('beamDepthInput').value = '0';
            document.getElementById('footingDepth').value = '1.5';
            document.getElementById('soilBearing').value = '150';

            // Re-render UI
            renderSpans();
            renderCantileverInputs();
            renderFloorTabs();
            calculate();
            fitView();

            console.log('v3.0: Project reset to defaults');
            alert('✅ Project reset to defaults!');
        }

        /**
         * Refresh view - recalculate and redraw
         */
        function refreshView() {
            calculate();

            // Refresh 3D if active
            if (typeof render3DFrame === 'function') {
                try { render3DFrame(); } catch (e) { console.warn('3D refresh skipped'); }
            }

            // Force canvas redraw
            if (typeof draw === 'function') {
                draw();
            }

            console.log('v3.0: View refreshed');
        }

        // ========== INIT ==========

        window.onload = function () {
            initCanvas();
            initPan();  // v2.4: Pan tool
            renderSpans();
            renderCantileverInputs();  // v3.0: Render cantilever inputs
            renderFloorTabs();  // v2.3: Render floor tabs
            calculate();
            fitView();
        };

        /**
         * v3.0: Generate STAAD Content String
         * Refactored to separate generation from download/copy logic.
         */
        function generateSTAADContent() {
            // Header
            let std = "STAAD SPACE\n";
            std += "START JOB INFORMATION\n";
            std += "ENGINEER DATE " + new Date().toDateString() + "\n";
            std += "JOB NAME " + (state.floors.length + " Storey Building") + "\n";
            std += "JOB CLIENT Tributary Pro v3.0\n";
            std += "END JOB INFORMATION\n";
            std += "INPUT WIDTH 79\n";  // Standard input width
            std += "UNIT METER KN\n\n";

            // Save State to restore later
            const oldBeams = [...state.beams];
            const oldSlabs = [...state.slabs];
            const oldCants = state.cantilevers;

            // v3.0 FIX: Better node numbering to avoid collisions
            // Node ID = (floorLevel * 1000) + columnIndex + 1
            const getNodeId = (colIdx, floorIdx) => (floorIdx * 1000) + colIdx + 1;

            // Track which nodes exist (for validation)
            const existingNodes = new Set();

            // --- 1. JOINT COORDINATES ---
            std += "JOINT COORDINATES\n";

            // Level 0 (Ground) - only columns that start from ground
            state.columns.forEach((col, ci) => {
                if (col.active === false) return;
                if (!col.startFloor) {  // Starts from ground
                    const nid = getNodeId(ci, 0);
                    existingNodes.add(nid);
                    std += `${nid} ${col.x.toFixed(3)} 0.000 ${col.y.toFixed(3)};\n`;
                }
            });

            // Suspended Levels
            let currentY = 0;
            state.floors.forEach((floor, fi) => {
                currentY += (floor.height || 3.0);
                const floorIdx = fi + 1;
                state.columns.forEach((col, ci) => {
                    if (col.active === false) return;
                    // v3.0: Check if column exists at this floor
                    const isActiveHere = isColumnActiveOnFloor(col, floor.id);
                    const startsBelow = !col.startFloor || isFloorAtOrAbove(floor.id, col.startFloor);

                    if (isActiveHere && startsBelow) {
                        const nid = getNodeId(ci, floorIdx);
                        existingNodes.add(nid);
                        std += `${nid} ${col.x.toFixed(3)} ${currentY.toFixed(3)} ${col.y.toFixed(3)};\n`;
                    }
                });
            });
            std += "\n";

            // --- 2. MEMBER INCIDENCES ---
            std += "MEMBER INCIDENCES\n";
            let memId = 1;
            const columnMembers = [];  // Track column member IDs
            const beamMembers = [];    // Track beam member IDs

            // Columns (vertical members)
            state.floors.forEach((floor, fi) => {
                const topIdx = fi + 1;
                const botIdx = fi;  // Previous floor (0 = ground)

                state.columns.forEach((col, ci) => {
                    if (col.active === false) return;

                    const topNode = getNodeId(ci, topIdx);
                    const botNode = getNodeId(ci, botIdx);

                    // v3.0 FIX: Only create member if both nodes exist
                    if (existingNodes.has(topNode) && existingNodes.has(botNode)) {
                        std += `${memId} ${botNode} ${topNode};\n`;
                        columnMembers.push(memId);
                        memId++;
                    }
                });
            });

            // Beams (horizontal members)
            const wallLoads = [];
            const processedBeams = new Set();  // v3.0: Prevent duplicate beams

            state.floors.forEach((floor, fi) => {
                const floorIdx = fi + 1;
                state.cantilevers = getCantilevers(floor.id);
                generateSlabs(floor.id);
                generateBeams(1.0, floor.wallLoad || 0);

                state.beams.forEach(beam => {
                    if (beam.isCantilever || beam.deleted) return;
                    if (!beam.startCol || !beam.endCol) return;

                    // v3.0: Create unique key to prevent duplicates
                    const beamKey = `${floorIdx}-${beam.startCol}-${beam.endCol}`;
                    if (processedBeams.has(beamKey)) return;
                    processedBeams.add(beamKey);

                    const startColIdx = state.columns.findIndex(c => c.id === beam.startCol);
                    const endColIdx = state.columns.findIndex(c => c.id === beam.endCol);

                    if (startColIdx >= 0 && endColIdx >= 0) {
                        const startNode = getNodeId(startColIdx, floorIdx);
                        const endNode = getNodeId(endColIdx, floorIdx);

                        // v3.0 FIX: Only create member if both nodes exist
                        if (existingNodes.has(startNode) && existingNodes.has(endNode)) {
                            std += `${memId} ${startNode} ${endNode};\n`;
                            beamMembers.push(memId);
                            if ((floor.wallLoad || 0) > 0) {
                                wallLoads.push({ id: memId, load: -(floor.wallLoad || 0) });
                            }
                            memId++;
                        }
                    }
                });
            });
            std += "\n";

            // --- 3. PROPERTIES ---
            std += "MEMBER PROPERTY AMERICAN\n";
            if (columnMembers.length > 0) {
                const colB = (state.columns[0]?.suggestedB || 300) / 1000;
                const colH = (state.columns[0]?.suggestedH || 300) / 1000;
                std += `${columnMembers.join(' ')} PRIS YD ${colH.toFixed(3)} ZD ${colB.toFixed(3)}\n`;
            }
            if (beamMembers.length > 0) {
                const beamB = (state.beams[0]?.suggestedB || 250) / 1000;
                const beamH = (state.beams[0]?.suggestedH || 400) / 1000;
                std += `${beamMembers.join(' ')} PRIS YD ${beamH.toFixed(3)} ZD ${beamB.toFixed(3)}\n`;
            }
            std += "\n";

            // --- 4. CONSTANTS (Concrete) ---
            std += "CONSTANTS\n";
            const E = (state.fc || 28) * 4700 * 1000;  // Ec = 4700*sqrt(fc) in kPa, simplified
            std += `E ${E.toFixed(0)} ALL\n`;
            std += "POISSON 0.2 ALL\n";
            std += "DENSITY 24 ALL\n";
            std += "ALPHA 1E-5 ALL\n\n";

            // --- 5. SUPPORTS ---
            std += "SUPPORTS\n";
            let supportNodes = [];
            state.columns.forEach((col, ci) => {
                if (col.active === false) return;
                if (!col.startFloor) {
                    const nid = getNodeId(ci, 0);
                    if (existingNodes.has(nid)) supportNodes.push(nid);
                }
            });
            if (supportNodes.length > 0) {
                std += supportNodes.join(' ') + " FIXED\n\n";
            }

            // --- 6. LOADS ---
            std += "LOAD 1 LOADTYPE Dead TITLE DEAD LOAD\n";
            std += "SELFWEIGHT Y -1.0\n";

            if (wallLoads.length > 0) {
                std += "MEMBER LOAD\n";
                wallLoads.forEach(wl => std += `${wl.id} UNI GY ${wl.load.toFixed(2)}\n`);
            }

            std += "FLOOR LOAD\n";
            let elevation = 0;
            state.floors.forEach(floor => {
                elevation += (floor.height || 3.0);
                const slabThick = (floor.slabThickness || state.slabThickness || 150) / 1000;
                const dlSuper = floor.dlSuper || state.DL || 1.5;
                const dl = -(dlSuper + (24 * slabThick));
                std += `YRANGE ${(elevation - 0.1).toFixed(3)} ${(elevation + 0.1).toFixed(3)} FLOAD ${dl.toFixed(3)} GY\n`;
            });

            std += "\nLOAD 2 LOADTYPE Live TITLE LIVE LOAD\n";
            std += "FLOOR LOAD\n";
            elevation = 0;
            state.floors.forEach(floor => {
                elevation += (floor.height || 3.0);
                const ll = floor.liveLoad || state.LL || 2.0;
                std += `YRANGE ${(elevation - 0.1).toFixed(3)} ${(elevation + 0.1).toFixed(3)} FLOAD ${(-ll).toFixed(3)} GY\n`;
            });

            std += "\nLOAD COMB 3 TITLE 1.2DL + 1.6LL\n";
            std += "1 1.2 2 1.6\n";

            std += "\nPERFORM ANALYSIS\n";
            std += "FINISH\n";

            // Restore State
            state.beams = oldBeams;
            state.slabs = oldSlabs;
            state.cantilevers = oldCants;
            // Re-render
            draw();

            console.log(`STAAD Export: ${existingNodes.size} nodes, ${memId - 1} members`);
            return std;
        }

        function exportToSTAAD() {
            try {
                const std = generateSTAADContent();
                const blob = new Blob([std], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `TributaryPro_Model_${new Date().toISOString().split('T')[0]}.std`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                alert('STAAD Model exported!\nCheck Downloads folder.');
            } catch (err) {
                alert('Export failed: ' + err.message);
            }
        }

        function copySTAADToClipboard() {
            try {
                const std = generateSTAADContent();
                navigator.clipboard.writeText(std).then(() => {
                    alert('📋 Code copied to clipboard!\n\n1. Open Notepad\n2. Paste (Ctrl+V)\n3. Save as "Model.std"');
                }).catch(err => {
                    const textArea = document.createElement("textarea");
                    textArea.value = std;
                    document.body.appendChild(textArea);
                    textArea.focus();
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        alert('📋 Code copied to clipboard (Legacy Mode)!');
                    } catch (err) {
                        alert('Unable to copy. Please try Export button.');
                    }
                    document.body.removeChild(textArea);
                });
            } catch (err) {
                alert('Copy failed: ' + err.message);
            }
        }

        // ========== v3.0: DXF EXPORT (AutoCAD) ==========

        /**
         * Generate DXF file content for AutoCAD
         */
        function generateDXFContent() {
            let dxf = '';

            // ========== HEADER SECTION ==========
            dxf += '0\nSECTION\n2\nHEADER\n';
            dxf += '9\n$ACADVER\n1\nAC1015\n';  // AutoCAD 2000 format
            dxf += '9\n$INSUNITS\n70\n6\n';      // Units: meters
            dxf += '0\nENDSEC\n';

            // ========== TABLES SECTION (Layers) ==========
            dxf += '0\nSECTION\n2\nTABLES\n';
            dxf += '0\nTABLE\n2\nLAYER\n70\n6\n';

            // Layer: GRID (Gray)
            dxf += '0\nLAYER\n2\nGRID\n70\n0\n62\n8\n6\nCONTINUOUS\n';
            // Layer: COLUMNS (Cyan)
            dxf += '0\nLAYER\n2\nCOLUMNS\n70\n0\n62\n4\n6\nCONTINUOUS\n';
            // Layer: BEAMS (Green)
            dxf += '0\nLAYER\n2\nBEAMS\n70\n0\n62\n3\n6\nCONTINUOUS\n';
            // Layer: SLABS (Blue)
            dxf += '0\nLAYER\n2\nSLABS\n70\n0\n62\n5\n6\nCONTINUOUS\n';
            // Layer: TEXT (White)
            dxf += '0\nLAYER\n2\nTEXT\n70\n0\n62\n7\n6\nCONTINUOUS\n';
            // Layer: CUSTOM_BEAMS (Magenta)
            dxf += '0\nLAYER\n2\nCUSTOM_BEAMS\n70\n0\n62\n6\n6\nCONTINUOUS\n';

            dxf += '0\nENDTAB\n0\nENDSEC\n';

            // ========== ENTITIES SECTION ==========
            dxf += '0\nSECTION\n2\nENTITIES\n';

            const currentFloor = state.floors[state.currentFloorIndex];
            const dxfLine = (x1, y1, x2, y2, layer) =>
                `0\nLINE\n8\n${layer}\n10\n${x1.toFixed(4)}\n20\n${y1.toFixed(4)}\n30\n0\n11\n${x2.toFixed(4)}\n21\n${y2.toFixed(4)}\n31\n0\n`;
            const dxfText = (x, y, text, layer, height = 0.2) =>
                `0\nTEXT\n8\n${layer}\n10\n${x.toFixed(4)}\n20\n${y.toFixed(4)}\n30\n0\n40\n${height}\n1\n${text}\n`;
            const dxfRect = (x1, y1, x2, y2, layer) =>
                dxfLine(x1, y1, x2, y1, layer) + dxfLine(x2, y1, x2, y2, layer) +
                dxfLine(x2, y2, x1, y2, layer) + dxfLine(x1, y2, x1, y1, layer);

            // ----- GRID LINES -----
            // v3.0 FIX: Calculate coordinates from spans (xCoords/yCoords don't exist in state)
            const xCoords = [0];
            state.xSpans.forEach(span => xCoords.push(xCoords[xCoords.length - 1] + span));
            const yCoords = [0];
            state.ySpans.forEach(span => yCoords.push(yCoords[yCoords.length - 1] + span));

            xCoords.forEach((x, i) => {
                const minY = Math.min(...yCoords);
                const maxY = Math.max(...yCoords);
                dxf += dxfLine(x, minY - 1, x, maxY + 1, 'GRID');
                dxf += dxfText(x, minY - 1.5, String(i + 1), 'TEXT', 0.3);
            });
            yCoords.forEach((y, i) => {
                const minX = Math.min(...xCoords);
                const maxX = Math.max(...xCoords);
                dxf += dxfLine(minX - 1, y, maxX + 1, y, 'GRID');
                dxf += dxfText(minX - 1.5, y, String.fromCharCode(65 + i), 'TEXT', 0.3);
            });

            // ----- COLUMNS -----
            state.columns.forEach(col => {
                if (col.active === false) return;
                const b = (col.suggestedB || 300) / 1000 / 2;
                const h = (col.suggestedH || 300) / 1000 / 2;
                dxf += dxfRect(col.x - b, col.y - h, col.x + b, col.y + h, 'COLUMNS');
                dxf += dxfText(col.x, col.y, col.id, 'TEXT', 0.15);
            });

            // ----- STRUCTURAL BEAMS -----
            state.beams.forEach(beam => {
                if (beam.deleted || beam.isCantilever || beam.isCustom) return;
                const bw = (beam.suggestedB || 250) / 1000 / 2;
                const startCol = state.columns.find(c => c.id === beam.startCol);
                const endCol = state.columns.find(c => c.id === beam.endCol);
                if (!startCol || !endCol) return;

                if (beam.direction === 'X') {
                    dxf += dxfLine(startCol.x, startCol.y - bw, endCol.x, endCol.y - bw, 'BEAMS');
                    dxf += dxfLine(startCol.x, startCol.y + bw, endCol.x, endCol.y + bw, 'BEAMS');
                } else {
                    dxf += dxfLine(startCol.x - bw, startCol.y, endCol.x - bw, endCol.y, 'BEAMS');
                    dxf += dxfLine(startCol.x + bw, startCol.y, endCol.x + bw, endCol.y, 'BEAMS');
                }
                const midX = (startCol.x + endCol.x) / 2;
                const midY = (startCol.y + endCol.y) / 2;
                dxf += dxfText(midX, midY + 0.3, beam.id, 'TEXT', 0.12);
            });

            // ----- CUSTOM BEAMS -----
            if (currentFloor && currentFloor.customBeams) {
                currentFloor.customBeams.forEach(cb => {
                    const bw = 0.125;
                    if (cb.dir === 'X') {
                        dxf += dxfLine(cb.start, cb.pos - bw, cb.end, cb.pos - bw, 'CUSTOM_BEAMS');
                        dxf += dxfLine(cb.start, cb.pos + bw, cb.end, cb.pos + bw, 'CUSTOM_BEAMS');
                    } else {
                        dxf += dxfLine(cb.pos - bw, cb.start, cb.pos - bw, cb.end, 'CUSTOM_BEAMS');
                        dxf += dxfLine(cb.pos + bw, cb.start, cb.pos + bw, cb.end, 'CUSTOM_BEAMS');
                    }
                    const midX = cb.dir === 'X' ? (cb.start + cb.end) / 2 : cb.pos;
                    const midY = cb.dir === 'Y' ? (cb.start + cb.end) / 2 : cb.pos;
                    dxf += dxfText(midX, midY + 0.3, cb.id, 'TEXT', 0.1);
                });
            }

            // ----- SLABS -----
            state.slabs.forEach(slab => {
                if (slab.isVoid || slab.isCantilever) return;
                dxf += dxfRect(slab.x1, slab.y1, slab.x2, slab.y2, 'SLABS');
                const cx = (slab.x1 + slab.x2) / 2;
                const cy = (slab.y1 + slab.y2) / 2;
                dxf += dxfText(cx, cy, slab.id || '', 'TEXT', 0.1);
            });

            dxf += '0\nENDSEC\n0\nEOF\n';
            return dxf;
        }

        function exportToDXF() {
            try {
                const dxf = generateDXFContent();
                const blob = new Blob([dxf], { type: 'application/dxf' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `TributaryPro_Plan_${new Date().toISOString().split('T')[0]}.dxf`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                alert('✅ DXF exported!\\n\\nOpen in AutoCAD, BricsCAD, or any DXF viewer.\\n\\nLayers:\\n• GRID (gray)\\n• COLUMNS (cyan)\\n• BEAMS (green)\\n• CUSTOM_BEAMS (magenta)\\n• SLABS (blue)\\n• TEXT (white)');
            } catch (err) {
                console.error('DXF export failed:', err);
                alert('❌ Export failed: ' + err.message);
            }
        }

        // ========== v3.0: ETABS EXPORT ==========

        /**
         * Generate ETABS .e2k file content
         */
        function generateETABSContent() {
            let e2k = '';

            // Header
            e2k += '$ ETABS MODEL FILE\n';
            e2k += '$ Generated by Tributary Pro v3.0\n';
            e2k += `$ Date: ${new Date().toISOString().split('T')[0]}\n\n`;

            // Units
            e2k += '$ UNITS\n';
            e2k += '  UNITS  "KN"  "M"  "C"\n\n';

            // Stories
            e2k += '$ STORIES - IN SEQUENCE FROM TOP TO BOTTOM\n';
            let elevations = [0];
            let currentElev = 0;
            state.floors.forEach(floor => {
                currentElev += (floor.height || 3.0);
                elevations.push(currentElev);
            });

            for (let i = state.floors.length - 1; i >= 0; i--) {
                const floor = state.floors[i];
                const height = floor.height || 3.0;
                e2k += `  STORY  "${floor.id}"  ${height.toFixed(4)}  ${elevations[i + 1].toFixed(4)}  Yes\n`;
            }
            e2k += '  STORY  "BASE"  0  0  No\n\n';

            // Materials
            e2k += '$ MATERIAL PROPERTIES\n';
            e2k += '  MATERIAL  "CONC"  "CONCRETE"  "Isotropic"\n';
            const E_concrete = 4700 * Math.sqrt(state.fc) * 1000;
            e2k += `  MATERIAL  "CONC"  ${E_concrete.toFixed(0)}  0  0.17  2.4  1.0E-05\n\n`;

            // Frame Sections
            const colB = (state.columns[0]?.suggestedB || 300) / 1000;
            const colH = (state.columns[0]?.suggestedH || 300) / 1000;
            const beamB = (state.beams[0]?.suggestedB || 250) / 1000;
            const beamH = (state.beams[0]?.suggestedH || 400) / 1000;

            e2k += '$ FRAME SECTION PROPERTIES\n';
            e2k += `  FRAMESECTION  "COL${Math.round(colB * 1000)}x${Math.round(colH * 1000)}"  MATERIAL "CONC"  SHAPE "Rectangular"\n`;
            e2k += `  FRAMESECTION  "COL${Math.round(colB * 1000)}x${Math.round(colH * 1000)}"  D ${colH.toFixed(4)}  B ${colB.toFixed(4)}\n`;
            e2k += `  FRAMESECTION  "BEAM${Math.round(beamB * 1000)}x${Math.round(beamH * 1000)}"  MATERIAL "CONC"  SHAPE "Rectangular"\n`;
            e2k += `  FRAMESECTION  "BEAM${Math.round(beamB * 1000)}x${Math.round(beamH * 1000)}"  D ${beamH.toFixed(4)}  B ${beamB.toFixed(4)}\n\n`;

            // Grid Lines
            const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            e2k += '$ GRID LINES\n';
            let xPos = 0;
            for (let xi = 0; xi <= state.xSpans.length; xi++) {
                e2k += `  GRID  "${letters[xi]}"  "X"  ${xPos.toFixed(4)}  "Yes"  "End"\n`;
                if (xi < state.xSpans.length) xPos += state.xSpans[xi];
            }
            let yPos = 0;
            for (let yi = 0; yi <= state.ySpans.length; yi++) {
                e2k += `  GRID  "${yi + 1}"  "Y"  ${yPos.toFixed(4)}  "Yes"  "End"\n`;
                if (yi < state.ySpans.length) yPos += state.ySpans[yi];
            }
            e2k += '\n';

            // Point Coordinates (simplified)
            e2k += '$ POINT COORDINATES\n';
            let pointId = 1;
            const pointMap = {};

            state.columns.forEach((col, ci) => {
                if (col.active === false) return;
                if (!col.startFloor) {
                    pointMap[`${col.id}_BASE`] = pointId;
                    e2k += `  POINT  "${pointId}"  ${col.x.toFixed(4)}  ${col.y.toFixed(4)}  0  "BASE"\n`;
                    pointId++;
                }
                state.floors.forEach((floor) => {
                    if (isColumnActiveOnFloor(col, floor.id)) {
                        pointMap[`${col.id}_${floor.id}`] = pointId;
                        e2k += `  POINT  "${pointId}"  ${col.x.toFixed(4)}  ${col.y.toFixed(4)}  0  "${floor.id}"\n`;
                        pointId++;
                    }
                });
            });
            e2k += '\n';

            // Load Patterns
            e2k += '$ LOAD PATTERNS\n';
            e2k += '  LOADPATTERN  "DEAD"  "Dead"  0\n';
            e2k += '  LOADPATTERN  "LIVE"  "Live"  0\n\n';

            // Load Combinations
            e2k += '$ LOAD COMBINATIONS (NSCP 2015)\n';
            e2k += '  COMBO  "1.2DL+1.6LL"  "Linear Add"\n';
            e2k += '    COMBO  "1.2DL+1.6LL"  "DEAD"  1.2\n';
            e2k += '    COMBO  "1.2DL+1.6LL"  "LIVE"  1.6\n\n';

            e2k += '$ END OF MODEL DATA\n';
            e2k += '  END\n';

            return e2k;
        }

        function exportToETABS() {
            try {
                const e2k = generateETABSContent();
                const blob = new Blob([e2k], { type: 'application/octet-stream' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `TributaryPro_Model_${new Date().toISOString().split('T')[0]}.e2k`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                alert('✅ ETABS Model exported!\n\nCheck Downloads folder for .e2k file.\n\nOpen in ETABS: File → Import → ETABS .e2k Text File');
            } catch (err) {
                alert('Export failed: ' + err.message);
            }
        }

        function copyETABSToClipboard() {
            try {
                const e2k = generateETABSContent();
                navigator.clipboard.writeText(e2k).then(() => {
                    alert('📋 ETABS code copied to clipboard!\n\n1. Open Notepad\n2. Paste (Ctrl+V)\n3. Save as "Model.e2k"\n4. Import to ETABS');
                }).catch(err => {
                    const textArea = document.createElement("textarea");
                    textArea.value = e2k;
                    document.body.appendChild(textArea);
                    textArea.select();
                    try {
                        document.execCommand('copy');
                        alert('📋 Code copied to clipboard (Legacy Mode)!');
                    } catch (err) {
                        alert('Unable to copy. Please try Export button.');
                    }
                    document.body.removeChild(textArea);
                });
            } catch (err) {
                alert('Copy failed: ' + err.message);
            }
        }

        // ========== v3.0: IFC EXPORT (Universal BIM) ==========

        /**
         * Generate unique IFC GUID
         */
        function generateIFCGUID() {
            const chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_$';
            let guid = '';
            for (let i = 0; i < 22; i++) {
                guid += chars[Math.floor(Math.random() * 64)];
            }
            return guid;
        }

        /**
         * Generate IFC file content (IFC 2x3)
         */
        function generateIFCContent() {
            const timestamp = new Date().toISOString().replace(/[-:]/g, '').split('.')[0];
            let entityId = 1;
            const getId = () => `#${entityId++}`;

            // Header
            let ifc = `ISO-10303-21;
HEADER;
FILE_DESCRIPTION(('ViewDefinition [CoordinationView]'),'2;1');
FILE_NAME('TributaryPro_Model.ifc','${timestamp}',('Tributary Pro v3.0'),('Futol Ethical Technology Ecosystems'),'Tributary Pro IFC Generator','Tributary Pro v3.0','');
FILE_SCHEMA(('IFC2X3'));
ENDSEC;
DATA;
`;

            // Basic IFC entities
            const ownerHistoryId = getId();
            const personId = getId();
            const orgId = getId();
            const personOrgId = getId();
            const appId = getId();
            const appDevId = getId();
            const unitAssignmentId = getId();
            const lengthUnitId = getId();
            const areaUnitId = getId();
            const contextId = getId();
            const originId = getId();
            const worldCoordId = getId();
            const projectId = getId();
            const siteId = getId();
            const buildingId = getId();

            ifc += `${personId}=IFCPERSON($,'Engineer','Structural',$,$,$,$,$);
${orgId}=IFCORGANIZATION($,'FETE','Futol Ethical Technology Ecosystems',$,$);
${personOrgId}=IFCPERSONANDORGANIZATION(${personId},${orgId},$);
${appDevId}=IFCORGANIZATION($,'FETE',$,$,$);
${appId}=IFCAPPLICATION(${appDevId},'3.0','Tributary Pro','TributaryPro');
${ownerHistoryId}=IFCOWNERHISTORY(${personOrgId},${appId},$,.NOCHANGE.,$,$,$,${Math.floor(Date.now() / 1000)});
${lengthUnitId}=IFCSIUNIT(*,.LENGTHUNIT.,$,.METRE.);
${areaUnitId}=IFCSIUNIT(*,.AREAUNIT.,$,.SQUARE_METRE.);
${unitAssignmentId}=IFCUNITASSIGNMENT((${lengthUnitId},${areaUnitId}));
${originId}=IFCCARTESIANPOINT((0.,0.,0.));
${worldCoordId}=IFCAXIS2PLACEMENT3D(${originId},$,$);
${contextId}=IFCGEOMETRICREPRESENTATIONCONTEXT($,'Model',3,1.0E-5,${worldCoordId},$);
${projectId}=IFCPROJECT('${generateIFCGUID()}',${ownerHistoryId},'Tributary Pro Model',$,$,$,$,(${contextId}),${unitAssignmentId});
${siteId}=IFCSITE('${generateIFCGUID()}',${ownerHistoryId},'Site',$,$,$,$,$,.ELEMENT.,$,$,$,$,$);
${buildingId}=IFCBUILDING('${generateIFCGUID()}',${ownerHistoryId},'Building',$,$,$,$,$,.ELEMENT.,$,$,$);
`;

            // Storeys
            const storeyIds = [];
            let currentZ = 0;
            const basePlacementId = getId();
            const baseStoreyId = getId();

            ifc += `${basePlacementId}=IFCLOCALPLACEMENT($,${worldCoordId});
${baseStoreyId}=IFCBUILDINGSTOREY('${generateIFCGUID()}',${ownerHistoryId},'Ground','Ground Level',$,${basePlacementId},$,$,.ELEMENT.,0.);
`;
            storeyIds.push(baseStoreyId);

            state.floors.forEach((floor, fi) => {
                currentZ += (floor.height || 3.0);
                const storey = getId();
                const placementPt = getId();
                const placement = getId();
                const localPlacement = getId();

                ifc += `${placementPt}=IFCCARTESIANPOINT((0.,0.,${currentZ.toFixed(3)}));
${placement}=IFCAXIS2PLACEMENT3D(${placementPt},$,$);
${localPlacement}=IFCLOCALPLACEMENT($,${placement});
${storey}=IFCBUILDINGSTOREY('${generateIFCGUID()}',${ownerHistoryId},'${floor.id}','${floor.name}',$,${localPlacement},$,$,.ELEMENT.,${currentZ.toFixed(3)});
`;
                storeyIds.push(storey);
            });

            // Relationships
            const relSiteId = getId();
            const relBuildingId = getId();
            const relStoreyId = getId();

            ifc += `${relSiteId}=IFCRELAGGREGATES('${generateIFCGUID()}',${ownerHistoryId},$,$,${projectId},(${siteId}));
${relBuildingId}=IFCRELAGGREGATES('${generateIFCGUID()}',${ownerHistoryId},$,$,${siteId},(${buildingId}));
${relStoreyId}=IFCRELAGGREGATES('${generateIFCGUID()}',${ownerHistoryId},$,$,${buildingId},(${storeyIds.join(',')}));
`;

            // Columns
            const columnIds = [];
            let totalHeight = 0;
            state.floors.forEach(f => totalHeight += (f.height || 3.0));

            state.columns.forEach((col, ci) => {
                if (col.active === false) return;
                const colB = (col.suggestedB || 300) / 1000;
                const colH = (col.suggestedH || 300) / 1000;

                const colPt = getId();
                const colAxis = getId();
                const colPlacement = getId();
                const profilePt = getId();
                const profile = getId();
                const extrudeDir = getId();
                const extrude = getId();
                const bodyRep = getId();
                const shape = getId();
                const column = getId();

                ifc += `${colPt}=IFCCARTESIANPOINT((${col.x.toFixed(3)},${col.y.toFixed(3)},0.));
${colAxis}=IFCAXIS2PLACEMENT3D(${colPt},$,$);
${colPlacement}=IFCLOCALPLACEMENT(${basePlacementId},${colAxis});
${profilePt}=IFCCARTESIANPOINT((0.,0.));
${profile}=IFCRECTANGLEPROFILEDEF(.AREA.,$,${profilePt},${colB.toFixed(3)},${colH.toFixed(3)});
${extrudeDir}=IFCDIRECTION((0.,0.,1.));
${extrude}=IFCEXTRUDEDAREASOLID(${profile},$,${extrudeDir},${totalHeight.toFixed(3)});
${bodyRep}=IFCSHAPEREPRESENTATION(${contextId},'Body','SweptSolid',(${extrude}));
${shape}=IFCPRODUCTDEFINITIONSHAPE($,$,(${bodyRep}));
${column}=IFCCOLUMN('${generateIFCGUID()}',${ownerHistoryId},'${col.id}','Column ${col.id}',$,${colPlacement},${shape},$);
`;
                columnIds.push(column);
            });

            // Contain columns in ground storey
            if (columnIds.length > 0) {
                const relContains = getId();
                ifc += `${relContains}=IFCRELCONTAINEDINSPATIALSTRUCTURE('${generateIFCGUID()}',${ownerHistoryId},$,$,(${columnIds.join(',')}),${baseStoreyId});
`;
            }

            ifc += `ENDSEC;
END-ISO-10303-21;
`;
            return ifc;
        }

        function exportToIFC() {
            try {
                const ifc = generateIFCContent();
                const blob = new Blob([ifc], { type: 'application/x-step' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.style.display = 'none';
                a.href = url;
                a.download = `TributaryPro_Model_${new Date().toISOString().split('T')[0]}.ifc`;
                document.body.appendChild(a);
                a.click();
                setTimeout(() => { document.body.removeChild(a); URL.revokeObjectURL(url); }, 100);
                alert('✅ IFC Model exported!\n\nCheck Downloads folder for .ifc file.\n\nOpen in:\n• Revit: Insert → Link IFC\n• ArchiCAD: File → Open\n• Tekla: File → Import → IFC');
            } catch (err) {
                alert('Export failed: ' + err.message);
            }
        }

        // This allows parameters (like Cantilevers) to reflect the selected floor's values


        document.addEventListener('click', function (e) {
            if (e.target.classList.contains('floor-tab') || e.target.closest('.floor-tab')) {
                // Wait for internal state.currentFloorIndex to update
                setTimeout(() => {
                    const currentFloor = state.floors[state.currentFloorIndex];
                    if (!currentFloor) return;

                    // Sync Cantilever Inputs
                    const cants = getCantilevers(currentFloor.id);
                    // Update UI state to match this floor's effective cantilevers
                    state.cantilevers = {
                        top: [...cants.top],
                        bottom: [...cants.bottom],
                        left: [...cants.left],
                        right: [...cants.right]
                    };

                    // Re-render inputs (safe to do on tab switch)
                    if (typeof renderCantileverInputs === 'function') {
                        renderCantileverInputs();
                    }
                    console.log(`v3.0: UI synced to floor ${currentFloor.id}`);
                }, 50); // Small delay to let app switch floor first
            }
        });

        // ========================================
        // v3.0: CUSTOM BEAM FUNCTIONS (Stair Openings)
        // ========================================

        /**
         * Show the custom beam modal dialog and populate dropdowns
         */
        function showCustomBeamDialog() {
            const modal = document.getElementById('customBeamModal');
            const dirSelect = document.getElementById('cbDir');
            const refSelect = document.getElementById('cbRefGridline');
            const fromSelect = document.getElementById('cbFromSpan');
            const toSelect = document.getElementById('cbToSpan');

            // Clear and populate reference gridline based on direction
            function updateReferenceGridlines() {
                refSelect.innerHTML = '';
                const letters = 'ABCDEFGHJKLMNPQRSTUVWXYZ';

                if (dirSelect.value === 'X') {
                    // Horizontal beam placed at Y offset from gridline 1, 2, 3, ...
                    for (let i = 0; i <= state.ySpans.length; i++) {
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = `Gridline ${i + 1} (Y = ${getYCoords()[i].toFixed(1)}m)`;
                        refSelect.appendChild(opt);
                    }
                } else {
                    // Vertical beam placed at X offset from gridline A, B, C, ...
                    for (let i = 0; i <= state.xSpans.length; i++) {
                        const opt = document.createElement('option');
                        opt.value = i;
                        opt.textContent = `Gridline ${letters[i]} (X = ${getXCoords()[i].toFixed(1)}m)`;
                        refSelect.appendChild(opt);
                    }
                }
            }

            // Populate span range dropdowns
            function updateSpanDropdowns() {
                fromSelect.innerHTML = '';
                toSelect.innerHTML = '';

                const spans = dirSelect.value === 'X' ? state.xSpans : state.ySpans;
                for (let i = 0; i < spans.length; i++) {
                    const optFrom = document.createElement('option');
                    optFrom.value = i;
                    optFrom.textContent = `Span ${i + 1} (${spans[i].toFixed(1)}m)`;
                    fromSelect.appendChild(optFrom);

                    const optTo = document.createElement('option');
                    optTo.value = i;
                    optTo.textContent = `Span ${i + 1}`;
                    toSelect.appendChild(optTo);
                }
                toSelect.value = spans.length - 1;
            }

            // Helper to get X coordinates
            function getXCoords() {
                const coords = [0];
                for (let span of state.xSpans) coords.push(coords[coords.length - 1] + span);
                return coords;
            }

            // Helper to get Y coordinates
            function getYCoords() {
                const coords = [0];
                for (let span of state.ySpans) coords.push(coords[coords.length - 1] + span);
                return coords;
            }

            // Update on direction change
            dirSelect.onchange = () => {
                updateReferenceGridlines();
                updateSpanDropdowns();
            };

            // Initialize
            updateReferenceGridlines();
            updateSpanDropdowns();

            // Show modal
            modal.style.display = 'flex';
        }

        /**
         * Hide the custom beam modal
         */
        function hideCustomBeamDialog() {
            document.getElementById('customBeamModal').style.display = 'none';
        }

        /**
         * Add a custom beam based on the dialog inputs
         */
        function addCustomBeam() {
            const dir = document.getElementById('cbDir').value;
            const refIdx = parseInt(document.getElementById('cbRefGridline').value);
            const offset = parseFloat(document.getElementById('cbOffset').value);
            const fromSpan = parseInt(document.getElementById('cbFromSpan').value);
            const toSpan = parseInt(document.getElementById('cbToSpan').value);

            if (!offset || offset <= 0) {
                alert('Please enter a valid offset distance.');
                return;
            }

            // Calculate absolute position and range
            const xCoords = [0];
            for (let span of state.xSpans) xCoords.push(xCoords[xCoords.length - 1] + span);
            const yCoords = [0];
            for (let span of state.ySpans) yCoords.push(yCoords[yCoords.length - 1] + span);

            let pos, start, end, x1, y1, x2, y2;

            if (dir === 'X') {
                // Horizontal beam: position is Y, beam runs along X
                pos = yCoords[refIdx] + offset;
                start = xCoords[fromSpan];
                end = xCoords[toSpan + 1];
                x1 = start; y1 = pos; x2 = end; y2 = pos;
            } else {
                // Vertical beam: position is X, beam runs along Y
                pos = xCoords[refIdx] + offset;
                start = yCoords[fromSpan];
                end = yCoords[toSpan + 1];
                x1 = pos; y1 = start; x2 = pos; y2 = end;
            }

            // Create custom beam object
            const customBeam = {
                id: `CB-${state.nextCustomBeamId++}`,
                dir: dir,
                refGridlineIdx: refIdx,
                offset: offset,
                fromSpan: fromSpan,
                toSpan: toSpan,
                pos: pos,
                start: start,
                end: end,
                x1: x1,
                y1: y1,
                x2: x2,
                y2: y2,
                span: Math.sqrt(Math.pow(x2 - x1, 2) + Math.pow(y2 - y1, 2)),
                isCustom: true
            };

            // Store in current floor's customBeams array
            const currentFloor = state.floors[state.currentFloorIndex];
            if (!currentFloor.customBeams) currentFloor.customBeams = [];
            currentFloor.customBeams.push(customBeam);

            // v3.0 FIX: Push to undo stack so it can be undone
            state.undoStack.push({
                type: 'beamAdd',
                floorId: currentFloor.id,
                data: customBeam
            });
            updateUndoButton();

            console.log(`v3.0: Added custom beam ${customBeam.id} at ${dir}=${pos.toFixed(2)}m, spanning ${start.toFixed(1)}m to ${end.toFixed(1)}m`);

            hideCustomBeamDialog();
            calculate();
        }

        /**
         * Get custom beams for current floor
         */
        function getCustomBeams(floorId) {
            const floor = state.floors.find(f => f.id === floorId);
            return floor && floor.customBeams ? floor.customBeams : [];
        }

        /**
         * Alias for getCustomBeams - returns custom beams for current floor
         * (Used by draw() for 2D rendering)
         */
        function getFloorCustomBeams() {
            const currentFloor = state.floors[state.currentFloorIndex];
            return currentFloor && currentFloor.customBeams ? currentFloor.customBeams : [];
        }



        // v3.0: Toggle slab void status (persists in floor.voidSlabs)
        function toggleSlabVoid(slabId) {
            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;
            if (!floor.voidSlabs) floor.voidSlabs = [];

            const index = floor.voidSlabs.indexOf(slabId);
            if (index === -1) {
                floor.voidSlabs.push(slabId);
                console.log(`v3.0: Slab ${slabId} marked as VOID on floor ${floor.id}`);
            } else {
                floor.voidSlabs.splice(index, 1);
                console.log(`v3.0: Slab ${slabId} restored (not void) on floor ${floor.id}`);
            }

            calculate();
            draw();
            render3DFrame(); // Update 3D also
        }

        // ========================================
        // v3.0: PLANTED COLUMNS & CONTEXT MENU
        // ========================================

        let selectedColumnId = null;  // Currently selected column for context menu

        /**
         * Show column context menu at click position
         */
        function showColumnMenu(colId, screenX, screenY) {
            selectedColumnId = colId;
            const menu = document.getElementById('columnContextMenu');
            const title = document.getElementById('columnMenuTitle');
            const optionsDiv = document.getElementById('plantedFloorOptions');

            // Set title
            title.textContent = `Column ${colId}`;

            // Populate planted floor options (all floors except GF which is ground)
            optionsDiv.innerHTML = '';
            state.floors.forEach((floor, idx) => {
                if (floor.id === 'GF') return; // Can't be planted at ground floor
                const btn = document.createElement('button');
                btn.className = 'ctx-menu-btn';
                btn.innerHTML = `🏗️ Planted @ ${floor.id}`;
                btn.onclick = () => setPlantedFloor(floor.id);
                optionsDiv.appendChild(btn);
            });

            // Position and show menu
            menu.style.left = screenX + 'px';
            menu.style.top = screenY + 'px';
            menu.style.display = 'block';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideColumnMenu, { once: true });
            }, 10);
        }

        /**
         * Hide column context menu
         */
        function hideColumnMenu() {
            document.getElementById('columnContextMenu').style.display = 'none';
        }

        // ========================================
        // v3.2: MEMBER CONTEXT MENU (beams/slabs)
        // ========================================

        let selectedMemberType = null;  // 'beam' or 'slab'
        let selectedMemberId = null;

        /**
         * Show member context menu at click position
         */
        function showMemberMenu(type, memberId, screenX, screenY) {
            selectedMemberType = type;
            selectedMemberId = memberId;

            const menu = document.getElementById('memberContextMenu');
            const title = document.getElementById('memberMenuTitle');
            const lockBtn = document.getElementById('memberLockBtn');

            // Set title based on type
            if (type === 'beam') {
                title.textContent = `Beam ${memberId}`;
            } else if (type === 'slab') {
                title.textContent = `Slab ${memberId}`;
            }

            // v3.2: Update lock button text based on current lock state
            const floor = state.floors[state.currentFloorIndex];
            let isLocked = false;
            if (type === 'beam' && floor?.lockedBeams?.includes(memberId)) {
                isLocked = true;
            } else if (type === 'slab' && floor?.lockedSlabs?.includes(memberId)) {
                isLocked = true;
            }
            lockBtn.innerHTML = isLocked ? '🔓 Unlock' : '🔒 Lock';

            // Position and show menu
            menu.style.left = screenX + 'px';
            menu.style.top = screenY + 'px';
            menu.style.display = 'block';

            // Close on click outside
            setTimeout(() => {
                document.addEventListener('click', hideMemberMenu, { once: true });
            }, 10);
        }

        /**
         * Hide member context menu
         */
        function hideMemberMenu() {
            document.getElementById('memberContextMenu').style.display = 'none';
        }

        /**
         * Delete member from context menu
         */
        function deleteMemberFromMenu() {
            hideMemberMenu();

            if (!selectedMemberType || !selectedMemberId) return;

            const floor = state.floors[state.currentFloorIndex];

            // v3.2: Check if member is locked - prevent deletion
            if (selectedMemberType === 'beam' && floor?.lockedBeams?.includes(selectedMemberId)) {
                console.log(`v3.2: Cannot delete LOCKED beam ${selectedMemberId} - unlock first`);
                return;
            }
            if (selectedMemberType === 'slab' && floor?.lockedSlabs?.includes(selectedMemberId)) {
                console.log(`v3.2: Cannot delete LOCKED slab ${selectedMemberId} - unlock first`);
                return;
            }

            if (selectedMemberType === 'beam') {
                console.log(`v3.2: Deleting beam ${selectedMemberId} via context menu`);
                toggleBeamDeleted(selectedMemberId);
            } else if (selectedMemberType === 'slab') {
                console.log(`v3.2: Deleting slab ${selectedMemberId} via context menu`);
                // Only delete if not already void
                if (!floor?.voidSlabs?.includes(selectedMemberId)) {
                    toggleSlabVoid(selectedMemberId);
                }
            }
        }

        /**
         * Restore member from context menu
         */
        function restoreMemberFromMenu() {
            hideMemberMenu();

            if (!selectedMemberType || !selectedMemberId) return;

            if (selectedMemberType === 'beam') {
                console.log(`v3.2: Restoring beam ${selectedMemberId} via context menu`);
                // If beam is deleted, restore it
                const floor = state.floors[state.currentFloorIndex];
                if (floor?.deletedBeams?.includes(selectedMemberId)) {
                    toggleBeamDeleted(selectedMemberId);
                }
            } else if (selectedMemberType === 'slab') {
                console.log(`v3.2: Restoring slab ${selectedMemberId} via context menu`);
                // If slab is void, restore it
                const floor = state.floors[state.currentFloorIndex];
                if (floor?.voidSlabs?.includes(selectedMemberId)) {
                    toggleSlabVoid(selectedMemberId);
                }
            }
        }

        /**
         * v3.2: Toggle lock state for selected member (beam/slab)
         */
        function toggleMemberLocked() {
            hideMemberMenu();

            if (!selectedMemberType || !selectedMemberId) return;

            const floor = state.floors[state.currentFloorIndex];
            if (!floor) return;

            if (selectedMemberType === 'beam') {
                if (!floor.lockedBeams) floor.lockedBeams = [];
                const idx = floor.lockedBeams.indexOf(selectedMemberId);
                if (idx >= 0) {
                    floor.lockedBeams.splice(idx, 1);
                    console.log(`v3.2: Beam ${selectedMemberId} UNLOCKED on floor ${floor.id}`);
                } else {
                    floor.lockedBeams.push(selectedMemberId);
                    console.log(`v3.2: Beam ${selectedMemberId} LOCKED on floor ${floor.id}`);
                }
            } else if (selectedMemberType === 'slab') {
                if (!floor.lockedSlabs) floor.lockedSlabs = [];
                const idx = floor.lockedSlabs.indexOf(selectedMemberId);
                if (idx >= 0) {
                    floor.lockedSlabs.splice(idx, 1);
                    console.log(`v3.2: Slab ${selectedMemberId} UNLOCKED on floor ${floor.id}`);
                } else {
                    floor.lockedSlabs.push(selectedMemberId);
                    console.log(`v3.2: Slab ${selectedMemberId} LOCKED on floor ${floor.id}`);
                }
            }

            draw(); // Redraw to show lock visual
        }

        /**
         * Toggle selected column active state
         */
        function toggleSelectedColumn() {
            if (!selectedColumnId) return;
            hideColumnMenu();

            const col = state.columns.find(c => c.id === selectedColumnId);
            if (col) {
                const floorId = state.floors[state.currentFloorIndex]?.id;
                if (!col.floorActive) col.floorActive = {};

                const wasActive = col.floorActive[floorId] !== false;
                col.floorActive[floorId] = !wasActive;

                console.log(`v3.0: Column ${col.id} ${!wasActive ? 'activated' : 'deactivated'} on floor ${floorId}`);
                calculate();
            }
        }

        /**
         * Set planted floor for selected column
         */
        function setPlantedFloor(floorId) {
            if (!selectedColumnId) return;
            hideColumnMenu();

            const col = state.columns.find(c => c.id === selectedColumnId);
            if (col) {
                col.startFloor = floorId;
                console.log(`v3.0: Column ${col.id} set as PLANTED starting at floor ${floorId}`);
                calculate();
            }
        }

        /**
         * Clear planted status (reset to ground)
         */
        function clearPlantedFloor() {
            if (!selectedColumnId) return;
            hideColumnMenu();

            const col = state.columns.find(c => c.id === selectedColumnId);
            if (col) {
                delete col.startFloor;
                console.log(`v3.0: Column ${col.id} planted status cleared (starts at ground)`);
                calculate();
            }
        }

        // ========================================
        // v3.0: PLANTED COLUMN DIALOG
        // ========================================

        // v3.0: Track current placement mode
        let pcPlacementMode = 'grid'; // 'grid' or 'custom'

        /**
         * Toggle placement mode between grid and custom X,Y
         */
        function setPCPlacementMode(mode) {
            pcPlacementMode = mode;

            const gridBtn = document.getElementById('pcModeGrid');
            const customBtn = document.getElementById('pcModeCustom');
            const gridSection = document.getElementById('pcGridSection');
            const customSection = document.getElementById('pcCustomSection');

            if (mode === 'grid') {
                gridBtn.style.background = 'linear-gradient(135deg,#8b5cf6,#6366f1)';
                gridBtn.style.color = 'white';
                customBtn.style.background = 'transparent';
                customBtn.style.color = '#8b949e';
                gridSection.style.display = 'block';
                customSection.style.display = 'none';
            } else {
                customBtn.style.background = 'linear-gradient(135deg,#8b5cf6,#6366f1)';
                customBtn.style.color = 'white';
                gridBtn.style.background = 'transparent';
                gridBtn.style.color = '#8b949e';
                gridSection.style.display = 'none';
                customSection.style.display = 'block';
            }
        }

        /**
         * Show planted column dialog and populate dropdowns
         * @param {number} presetX - Optional preset X coordinate (from click-to-place)
         * @param {number} presetY - Optional preset Y coordinate (from click-to-place)
         */
        function showPlantedColumnDialog(presetX = null, presetY = null) {
            const modal = document.getElementById('plantedColumnModal');
            const gridSelect = document.getElementById('pcGridLocation');
            const floorSelect = document.getElementById('pcStartFloor');

            // Populate grid locations from state.xSpans/ySpans using COLUMN_LETTERS
            gridSelect.innerHTML = '';
            const COLUMN_LETTERS = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
            const numXGridlines = (state.xSpans?.length || 0) + 1; // +1 for gridlines = spans + 1
            const numYGridlines = (state.ySpans?.length || 0) + 1;

            // Generate X labels (A, B, C...) and Y labels (1, 2, 3...)
            const xLabels = [];
            for (let i = 0; i < numXGridlines && i < COLUMN_LETTERS.length; i++) {
                xLabels.push(COLUMN_LETTERS[i]);
            }
            const yLabels = [];
            for (let i = 0; i < numYGridlines; i++) {
                yLabels.push(String(i + 1));
            }

            // Generate all grid intersections (column IDs)
            for (const y of yLabels) {
                for (const x of xLabels) {
                    const colId = `${x}${y}`;
                    // Check if column already exists
                    const exists = state.columns.some(c => c.id === colId);
                    const opt = document.createElement('option');
                    opt.value = colId;
                    opt.textContent = exists ? `${colId} (exists)` : colId;
                    opt.disabled = exists;
                    gridSelect.appendChild(opt);
                }
            }

            // Populate floors (exclude GF - can't plant at ground)
            floorSelect.innerHTML = '';
            state.floors.forEach(floor => {
                if (floor.id === 'GF') return;
                const opt = document.createElement('option');
                opt.value = floor.id;
                opt.textContent = floor.id;
                floorSelect.appendChild(opt);
            });

            // v3.0: Handle preset coordinates from click-to-place
            if (presetX !== null && presetY !== null) {
                // Switch to custom mode and fill coordinates
                setPCPlacementMode('custom');
                document.getElementById('pcCustomX').value = presetX.toFixed(2);
                document.getElementById('pcCustomY').value = presetY.toFixed(2);
            } else {
                // Reset to grid mode
                setPCPlacementMode('grid');
                document.getElementById('pcCustomX').value = '0';
                document.getElementById('pcCustomY').value = '0';
            }

            // Show modal
            modal.style.display = 'flex';
        }

        /**
         * Hide planted column dialog
         */
        function hidePlantedColumnDialog() {
            document.getElementById('plantedColumnModal').style.display = 'none';
        }

        /**
         * Add new planted column from dialog
         * Supports both grid location mode and custom X,Y mode
         */
        function addPlantedColumn() {
            const startFloor = document.getElementById('pcStartFloor').value;
            const widthB = parseInt(document.getElementById('pcWidthB').value) || 300;
            const depthH = parseInt(document.getElementById('pcDepthH').value) || 300;

            if (!startFloor) {
                alert('Please select a starting floor.');
                return;
            }

            let x, y, colId;

            if (pcPlacementMode === 'custom') {
                // Custom X,Y mode
                x = parseFloat(document.getElementById('pcCustomX').value);
                y = parseFloat(document.getElementById('pcCustomY').value);

                if (isNaN(x) || isNaN(y) || x < 0 || y < 0) {
                    alert('Please enter valid X and Y coordinates (≥ 0).');
                    return;
                }

                // v3.0 FIX: Validate that position is on a beam (planted cols MUST be on beams)
                const tolerance = 0.05; // 5cm tolerance
                const currentFloor = state.floors[state.currentFloorIndex];
                const allBeams = [...(state.beams || []), ...(currentFloor?.customBeams || [])];

                const isOnBeam = allBeams.some(beam => {
                    if (beam.direction === 'X' || beam.dir === 'X') {
                        // Horizontal beam: check Y matches and X is within range
                        const bY = beam.y1 ?? beam.pos;
                        const bX1 = Math.min(beam.x1 ?? beam.start, beam.x2 ?? beam.end);
                        const bX2 = Math.max(beam.x1 ?? beam.start, beam.x2 ?? beam.end);
                        return Math.abs(y - bY) < tolerance && x >= bX1 - tolerance && x <= bX2 + tolerance;
                    } else {
                        // Vertical beam: check X matches and Y is within range
                        const bX = beam.x1 ?? beam.pos;
                        const bY1 = Math.min(beam.y1 ?? beam.start, beam.y2 ?? beam.end);
                        const bY2 = Math.max(beam.y1 ?? beam.start, beam.y2 ?? beam.end);
                        return Math.abs(x - bX) < tolerance && y >= bY1 - tolerance && y <= bY2 + tolerance;
                    }
                });

                if (!isOnBeam) {
                    alert('⚠️ Planted columns must be placed ON a beam!\n\nUse the "🎯 Click a Beam" mode (Planted Col button) to place columns directly on beams.');
                    return;
                }

                // Generate unique ID for custom column (PC = Planted Custom)
                let customId = 1;
                while (state.columns.some(c => c.id === `PC${customId}`)) {
                    customId++;
                }
                colId = `PC${customId}`;

                // Check if there's already a column at these exact coordinates
                const existingAtPos = state.columns.find(c =>
                    Math.abs(c.x - x) < 0.01 && Math.abs(c.y - y) < 0.01
                );
                if (existingAtPos) {
                    alert(`Column ${existingAtPos.id} already exists at approximately (${x.toFixed(2)}, ${y.toFixed(2)}).`);
                    return;
                }

            } else {
                // Grid location mode
                const gridLocation = document.getElementById('pcGridLocation').value;

                if (!gridLocation) {
                    alert('Please select a grid location.');
                    return;
                }

                // Check if column already exists
                const existingCol = state.columns.find(c => c.id === gridLocation);
                if (existingCol) {
                    alert(`Column ${gridLocation} already exists.`);
                    return;
                }

                // Parse grid location to get x/y coordinates
                const match = gridLocation.match(/^([A-Z]+)(\d+)$/);
                if (!match) {
                    alert('Invalid grid location format.');
                    return;
                }

                const xLabel = match[1];
                const yLabel = match[2];

                // Generate labels from state.xSpans/ySpans
                const COLUMN_LETTERS = 'ABCDEFGHJKLMNPQRSTUVWXYZ';
                const numXGridlines = (state.xSpans?.length || 0) + 1;
                const numYGridlines = (state.ySpans?.length || 0) + 1;

                const xLabels = [];
                for (let i = 0; i < numXGridlines && i < COLUMN_LETTERS.length; i++) {
                    xLabels.push(COLUMN_LETTERS[i]);
                }
                const yLabels = [];
                for (let i = 0; i < numYGridlines; i++) {
                    yLabels.push(String(i + 1));
                }

                // Get spans directly from state
                const xSpans = state.xSpans || [];
                const ySpans = state.ySpans || [];

                const xIdx = xLabels.indexOf(xLabel);
                const yIdx = yLabels.indexOf(yLabel);

                if (xIdx === -1 || yIdx === -1) {
                    alert('Grid location not found.');
                    return;
                }

                // Calculate coordinates
                x = 0;
                for (let i = 0; i < xIdx && i < xSpans.length; i++) {
                    x += xSpans[i];
                }

                y = 0;
                for (let i = 0; i < yIdx && i < ySpans.length; i++) {
                    y += ySpans[i];
                }

                colId = gridLocation;
            }

            // Create planted column
            const newCol = {
                id: colId,
                x: x,
                y: y,
                bx: widthB,
                by: depthH,
                totalLoad: 0,
                startFloor: startFloor, // This makes it a planted column
                floorActive: {},  // Will be set active from startFloor upward
                isPlanted: true, // v3.0 FIX: Required for persistence after calculate()
                isCustomPlaced: pcPlacementMode === 'custom' // Track if manually placed
            };

            // Set active only on floors from startFloor upward
            let foundStartFloor = false;
            state.floors.forEach(floor => {
                if (floor.id === startFloor) foundStartFloor = true;
                newCol.floorActive[floor.id] = foundStartFloor;
            });

            // Add to state
            state.columns.push(newCol);

            // Add to undo stack
            state.undoStack.push({
                type: 'columnAdd',
                data: newCol
            });
            updateUndoButton();

            const modeLabel = pcPlacementMode === 'custom' ? 'custom placement' : 'grid location';
            console.log(`v3.0: Added planted column ${colId} at (${x.toFixed(2)}, ${y.toFixed(2)}), starting from floor ${startFloor}, size ${widthB}×${depthH}mm [${modeLabel}]`);

            hidePlantedColumnDialog();
            calculate();
        }

        // ========================================
        // v3.0: BEAM-CLICK PLANTED COLUMN PLACEMENT
        // ========================================

        /**
         * Enter planted column placement mode
         * User clicks a beam to place column on it
         */
        function enterPlantedColumnMode() {
            placingPlantedColumn = true;
            canvas.style.cursor = 'crosshair';

            // Update button appearance
            const btn = document.getElementById('addPlantedColBtn');
            if (btn) {
                btn.style.background = 'linear-gradient(135deg, #10b981, #059669)';
                btn.innerHTML = '🎯 Click a Beam';
            }

            console.log('v3.0: Entered planted column placement mode - click on a beam');
        }

        /**
         * Toggle planted column placement mode (called by button)
         * Shift+Click opens old dialog for grid/custom placement
         */
        function togglePlantedColumnMode(event) {
            if (event && event.shiftKey) {
                // Shift+Click: Open original dialog for grid/custom placement
                showPlantedColumnDialog();
                return;
            }

            if (placingPlantedColumn) {
                exitPlantedColumnMode();
            } else {
                enterPlantedColumnMode();
            }
        }

        /**
         * Exit planted column placement mode
         */
        function exitPlantedColumnMode() {
            placingPlantedColumn = false;
            selectedBeamForPC = null;
            canvas.style.cursor = 'default';

            // Restore button appearance
            const btn = document.getElementById('addPlantedColBtn');
            if (btn) {
                btn.style.background = 'linear-gradient(135deg, #8b5cf6, #6366f1)';
                btn.innerHTML = '⏫ Planted Col';
            }

            console.log('v3.0: Exited planted column placement mode');
        }

        /**
         * Show beam offset dialog when beam is clicked in placement mode
         */
        function showBeamOffsetDialog(beam) {
            selectedBeamForPC = beam;

            // Update beam info display
            const beamInfoEl = document.getElementById('pcBeamInfo');
            const directionEl = document.getElementById('pcOffsetDirection');
            const rangeEl = document.getElementById('pcOffsetRange');

            if (beam.direction === 'X') {
                beamInfoEl.textContent = `${beam.id} (Horizontal, ${beam.span.toFixed(1)}m)`;
                directionEl.textContent = '→ Left to Right';
            } else {
                beamInfoEl.textContent = `${beam.id} (Vertical, ${beam.span.toFixed(1)}m)`;
                directionEl.textContent = '↓ Top to Bottom';
            }

            // Set max offset to beam span
            const offsetInput = document.getElementById('pcBeamOffset');
            offsetInput.max = beam.span - 0.1;
            offsetInput.value = Math.min(1.0, beam.span / 2).toFixed(1);
            rangeEl.textContent = `Range: 0.1 - ${(beam.span - 0.1).toFixed(1)} m`;

            // Populate floor dropdown (exclude current floor - column starts above)
            const floorSelect = document.getElementById('pcBeamStartFloor');
            floorSelect.innerHTML = '';
            const currentFloor = state.floors[state.currentFloorIndex];
            state.floors.forEach(floor => {
                if (floor.id === currentFloor?.id) return; // Skip current floor
                const opt = document.createElement('option');
                opt.value = floor.id;
                opt.textContent = floor.id;
                floorSelect.appendChild(opt);
            });

            // Show modal
            document.getElementById('beamOffsetModal').style.display = 'flex';
        }

        /**
         * Hide beam offset dialog
         */
        function hideBeamOffsetDialog() {
            document.getElementById('beamOffsetModal').style.display = 'none';
            selectedBeamForPC = null;
            exitPlantedColumnMode();
        }

        /**
         * Place planted column on the selected beam at specified offset
         */
        function placePlantedColumnOnBeam() {
            if (!selectedBeamForPC) {
                alert('No beam selected.');
                return;
            }

            const beam = selectedBeamForPC;
            const offset = parseFloat(document.getElementById('pcBeamOffset').value) || 1.0;
            const startFloor = document.getElementById('pcBeamStartFloor').value;
            const widthB = parseInt(document.getElementById('pcBeamColB').value) || 250;
            const depthH = parseInt(document.getElementById('pcBeamColH').value) || 250;

            // Validate offset
            if (offset <= 0 || offset >= beam.span) {
                alert(`Offset must be between 0.1 and ${(beam.span - 0.1).toFixed(1)}m`);
                return;
            }

            if (!startFloor) {
                alert('Please select a start floor.');
                return;
            }

            // Calculate position based on beam direction
            let x, y;
            if (beam.direction === 'X') {
                // Horizontal beam: offset from left (x1) to right
                x = Math.min(beam.x1, beam.x2) + offset;
                y = beam.y1; // Y is constant for horizontal beam
            } else {
                // Vertical beam: offset from top (y1) to bottom
                x = beam.x1; // X is constant for vertical beam
                y = Math.min(beam.y1, beam.y2) + offset;
            }

            // Generate column ID
            const customId = state.columns.length + 1;
            const colId = `PC${customId}`;

            // Check for existing column at position
            const existingAtPos = state.columns.find(c =>
                Math.abs(c.x - x) < 0.2 && Math.abs(c.y - y) < 0.2
            );
            if (existingAtPos) {
                alert(`Column ${existingAtPos.id} already exists near (${x.toFixed(2)}, ${y.toFixed(2)}).`);
                return;
            }

            // Create planted column
            const newCol = {
                id: colId,
                x: x,
                y: y,
                bx: widthB,
                by: depthH,
                suggestedB: widthB,
                suggestedH: depthH,
                totalLoad: 0,
                startFloor: startFloor,
                floorActive: {},
                isPlanted: true,
                supportingBeamId: beam.id, // Track which beam supports this column
                offsetOnBeam: offset       // Track offset along beam
            };

            // Set active only on floors from startFloor upward
            let foundStartFloor = false;
            state.floors.forEach(floor => {
                if (floor.id === startFloor) foundStartFloor = true;
                newCol.floorActive[floor.id] = foundStartFloor;
            });

            // Add to state
            state.columns.push(newCol);

            // Add to undo stack
            state.undoStack.push({
                type: 'columnAdd',
                data: newCol,
                floorId: startFloor
            });
            updateUndoButton();

            console.log(`v3.0: Added planted column ${colId} on beam ${beam.id} at offset ${offset.toFixed(2)}m, position (${x.toFixed(2)}, ${y.toFixed(2)}), starting from floor ${startFloor}`);

            hideBeamOffsetDialog();
            calculate();
        }


        // ========================================
        // v3.0: SCHEDULES MODAL
        // ========================================

        let currentScheduleTab = 'beams';

        /**
         * Show schedules modal and populate tables
         */
        function showSchedulesModal() {
            const modal = document.getElementById('schedulesModal');
            modal.style.display = 'flex';
            populateScheduleTables();
        }

        /**
         * Hide schedules modal
         */
        function hideSchedulesModal() {
            document.getElementById('schedulesModal').style.display = 'none';
        }

        /**
         * Switch between beam and column schedule tabs
         */
        function switchScheduleTab(tab) {
            currentScheduleTab = tab;
            document.getElementById('schedTabBeams').classList.toggle('active', tab === 'beams');
            document.getElementById('schedTabColumns').classList.toggle('active', tab === 'columns');
            document.getElementById('scheduleBeamsPanel').style.display = tab === 'beams' ? 'block' : 'none';
            document.getElementById('scheduleColumnsPanel').style.display = tab === 'columns' ? 'block' : 'none';
        }

        /**
         * Populate schedule tables with current data
         */
        function populateScheduleTables() {
            // Beam schedule
            const beamsBody = document.getElementById('scheduleBeamsBody');
            beamsBody.innerHTML = '';

            state.beams.filter(b => !b.deleted).forEach(beam => {
                const size = beam.bSize && beam.hSize ? `${beam.bSize}×${beam.hSize}` : '-';
                const row = document.createElement('tr');
                row.innerHTML = `
                    <td>${beam.id}</td>
                    <td>${beam.direction || '-'}</td>
                    <td>${beam.span?.toFixed(2) || '-'}</td>
                    <td>${size}</td>
                    <td>${beam.startCol || '-'}</td>
                    <td>${beam.endCol || '-'}</td>
                    <td>${beam.w?.toFixed(1) || '-'}</td>
                    <td>${beam.Rleft ? ((beam.Rleft + beam.Rright) / 2).toFixed(1) : '-'}</td>
                `;
                beamsBody.appendChild(row);
            });

            // Custom beams
            const customBeams = getFloorCustomBeams();
            customBeams.forEach(cb => {
                const row = document.createElement('tr');
                row.style.background = 'rgba(249, 115, 22, 0.1)';
                row.innerHTML = `
                    <td>${cb.id} (custom)</td>
                    <td>${cb.dir}</td>
                    <td>${cb.span?.toFixed(2) || '-'}</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                    <td>-</td>
                `;
                beamsBody.appendChild(row);
            });

            // Column schedule
            const colsBody = document.getElementById('scheduleColumnsBody');
            colsBody.innerHTML = '';

            state.columns.forEach(col => {
                // Determine floors where column is active
                const activeFloors = state.floors
                    .filter(f => col.floorActive?.[f.id] !== false)
                    .map(f => f.id)
                    .join(', ') || 'All';

                const planted = col.startFloor ? `Yes @ ${col.startFloor}` : 'No';
                const size = col.size ? `${col.size}×${col.size}` : '-';
                const footing = col.footingSize ? col.footingSize.toFixed(2) : '-';

                const row = document.createElement('tr');
                if (col.startFloor) row.style.background = 'rgba(245, 158, 11, 0.1)';
                row.innerHTML = `
                    <td>${col.id}</td>
                    <td>${col.type || '-'}</td>
                    <td>${size}</td>
                    <td>${col.totalLoad?.toFixed(1) || '-'}</td>
                    <td>${footing}</td>
                    <td>${planted}</td>
                    <td>${activeFloors}</td>
                `;
                colsBody.appendChild(row);
            });
        }

        /**
         * Export current schedule tab as CSV
         */
        function exportScheduleCSV() {
            let csvContent = '';
            let filename = '';

            if (currentScheduleTab === 'beams') {
                filename = 'beam_schedule.csv';
                csvContent = 'Beam ID,Direction,Span (m),Size (mm),Start Col,End Col,w (kN/m),R (kN)\n';

                state.beams.filter(b => !b.deleted).forEach(beam => {
                    const size = beam.bSize && beam.hSize ? `${beam.bSize}x${beam.hSize}` : '-';
                    csvContent += `${beam.id},${beam.direction || '-'},${beam.span?.toFixed(2) || '-'},${size},${beam.startCol || '-'},${beam.endCol || '-'},${beam.w?.toFixed(1) || '-'},${beam.Rleft ? ((beam.Rleft + beam.Rright) / 2).toFixed(1) : '-'}\n`;
                });

                // Custom beams
                const customBeams = getFloorCustomBeams();
                customBeams.forEach(cb => {
                    csvContent += `${cb.id} (custom),${cb.dir},${cb.span?.toFixed(2) || '-'},-,-,-,-,-\n`;
                });
            } else {
                filename = 'column_schedule.csv';
                csvContent = 'Col ID,Type,Size (mm),Total Load (kN),Footing (m),Planted,Floors Active\n';

                state.columns.forEach(col => {
                    const activeFloors = state.floors
                        .filter(f => col.floorActive?.[f.id] !== false)
                        .map(f => f.id)
                        .join('/') || 'All';

                    const planted = col.startFloor ? `Yes @ ${col.startFloor}` : 'No';
                    const size = col.size ? `${col.size}x${col.size}` : '-';
                    const footing = col.footingSize ? col.footingSize.toFixed(2) : '-';

                    csvContent += `${col.id},${col.type || '-'},${size},${col.totalLoad?.toFixed(1) || '-'},${footing},${planted},${activeFloors}\n`;
                });
            }

            // Download
            const blob = new Blob([csvContent], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = filename;
            a.click();
            URL.revokeObjectURL(url);

            console.log(`v3.0: Exported ${filename}`);
        }
    </script>

    <!-- ========== RESIDENT ETHOS AI ASSISTANT ========== -->
    <style>
        /* Floating Action Button - Modern Glowing Entity */
        .ethos-fab {
            position: fixed;
            bottom: 60px;
            right: 24px;
            width: 60px;
            height: 60px;
            border-radius: 50%;
            /* Glassmorphism + Glow */
            background: rgba(124, 58, 237, 0.15);
            backdrop-filter: blur(12px);
            -webkit-backdrop-filter: blur(12px);
            border: 1px solid rgba(124, 58, 237, 0.3);
            color: #a78bfa;
            font-size: 26px;
            cursor: pointer;
            /* Multi-layer glow effect */
            box-shadow:
                0 0 20px rgba(124, 58, 237, 0.4),
                0 0 40px rgba(79, 70, 229, 0.2),
                0 0 60px rgba(139, 92, 246, 0.1),
                inset 0 0 20px rgba(167, 139, 250, 0.1);
            z-index: 9999;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            /* Pulsing animation */
            animation: ethosGlow 3s ease-in-out infinite;
        }

        @keyframes ethosGlow {

            0%,
            100% {
                box-shadow:
                    0 0 20px rgba(124, 58, 237, 0.4),
                    0 0 40px rgba(79, 70, 229, 0.2),
                    0 0 60px rgba(139, 92, 246, 0.1),
                    inset 0 0 20px rgba(167, 139, 250, 0.1);
                transform: scale(1);
            }

            50% {
                box-shadow:
                    0 0 30px rgba(124, 58, 237, 0.6),
                    0 0 60px rgba(79, 70, 229, 0.3),
                    0 0 80px rgba(139, 92, 246, 0.2),
                    inset 0 0 30px rgba(167, 139, 250, 0.15);
                transform: scale(1.05);
            }
        }

        .ethos-fab:hover {
            transform: scale(1.15);
            background: rgba(124, 58, 237, 0.25);
            box-shadow:
                0 0 40px rgba(124, 58, 237, 0.7),
                0 0 80px rgba(79, 70, 229, 0.4),
                0 0 100px rgba(139, 92, 246, 0.3),
                inset 0 0 30px rgba(167, 139, 250, 0.2);
            animation: none;
        }

        .ethos-fab.hidden {
            transform: scale(0);
            opacity: 0;
            pointer-events: none;
        }

        /* Panel */
        .ethos-panel {
            position: fixed;
            bottom: 60px;
            right: 24px;
            width: 380px;
            height: 480px;
            background: var(--panel-bg, #161b22);
            border: 1px solid var(--border, #21262d);
            border-radius: 16px;
            box-shadow: 0 8px 40px rgba(0, 0, 0, 0.4);
            z-index: 10000;
            display: flex;
            flex-direction: column;
            opacity: 0;
            transform: translateY(20px) scale(0.95);
            pointer-events: none;
            transition: all 0.3s ease;
        }

        .ethos-panel.open {
            opacity: 1;
            transform: translateY(0) scale(1);
            pointer-events: all;
        }

        .ethos-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 12px 16px;
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            border-radius: 16px 16px 0 0;
            color: white;
        }

        .ethos-title {
            display: flex;
            align-items: center;
            gap: 8px;
            font-weight: 600;
        }

        .ethos-controls {
            display: flex;
            gap: 4px;
        }

        .ethos-btn {
            background: rgba(255, 255, 255, 0.2);
            border: none;
            padding: 6px 8px;
            border-radius: 6px;
            cursor: pointer;
            color: white;
            font-size: 14px;
        }

        .ethos-btn:hover {
            background: rgba(255, 255, 255, 0.3);
        }

        .ethos-messages {
            flex: 1;
            overflow-y: auto;
            padding: 16px;
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .ethos-welcome {
            background: var(--glass, rgba(0, 0, 0, 0.2));
            padding: 12px;
            border-radius: 12px;
            color: var(--text-muted, #8b949e);
            font-size: 13px;
        }

        .ethos-message {
            max-width: 85%;
            padding: 10px 14px;
            border-radius: 12px;
            font-size: 14px;
            line-height: 1.5;
            word-wrap: break-word;
        }

        .ethos-message.user {
            align-self: flex-end;
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            color: white;
            border-bottom-right-radius: 4px;
        }

        .ethos-message.assistant {
            align-self: flex-start;
            background: var(--glass, rgba(0, 0, 0, 0.3));
            color: var(--text-primary, #e6edf3);
            border-bottom-left-radius: 4px;
        }

        .ethos-message.error {
            background: #dc2626;
            color: white;
        }

        .ethos-message.loading {
            color: var(--text-muted, #8b949e);
        }

        .ethos-message.loading::after {
            content: '...';
            animation: dots 1s infinite;
        }

        @keyframes dots {

            0%,
            20% {
                content: '.';
            }

            40% {
                content: '..';
            }

            60%,
            100% {
                content: '...';
            }
        }

        .ethos-input-area {
            display: flex;
            gap: 8px;
            padding: 12px 16px;
            border-top: 1px solid var(--border, #21262d);
        }

        #ethosInput {
            flex: 1;
            padding: 10px 14px;
            border: 1px solid var(--border, #21262d);
            border-radius: 8px;
            background: var(--glass, rgba(0, 0, 0, 0.3));
            color: var(--text-primary, #e6edf3);
            font-size: 14px;
        }

        #ethosInput:focus {
            outline: none;
            border-color: #7c3aed;
        }

        .ethos-send-btn {
            padding: 10px 16px;
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            border: none;
            border-radius: 8px;
            color: white;
            cursor: pointer;
            font-size: 16px;
        }

        .ethos-send-btn:disabled {
            opacity: 0.5;
        }

        .ethos-api-setup {
            padding: 16px;
            background: var(--glass, rgba(0, 0, 0, 0.2));
            border-top: 1px solid var(--border, #21262d);
            text-align: center;
        }

        .ethos-api-setup p {
            margin: 8px 0;
            color: var(--text-muted, #8b949e);
            font-size: 13px;
        }

        .ethos-api-setup input {
            width: 100%;
            padding: 10px;
            margin: 8px 0;
            border: 1px solid var(--border, #21262d);
            border-radius: 6px;
            background: var(--glass-darker, rgba(0, 0, 0, 0.3));
            color: var(--text-primary, #e6edf3);
        }

        .ethos-api-setup button {
            padding: 10px 20px;
            background: linear-gradient(135deg, #7c3aed, #4f46e5);
            border: none;
            border-radius: 6px;
            color: white;
            cursor: pointer;
        }

        .ethos-hint a {
            color: #7c3aed;
        }
    </style>

    <!-- Resident Ethos UI -->
    <button id="ethosFab" class="ethos-fab" title="Resident Ethos - AI Assistant">AI</button>
    <div id="ethosPanel" class="ethos-panel">
        <div class="ethos-header">
            <div class="ethos-title"><span>🤖</span><span>Resident Ethos</span></div>
            <div class="ethos-controls">
                <button class="ethos-btn" id="ethosClear" title="Clear">🗑️</button>
                <button class="ethos-btn" id="ethosSettings" title="Settings">⚙️</button>
                <button class="ethos-btn" id="ethosClose" title="Close">✕</button>
            </div>
        </div>
        <div class="ethos-messages" id="ethosMessages">
            <div class="ethos-welcome">
                <p>👋 Hello! I'm <strong>Resident Ethos</strong>, your AI structural engineering assistant.</p>
                <p>Ask me about your structure, NSCP code, or calculations!</p>
            </div>
        </div>
        <div class="ethos-input-area" id="ethosInputArea">
            <input type="text" id="ethosInput" placeholder="Ask about your structure..." />
            <button id="ethosSend" class="ethos-send-btn">➤</button>
        </div>
        <div class="ethos-api-setup" id="ethosApiSetup" style="display:none;">
            <p>🔑 Enter your Gemini API key:</p>
            <input type="password" id="ethosApiKeyInput" placeholder="AIza..." />
            <button id="ethosApiKeySave">Save Key</button>
            <p class="ethos-hint">Get a free key at <a href="https://aistudio.google.com/apikey" target="_blank">AI
                    Studio</a></p>
        </div>
    </div>

    <script>
        // ========== RESIDENT ETHOS ENGINE ==========
        const ETHOS = {
            apiKey: localStorage.getItem('residentEthosApiKey'),
            history: [],
            isLoading: false,

            SYSTEM_PROMPT: `You are Resident Ethos, an AI structural engineering assistant in Tributary Pro v3.0.
Tributary Pro calculates column loads, beam reactions, and footing sizes per NSCP 2015 (Philippines).

You can access the current project state. Be concise, technical, use engineering terms.
Reference NSCP sections when applicable. Format numbers with units (kN, mm, m).`,

            // Get project state
            getState() {
                return {
                    grid: { xSpans: state.xSpans, ySpans: state.ySpans },
                    floors: state.floors.map(f => ({ id: f.id, height: f.height, load: f.load })),
                    columns: state.columns.filter(c => c.active !== false).length,
                    settings: { fc: state.fc, fy: state.fy, sbc: state.sbc }
                };
            },

            getColumnLoads() {
                return state.columns.filter(c => c.active !== false).map(c => ({
                    id: c.id, type: c.type,
                    load: c.totalLoad ? c.totalLoad.toFixed(1) + ' kN' : 'N/A',
                    size: c.suggestedB ? `${c.suggestedB}x${c.suggestedH} mm` : 'N/A'
                }));
            },

            // ========== ACTION FUNCTIONS ==========

            setXSpans(values) {
                if (!Array.isArray(values)) return { success: false, error: 'values must be an array' };
                state.xSpans = values.map(v => parseFloat(v));
                if (typeof renderSpans === 'function') renderSpans();
                if (typeof calculate === 'function') calculate();
                return { success: true, message: `✅ Set ${state.xSpans.length} X-spans: ${state.xSpans.join('m, ')}m` };
            },

            setYSpans(values) {
                if (!Array.isArray(values)) return { success: false, error: 'values must be an array' };
                state.ySpans = values.map(v => parseFloat(v));
                if (typeof renderSpans === 'function') renderSpans();
                if (typeof calculate === 'function') calculate();
                return { success: true, message: `✅ Set ${state.ySpans.length} Y-spans: ${state.ySpans.join('m, ')}m` };
            },

            setFloorCount(count) {
                const target = parseInt(count);
                if (target < 1 || target > 10) return { success: false, error: 'Floor count must be 1-10' };
                while (state.floors.length < target) { if (typeof addFloor === 'function') addFloor(); else break; }
                while (state.floors.length > target) { if (typeof removeFloor === 'function') removeFloor(); else break; }
                return { success: true, message: `✅ Set to ${state.floors.length} floors` };
            },

            runCalculation() {
                if (typeof calculate === 'function') {
                    calculate();
                    const maxLoad = state.columns.length > 0
                        ? Math.max(...state.columns.filter(c => c.active !== false).map(c => c.totalLoad || 0))
                        : 0;
                    return { success: true, message: `✅ Calculation complete!\n📊 Max column load: ${maxLoad.toFixed(1)} kN\n🏛️ Active columns: ${state.columns.filter(c => c.active !== false).length}` };
                }
                return { success: false, error: 'calculate function not available' };
            },

            exportProject(format) {
                const fmt = format.toUpperCase();
                if (fmt === 'STAAD' && typeof exportToSTAAD === 'function') {
                    exportToSTAAD();
                    return { success: true, message: '✅ Exported to STAAD format (download started)' };
                } else if (fmt === 'ETABS' && typeof exportToETABS === 'function') {
                    exportToETABS();
                    return { success: true, message: '✅ Exported to ETABS format (download started)' };
                }
                return { success: false, error: `Unknown format: ${format}. Use STAAD or ETABS.` };
            },

            setLiveLoad(value) {
                const ll = parseFloat(value);
                if (isNaN(ll) || ll < 0 || ll > 20) return { success: false, error: 'Live load must be 0-20 kPa' };
                state.LL = ll;
                const llInput = document.getElementById('LL');
                if (llInput) llInput.value = ll;
                if (typeof calculate === 'function') calculate();
                return { success: true, message: `✅ Live load set to ${ll} kPa` };
            },

            // ========== COMMAND PARSER ==========
            parseCommand(msg) {
                const lower = msg.toLowerCase();

                // Set X spans: "set x spans to 4, 5, 4" or "x spans 4m 5m 4m"
                let match = lower.match(/(?:set\s+)?x\s*spans?\s*(?:to\s+)?([\d.,\s]+)/);
                if (match) {
                    const values = match[1].split(/[\s,]+/).map(v => parseFloat(v.replace('m', ''))).filter(v => !isNaN(v) && v > 0);
                    if (values.length > 0) return this.setXSpans(values);
                }

                // Set Y spans
                match = lower.match(/(?:set\s+)?y\s*spans?\s*(?:to\s+)?([\d.,\s]+)/);
                if (match) {
                    const values = match[1].split(/[\s,]+/).map(v => parseFloat(v.replace('m', ''))).filter(v => !isNaN(v) && v > 0);
                    if (values.length > 0) return this.setYSpans(values);
                }

                // Set floor count: "set to 4 floors" or "4 floors" or "add 3 floors"
                match = lower.match(/(\d+)\s*(?:storeys?|floors?)/);
                if (match && (lower.includes('set') || lower.includes('make') || lower.includes('floors'))) {
                    return this.setFloorCount(parseInt(match[1]));
                }

                // Calculate: "calculate" or "run calculation"
                if (lower.includes('calculate') || lower.includes('run calc') || lower.includes('compute')) {
                    return this.runCalculation();
                }

                // Export: "export to staad" or "staad export"
                if (lower.includes('export') && lower.includes('staad')) {
                    return this.exportProject('STAAD');
                }
                if (lower.includes('export') && lower.includes('etabs')) {
                    return this.exportProject('ETABS');
                }

                // Set live load: "set live load to 2.4" or "LL 2.4 kpa"
                match = lower.match(/(?:set\s+)?(?:live\s*load|ll)\s*(?:to\s+)?([\d.]+)/);
                if (match) {
                    return this.setLiveLoad(parseFloat(match[1]));
                }

                return null; // No command matched
            },

            // Chat with Gemini
            async chat(message) {
                if (!this.apiKey) return { success: false, error: 'API key not set' };

                // v3.0: Check for action commands FIRST
                const cmdResult = this.parseCommand(message);
                if (cmdResult) {
                    this.history.push({ role: 'user', parts: [{ text: message }] });
                    this.history.push({ role: 'model', parts: [{ text: cmdResult.message || cmdResult.error }] });
                    return cmdResult;
                }

                this.history.push({ role: 'user', parts: [{ text: message }] });

                // Check for local queries
                const lower = message.toLowerCase();
                if (lower.includes('span') || lower.includes('grid')) {
                    const s = this.getState();
                    return {
                        success: true, message:
                            `📏 **Current Grid:**\n- X Spans: ${s.grid.xSpans.join(', ')} m\n- Y Spans: ${s.grid.ySpans.join(', ')} m\n- Total X: ${s.grid.xSpans.reduce((a, b) => a + b, 0).toFixed(1)} m\n- Total Y: ${s.grid.ySpans.reduce((a, b) => a + b, 0).toFixed(1)} m`
                    };
                }
                if (lower.includes('column') && lower.includes('load')) {
                    const cols = this.getColumnLoads().slice(0, 8);
                    return {
                        success: true, message:
                            `🏗️ **Column Loads (first 8):**\n${cols.map(c => `- ${c.id}: ${c.load} → ${c.size}`).join('\n')}`
                    };
                }
                if (lower.includes('floor') || lower.includes('storey')) {
                    const s = this.getState();
                    return {
                        success: true, message:
                            `🏢 **Floors:** ${s.floors.length}\n${s.floors.map(f => `- ${f.id}: H=${f.height}m, Load=${f.load} kN/m²`).join('\n')}`
                    };
                }

                try {
                    const response = await fetch(`https://generativelanguage.googleapis.com/v1beta/models/gemini-2.0-flash:generateContent?key=${this.apiKey}`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({
                            system_instruction: { parts: [{ text: this.SYSTEM_PROMPT + '\n\nCurrent State: ' + JSON.stringify(this.getState()) }] },
                            contents: this.history
                        })
                    });

                    if (!response.ok) {
                        const err = await response.json();
                        throw new Error(err.error?.message || 'API error');
                    }

                    const data = await response.json();
                    const text = data.candidates?.[0]?.content?.parts?.[0]?.text || 'No response';

                    this.history.push({ role: 'model', parts: [{ text }] });
                    return { success: true, message: text };

                } catch (e) {
                    this.history.pop();
                    return { success: false, error: e.message };
                }
            }
        };

        // ========== UI LOGIC ==========
        document.addEventListener('DOMContentLoaded', () => {
            const fab = document.getElementById('ethosFab');
            const panel = document.getElementById('ethosPanel');
            const closeBtn = document.getElementById('ethosClose');
            const clearBtn = document.getElementById('ethosClear');
            const settingsBtn = document.getElementById('ethosSettings');
            const sendBtn = document.getElementById('ethosSend');
            const input = document.getElementById('ethosInput');
            const messages = document.getElementById('ethosMessages');
            const apiSetup = document.getElementById('ethosApiSetup');
            const inputArea = document.getElementById('ethosInputArea');
            const apiSaveBtn = document.getElementById('ethosApiKeySave');

            // Open/Close panel
            fab.onclick = () => { panel.classList.add('open'); fab.classList.add('hidden'); input.focus(); };
            closeBtn.onclick = () => { panel.classList.remove('open'); fab.classList.remove('hidden'); };

            // Clear chat
            clearBtn.onclick = () => {
                ETHOS.history = [];
                messages.innerHTML = '<div class="ethos-welcome"><p>👋 Chat cleared! How can I help?</p></div>';
            };

            // Settings
            settingsBtn.onclick = () => {
                apiSetup.style.display = 'block';
                inputArea.style.display = 'none';
            };

            // Save API key
            apiSaveBtn.onclick = () => {
                const key = document.getElementById('ethosApiKeyInput').value.trim();
                if (key) {
                    ETHOS.apiKey = key;
                    localStorage.setItem('residentEthosApiKey', key);
                    apiSetup.style.display = 'none';
                    inputArea.style.display = 'flex';
                    addMsg('assistant', '✅ API key saved! Ready to help.');
                }
            };

            // Check API key on load
            if (!ETHOS.apiKey) {
                apiSetup.style.display = 'block';
                inputArea.style.display = 'none';
            }

            // Send message
            const sendMessage = async () => {
                if (ETHOS.isLoading) return;
                const text = input.value.trim();
                if (!text) return;
                if (!ETHOS.apiKey) { settingsBtn.click(); return; }

                input.value = '';
                addMsg('user', text);

                ETHOS.isLoading = true;
                sendBtn.disabled = true;
                const loading = addMsg('loading', 'Thinking');

                const result = await ETHOS.chat(text);
                loading.remove();

                if (result.success) addMsg('assistant', result.message);
                else addMsg('error', '❌ ' + result.error);

                ETHOS.isLoading = false;
                sendBtn.disabled = false;
                input.focus();
            };

            sendBtn.onclick = sendMessage;
            input.onkeydown = (e) => { if (e.key === 'Enter') sendMessage(); };

            function addMsg(type, text) {
                const div = document.createElement('div');
                div.className = 'ethos-message ' + type;
                div.textContent = text;
                messages.appendChild(div);
                messages.scrollTop = messages.scrollHeight;
                return div;
            }

            console.log('🤖 Resident Ethos initialized');

            // v3.3: Hamburger Dropdown Logic
            window.toggleDropdown = function () {
                const dd = document.getElementById('settingsDropdown');
                if (dd) dd.classList.toggle('hidden');
            };

            // Close dropdown when clicking outside
            document.addEventListener('click', function (event) {
                const dd = document.getElementById('settingsDropdown');
                const btn = document.querySelector('.settings-gear');
                if (dd && !dd.classList.contains('hidden') && !dd.contains(event.target) && !btn.contains(event.target)) {
                    dd.classList.add('hidden');
                }
            });
        });
    </script>

    <!-- Attribution Footer -->

    <footer style="
        position: fixed;
        bottom: 0;
        left: 0;
        right: 0;
        background: linear-gradient(135deg, rgba(15, 23, 42, 0.95), rgba(30, 41, 59, 0.95));
        backdrop-filter: blur(10px);
        border-top: 1px solid rgba(99, 102, 241, 0.3);
        padding: 8px 20px;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-size: 0.75rem;
        color: #94a3b8;
        z-index: 1000;
    ">
        <div style="display: flex; align-items: center; gap: 8px;">
            <span style="color: #6366f1; font-weight: 600;">Tributary Pro</span>
            <span style="opacity: 0.5;">|</span>
            <span>by <strong style="color: #f59e0b;">Engr. Michael D. Futol</strong> & <strong
                    style="color: #ec4899;">Kira Futol</strong></span>
        </div>
        <div style="display: flex; align-items: center; gap: 6px;">
            <span style="
                background: linear-gradient(135deg, #6366f1, #8b5cf6);
                -webkit-background-clip: text;
                -webkit-text-fill-color: transparent;
                font-weight: 600;
            ">Futol Ethical Technology Ecosystems</span>
            <span style="opacity: 0.5;">© 2024-2025</span>
        </div>
    </footer>
</body>

</html>